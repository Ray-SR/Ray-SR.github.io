{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/apple-touch-icon.png","path":"img/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/post.js","path":"js/post.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/1.png","path":"img/Docker/1.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/2.png","path":"img/Docker/2.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/3.png","path":"img/Docker/3.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/4.png","path":"img/Docker/4.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/5.png","path":"img/Docker/5.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/6.png","path":"img/Docker/6.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Docker/7.png","path":"img/Docker/7.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Git/1.jpg","path":"img/Git/1.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Git/3.png","path":"img/Git/3.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/anchor/anchor.min.js","path":"lib/anchor/anchor.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.css","path":"lib/fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/github-markdown/github-markdown.min.css","path":"lib/github-markdown/github-markdown.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/katex/katex.min.css","path":"lib/katex/katex.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/popper/popper.min.js","path":"lib/popper/popper.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/github-v2.min.css","path":"lib/prettify/github-v2.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/prettify.min.js","path":"lib/prettify/prettify.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night-eighties.min.css","path":"lib/prettify/tomorrow-night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night.min.css","path":"lib/prettify/tomorrow-night.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/prettify/tomorrow.min.css","path":"lib/prettify/tomorrow.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/smooth-scroll/smooth-scroll.min.js","path":"lib/smooth-scroll/smooth-scroll.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/tocbot/tocbot.min.js","path":"lib/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/typed/typed.min.js","path":"lib/typed/typed.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/Git/2.png","path":"img/Git/2.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.js","path":"lib/fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/post_banner.jpg","path":"img/post_banner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/bootstrap/js/bootstrap.min.js","path":"lib/bootstrap/js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/bootstrap/css/bootstrap.min.css","path":"lib/bootstrap/css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/js/mdb.min.js","path":"lib/mdbootstrap/js/mdb.min.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","path":"lib/mdbootstrap/font/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/mdbootstrap/css/mdb.min.css","path":"lib/mdbootstrap/css/mdb.min.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"c94cfc71f06d716f7caf321c23854cd536ad6abf","modified":1608521500095},{"_id":"themes/fluid/Changelog.md","hash":"de48dff0ce31da9cb1db889bf5b03a6ffbf60be8","modified":1608521500099},{"_id":"themes/fluid/LICENSE","hash":"77259cff2096bcf2974d2091a28302511b9103f4","modified":1608521500099},{"_id":"themes/fluid/README.md","hash":"db5ef8640c59c7dba5433438841bb46f32984bec","modified":1608521500099},{"_id":"themes/fluid/README_en.md","hash":"dca08de1f6120164c03de47f6e69eba632fd20c0","modified":1608521500099},{"_id":"themes/fluid/_config.yml","hash":"cc634511ed907e364961a96e58281c5237df2274","modified":1608521500099},{"_id":"themes/fluid/_static_prefix.yml","hash":"0660e38bcf06a2c33811f178919dcb855166cbc5","modified":1608521500099},{"_id":"themes/fluid/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"source/_posts/DICOM Tag中文编码问题.md","hash":"6f21b20c81b0f9ff45ef731206660fefde47bdff","modified":1608521500095},{"_id":"source/_posts/Django实现单设备登录限制.md","hash":"e367b9d9969655fa7752e32b22b3268b4dda7ac7","modified":1608521500095},{"_id":"source/_posts/Django实现语言切换.md","hash":"ac609ea6cd4f69cbe9628af8d33d221a23097edb","modified":1608521500095},{"_id":"source/_posts/Docker使用总结.md","hash":"d4b638ac29f6919156da1fb5674926ad063cbbd3","modified":1608521500095},{"_id":"source/_posts/Docker部署Nginx + uWSGI + Django实践.md","hash":"5663361d5d60453ec619a827b801796099ff76d9","modified":1608521500095},{"_id":"source/_posts/Git简介及常用操作.md","hash":"fdc0bffb0deeeb6a8be66c972f86bb2ed9f790ee","modified":1608521500095},{"_id":"source/_posts/Orthanc + OHIF 搭建DICOM web viewer.md","hash":"6dd1d48ee4b71ba73f28d829402ed590457b349e","modified":1608521500095},{"_id":"source/_posts/使用SimpleITK读取DICOM.md","hash":"2849cf0724fd54ac7ed6979727d6718aa62242ce","modified":1608521500095},{"_id":"source/_posts/使用python将PDF转换为DICOM格式.md","hash":"1d159e4ceeb44d6d095bc5c6dfeee031efd895f5","modified":1608521500095},{"_id":"source/about/About me.md","hash":"af33f17b81c0ec3e7869e5d71401ffd282fc74da","modified":1608521500095},{"_id":"source/about/index.md","hash":"b0f67fec0d6499d7929b42bcf759b64cf702e4de","modified":1608521500095},{"_id":"source/categories/index.md","hash":"a2233eca03c8a833cc26b0376dfef0bf78abb960","modified":1608521500095},{"_id":"source/tags/index.md","hash":"34aa544742154e500ec6184a636f47bedd2a9d71","modified":1608521500095},{"_id":"themes/fluid/languages/en.yml","hash":"48fed140dcef596a5cd980b1374e81aa55441bac","modified":1608521500099},{"_id":"themes/fluid/languages/ja.yml","hash":"2597c19b1551dac598c65294dff38ef9cb9674fc","modified":1608521500099},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"eece4076673b7c580dc045f55df30cc67be9a8a8","modified":1608521500099},{"_id":"themes/fluid/layout/404.ejs","hash":"8207b0b7e14384a8ae3a954bbad1db14664bb918","modified":1608521500099},{"_id":"themes/fluid/layout/about.ejs","hash":"c724d498e3bd49956b45ff65ecc6bd7054239e8c","modified":1608521500099},{"_id":"themes/fluid/layout/archive.ejs","hash":"ed39c0a0facd2e746276e061a27ae38867f7b71c","modified":1608521500099},{"_id":"themes/fluid/layout/categories.ejs","hash":"8a3347ec1ba39d5dd3984ba2b3c90eb8258e5977","modified":1608521500099},{"_id":"themes/fluid/layout/category.ejs","hash":"9cc94d4044e1170ffff2f98d4842b0fc27bf168d","modified":1608521500103},{"_id":"themes/fluid/layout/index.ejs","hash":"1bb03893e4081705685dfefd1f36cecefe24e482","modified":1608521500103},{"_id":"themes/fluid/layout/layout.ejs","hash":"ab337a080e91a8a6c8ce04e358852db21c4ce240","modified":1608521500103},{"_id":"themes/fluid/layout/post.ejs","hash":"fbf6860fa6d89956d02bd28c9ae0d2fed59467a0","modified":1608521500103},{"_id":"themes/fluid/layout/tag.ejs","hash":"f47a126f3848bcdf482f2ed9c7f396e65a30ef7d","modified":1608521500103},{"_id":"themes/fluid/layout/tags.ejs","hash":"716769e91a69014cefffdddb137098bb2ed99297","modified":1608521500103},{"_id":"themes/fluid/pages/about.md","hash":"8fd5cf93407a3e39d156b1c293fbf936787b0369","modified":1608521500103},{"_id":"themes/fluid/pages/local-search.xml","hash":"6606c859dc91b1a216e1a2b9eb0d1ec98db5d98b","modified":1608521500103},{"_id":"themes/fluid/scripts/helpers.js","hash":"7bd7e12252981003448e3b867e25cc303b3465fe","modified":1608521500103},{"_id":"themes/fluid/scripts/lazyload.js","hash":"ab682108e69328fece371955b2eb271f51016596","modified":1608521500103},{"_id":"themes/fluid/scripts/local-search.js","hash":"6db2897057b51617edb19cf8f40ea30106d66f37","modified":1608521500103},{"_id":"themes/fluid/scripts/merge-configs.js","hash":"63727d66f6a0340538d17b52dde9c7f0fe70cf83","modified":1608521500103},{"_id":"themes/fluid/scripts/pages.js","hash":"6b8767191e0675a51a33ee47b554d4ef939b7771","modified":1608521500103},{"_id":"themes/fluid/scripts/wordcount.js","hash":"154e838ba4f5b6e9510da7e618a63fe9b388bd3d","modified":1608521500103},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"cd2d2358380638b3d11b89cf6cb99e5dd1da3875","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/busuanzi.ejs","hash":"33392e25166c98eeb736fef5894c93cbfa9091ce","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"98f1bab1fc424cd52e1cc93f94e4d63569306996","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"549a9296ff07ee3e341d7fc0b2f6550e4e42a483","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"1305a0817e540323dfcd3b4a558103b592a7d78d","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"c798fdce888c6f26790cd201e0962ce8d479a6fc","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"e59408274d8060d535be8ab923284df2f8aa8506","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"3e8a25191e4bc839f46e1cc43477759f31566655","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"baf8c01fcdfcee79dddfd1f308e0b86aa3f70cfc","modified":1608521500099},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"818aa1166f5aeb2fa3712e11481d3c65bc211524","modified":1608521500103},{"_id":"themes/fluid/source/css/main.styl","hash":"33a5dac12a89f0b6f343f4b7f639f8cb2c29e330","modified":1608521500103},{"_id":"themes/fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1608521500107},{"_id":"themes/fluid/source/img/avatar.jpg","hash":"cb8e80e5a5a415c706d76b964ab4466d777eba6a","modified":1608521500107},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1608521500107},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1608521500107},{"_id":"themes/fluid/source/img/favicon.png","hash":"0c801dd507d4fb6a2367cd94f3e9f93f1ad1c3d9","modified":1608521500107},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1608521500107},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1608521500107},{"_id":"themes/fluid/source/js/lazyload.js","hash":"bb11c0a419de1fc4ce1ef633574ce0f9b91e1441","modified":1608521500107},{"_id":"themes/fluid/source/js/local-search.js","hash":"66046f2ad85aa22fd64bbd0e968a498a2c5bfbaa","modified":1608521500107},{"_id":"themes/fluid/source/js/main.js","hash":"21ebed6b8c52fe92a7677ebda729f195bf97c9c6","modified":1608521500107},{"_id":"themes/fluid/source/js/post.js","hash":"3c4894c77b4f28d61ab017dd61548054ed781dbe","modified":1608521500107},{"_id":"themes/fluid/source/css/_functions/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"5898fb0a5610c840ba20a6a84c2952e9331d89b9","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"b8d84205f2cd899ba490fc2335ea2e1353f1d03d","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"19fb3d0390a8e2334030b3f43b53f1019b682433","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"8ab72945ef82f80147e60604dbb8506f3dcdec4f","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2cfd1e0cbf0b71d74de2760fd2303bb90afedc42","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"c4bbcf1507f19be6e077e73d0b38d00003f3161b","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"f1a4ced91653cd1c9ce1943d36488492bb5f152e","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"40032ca6af619716fa3479eeb9a5f47924d95126","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"784a8e656dbf535269bb901fc7b2469dc24e1899","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"421ad423f4a44a9468253e1f117145a500fdec78","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"2778826c66c442e33ac9f9c32bc6e9e1ec0ef8f5","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/prettify.ejs","hash":"d835646f43d27cfa63c1d84c851a16cd1c49f970","modified":1608521500099},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"2ee91a9782ffca316b12ab45a96a9bbafe57e5af","modified":1608521500099},{"_id":"themes/fluid/source/css/_custom/custom.styl","hash":"3626d8439c27c9bfde008de8a7ba5124bbc7c397","modified":1608521500103},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"271abbfef0414cb6d854a0278f8348e3f6fc70b1","modified":1608521500103},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"68caf7cc73fa6211f9802b69293a2a38d7322de7","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"03703ece80dac645607d4731dff3fdd923777d2a","modified":1608521500103},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"56ee4f721b54c623286dd172085aaf34c0128837","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/1.png","hash":"42c94ca5adc481f988ed5f051cf88dc4f6a06a90","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/2.png","hash":"256fcb6ad67dcbaf5e5ed7bd0037b8a6f196875b","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/3.png","hash":"b82888f8792751230053fe8006003ca83e0d305f","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/4.png","hash":"4002cae31828bc633f557f8c57987aa7fa523b60","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/5.png","hash":"404085d8dad7c15d811214335a3158a1fd34e126","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/6.png","hash":"47fff2da26ae40c7e2f6ca471f0c99fd7b8a75a0","modified":1608521500103},{"_id":"themes/fluid/source/img/Docker/7.png","hash":"b1644851f1d72f22829b8d11bfe0aab9546faae1","modified":1608521500103},{"_id":"themes/fluid/source/img/Git/1.jpg","hash":"0896242aa82ff35d92e96e95be723662f564377a","modified":1608521500103},{"_id":"themes/fluid/source/img/Git/3.png","hash":"1b039cee7d797f1e59b66eefd6386ba3884bdb5e","modified":1608521500107},{"_id":"themes/fluid/source/lib/anchor/anchor.min.js","hash":"0996588202bd062dad6f592615cb4791e1f8be91","modified":1608521500107},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.css","hash":"bfa13de0fab7defa3a25c3197e90b600c4897c34","modified":1608521500111},{"_id":"themes/fluid/source/lib/github-markdown/github-markdown.min.css","hash":"23ec6f05c5b69aa8ffb12c59c9bf1325ee5a26d1","modified":1608521500127},{"_id":"themes/fluid/source/lib/katex/katex.min.css","hash":"f29c27f5b804ec30acdebb8ec0488fc4a9e1538a","modified":1608521500127},{"_id":"themes/fluid/source/lib/popper/popper.min.js","hash":"27d61a7e89d12ce0744f34fa804230eeb13ff128","modified":1608521500139},{"_id":"themes/fluid/source/lib/prettify/github-v2.min.css","hash":"da1b8e6d4df1f044d12f461880e677d65dbbf2d3","modified":1608521500139},{"_id":"themes/fluid/source/lib/prettify/prettify.min.js","hash":"03044b62cdb1c300537c14dcf424333fcf4c9110","modified":1608521500139},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night-eighties.min.css","hash":"a5f2102fc148359a92435b170f3bfb25e1221837","modified":1608521500139},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night.min.css","hash":"535256d676d247d3282e9a8ae2777c6f7df4fdc6","modified":1608521500139},{"_id":"themes/fluid/source/lib/prettify/tomorrow.min.css","hash":"ea61879c64ca73a5ea233b1315faf7f2fdfebca9","modified":1608521500139},{"_id":"themes/fluid/source/lib/smooth-scroll/smooth-scroll.min.js","hash":"ee5dea9ea4c5edb110f30a277e5fca7993f948b5","modified":1608521500139},{"_id":"themes/fluid/source/lib/tocbot/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1608521500139},{"_id":"themes/fluid/source/lib/typed/typed.min.js","hash":"38b792348023d55caabd7f888ae477ee143e6abe","modified":1608521500139},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608521500103},{"_id":"themes/fluid/source/img/Git/2.png","hash":"5eb99f1619bc8e2fc4718db2adef9d328b97ad6b","modified":1608521500103},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.js","hash":"211f4852cbb5662e11b9688bef8415ca328a88ef","modified":1608521500111},{"_id":"themes/fluid/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1608521500127},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"c42222b737664023ee95db6c379e6e4a40f1cbcd","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"8a12e25537741e178279a4fcd53a7e94b8a01e36","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"43f49545fe2581338d971ecdf848942cc519e378","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"8c1d33e3f38d13f56bf1d5b028b6ef7cf8a17169","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"eee2e84a23f1bbccbe1c24395dce15814a291e8b","modified":1608521500103},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"ed9268c7a4ba135437ec30adfe4724cf2719e1cc","modified":1608521500103},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"5eb58f4263f87c543388bf66dec7d1f0b7c5b32c","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"38e6bd17442bb34e0e13a2c9bcbc5299f68be173","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"8b356dc021032d9380af47f7608a6b62a9b6f363","modified":1608521500119},{"_id":"themes/fluid/source/img/post_banner.jpg","hash":"b66b0b0dd1c6d11216f662d3693ccc3f2d5bad74","modified":1608521500107},{"_id":"themes/fluid/source/lib/bootstrap/js/bootstrap.min.js","hash":"8260ff4bf54350c075bc10d18e349d158e1a4af1","modified":1608521500111},{"_id":"themes/fluid/source/lib/font-awesome/css/all.min.css","hash":"6f4095f66e56d39ef0adefbe85a1dcfc13bd133b","modified":1608521500111},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"2417fe03c7330a5160f070d6ab747a2bc4bbd41b","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"2e97930b520222ec3c2e4188ce07cc1904beba48","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"5d5d1448b199c38f1b39a49b1e9b3f1381a26cad","modified":1608521500127},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"d378644ff0f7549fa6f217a08dfd2566a770638e","modified":1608521500127},{"_id":"themes/fluid/source/img/banner.jpg","hash":"90f43cce3227034aa428ea6b896fae665f72f823","modified":1608521500107},{"_id":"themes/fluid/source/lib/bootstrap/css/bootstrap.min.css","hash":"3665a5389b7a20dd3b2fe9cb0ed3d80bec1cf2a3","modified":1608521500111},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"453e71a65f2958480b74fdb75a53d41068699dbf","modified":1608521500111},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"3fbe9822118e91350912f51f3080ce4aa9b3ec38","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"9465c5894ca2f93655fa5767b820b762aff6b518","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"f9583bce6740a4125e14d0628ffbd946b7ddfdda","modified":1608521500119},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1608521500139},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1608521500139},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"2b0ebea58a0bc895400dffe8c5e434c8b12338e3","modified":1608521500119},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"7b280debee5800806092e35a6bc2c6fd9c51cf63","modified":1608521500127},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1608521500135},{"_id":"themes/fluid/source/lib/mdbootstrap/js/mdb.min.js","hash":"fef8d611bbc14ad31ca9ec9e2990bfde4d873bb1","modified":1608521500139},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1608521500131},{"_id":"themes/fluid/source/lib/mdbootstrap/css/mdb.min.css","hash":"62818e7755b098a1c3b503425356570a2c7474d9","modified":1608521500131},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fcac55c6f9e9993cea6e2ecc729fffc36c7009b2","modified":1608521500115},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3d24b0004b9dac32a46622cefa72cb3173b13115","modified":1608521500127},{"_id":"public/local-search.xml","hash":"03101406fa9a55413475122fbec95bd4ba18c63d","modified":1608528204842},{"_id":"public/about/About me.html","hash":"89debebe9c4d5474887c57ed761161fc31f09f67","modified":1608528204842},{"_id":"public/about/index.html","hash":"d4c6aaecdadab1df409125f3d9b9799119feb172","modified":1608528204842},{"_id":"public/categories/index.html","hash":"e32afed0dfaf96056402b6134fcd6d8502acad1c","modified":1608528204842},{"_id":"public/tags/index.html","hash":"3a318797355374d4fd0a217cacbde18aa6aa6037","modified":1608528204842},{"_id":"public/2019/12/08/Orthanc + OHIF 搭建DICOM web viewer/index.html","hash":"e44517999e2047c0dd6ff4955800d8276086ec87","modified":1608528204842},{"_id":"public/2019/10/15/DICOM Tag中文编码问题/index.html","hash":"54f0e990e2ddd8610024844b95115f2a25eb6820","modified":1608528204842},{"_id":"public/2019/06/08/使用SimpleITK读取DICOM/index.html","hash":"acb90967df6adea2bdf55b2267467e58bee3db9b","modified":1608528204842},{"_id":"public/2017/09/05/Django实现单设备登录限制/index.html","hash":"9e8edec6fb9316faae64c2625b04acad344bbb5a","modified":1608528204842},{"_id":"public/archives/index.html","hash":"afc39f1d92e27ba9ceb72c126bf4bcdf80c6ac17","modified":1608528204842},{"_id":"public/archives/2017/index.html","hash":"a717cbe804e05049355c8c74f906921a1b3a516b","modified":1608528204842},{"_id":"public/archives/2017/09/index.html","hash":"a717cbe804e05049355c8c74f906921a1b3a516b","modified":1608528204842},{"_id":"public/archives/2018/index.html","hash":"37d5d1330a90554d7f0104013706e26bde79a513","modified":1608528204842},{"_id":"public/archives/2018/01/index.html","hash":"37d5d1330a90554d7f0104013706e26bde79a513","modified":1608528204842},{"_id":"public/archives/2019/index.html","hash":"79a57f24f32b09a8c68a3998ccc8b028527b04fd","modified":1608528204842},{"_id":"public/archives/2019/06/index.html","hash":"0ceaf416d74f643dbae12dba3d23bcc9858726de","modified":1608528204842},{"_id":"public/archives/2019/10/index.html","hash":"32df592e03db010c8616303dad38de6a8f314cb9","modified":1608528204842},{"_id":"public/archives/2019/12/index.html","hash":"6748642de28b38021c99cb729ea47cda6e195308","modified":1608528204842},{"_id":"public/archives/2020/index.html","hash":"b83e5ec8d03f524da09c3d452f325a4e3b47ce2a","modified":1608528204842},{"_id":"public/archives/2020/01/index.html","hash":"c67935dce624d8144d643a9a9044ff8680db4153","modified":1608528204842},{"_id":"public/archives/2020/02/index.html","hash":"45fee97bf473778cb79596f2e79e3b4389345b9e","modified":1608528204842},{"_id":"public/categories/DICOM/index.html","hash":"e943ffccd33f725d99285b2ee37aad77e6f249a4","modified":1608528204842},{"_id":"public/categories/Django/index.html","hash":"a75d906008692601aac552e0faae1be6c8a46362","modified":1608528204842},{"_id":"public/categories/Docker/index.html","hash":"e489c8e22910005b6c719300592cdb21f22145f4","modified":1608528204842},{"_id":"public/categories/Git/index.html","hash":"0a66227bfa3fe59ce840906c4f57709d294bf3ea","modified":1608528204842},{"_id":"public/tags/DICOM/index.html","hash":"0e46c01cc716072c0ec981e86a99bf9d67b0faf2","modified":1608528204842},{"_id":"public/tags/Python/index.html","hash":"47ef3ce7e032ce777c9f53be4f7c32db3db0812e","modified":1608528204842},{"_id":"public/tags/pydicom/index.html","hash":"c15f9d30142cda53515a5e2fd597b30467fe21e9","modified":1608528204842},{"_id":"public/tags/Django/index.html","hash":"e6e4b0d49faa711c0674d3166302d461728ffdfe","modified":1608528204842},{"_id":"public/tags/Docker/index.html","hash":"8b5aa0ee38d522e489ede69b4484daf78ae85744","modified":1608528204842},{"_id":"public/tags/Nginx/index.html","hash":"fb5e276a60a713048cf34c0a81022f89803f262e","modified":1608528204842},{"_id":"public/tags/Git/index.html","hash":"816309cf26d9dbd13cea00b98fe7b0204d00ceae","modified":1608528204842},{"_id":"public/tags/Orthanc/index.html","hash":"73d3074ad3437f31e2904e27c955a3db55b136ce","modified":1608528204842},{"_id":"public/tags/OHIF/index.html","hash":"2c44bde6dd9a63d6c4dd0f4a0c592f50b53f86a0","modified":1608528204842},{"_id":"public/tags/SimpleITK/index.html","hash":"ccb7f788b9c76613d84134f2789c899d8cfbb6ac","modified":1608528204842},{"_id":"public/404.html","hash":"cfc2741849e1861171f452f8b8f40d71ab44f463","modified":1608528204842},{"_id":"public/2020/02/20/Git简介及常用操作/index.html","hash":"1057f43fc31f42b3079b10f36a941553984b7ba1","modified":1608528204842},{"_id":"public/2020/01/08/Docker使用总结/index.html","hash":"b8a96a46059e137a250d4c3158ec74907ee01edf","modified":1608528204842},{"_id":"public/2019/12/10/Docker部署Nginx + uWSGI + Django实践/index.html","hash":"7c8ccffb36f185222f909d0f11e3ba1105478e19","modified":1608528204842},{"_id":"public/2019/06/25/使用python将PDF转换为DICOM格式/index.html","hash":"ed1a5ce421cb886cf947639ea24ca85d39e16209","modified":1608528204842},{"_id":"public/2018/01/08/Django实现语言切换/index.html","hash":"d0258d2d5fe92e407f780f0f7f49f26ed409e2a3","modified":1608528204842},{"_id":"public/index.html","hash":"4de9109f50771427f3e6030ce56e17ca98410e45","modified":1608528204842},{"_id":"public/favicon.ico","hash":"c94cfc71f06d716f7caf321c23854cd536ad6abf","modified":1608528204842},{"_id":"public/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1608528204842},{"_id":"public/img/avatar.jpg","hash":"cb8e80e5a5a415c706d76b964ab4466d777eba6a","modified":1608528204842},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1608528204842},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1608528204842},{"_id":"public/img/favicon.png","hash":"0c801dd507d4fb6a2367cd94f3e9f93f1ad1c3d9","modified":1608528204842},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1608528204842},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1608528204842},{"_id":"public/img/Docker/1.png","hash":"42c94ca5adc481f988ed5f051cf88dc4f6a06a90","modified":1608528204842},{"_id":"public/img/Docker/2.png","hash":"256fcb6ad67dcbaf5e5ed7bd0037b8a6f196875b","modified":1608528204842},{"_id":"public/img/Docker/3.png","hash":"b82888f8792751230053fe8006003ca83e0d305f","modified":1608528204842},{"_id":"public/img/Docker/4.png","hash":"4002cae31828bc633f557f8c57987aa7fa523b60","modified":1608528204842},{"_id":"public/img/Docker/5.png","hash":"404085d8dad7c15d811214335a3158a1fd34e126","modified":1608528204842},{"_id":"public/img/Docker/6.png","hash":"47fff2da26ae40c7e2f6ca471f0c99fd7b8a75a0","modified":1608528204842},{"_id":"public/img/Docker/7.png","hash":"b1644851f1d72f22829b8d11bfe0aab9546faae1","modified":1608528204842},{"_id":"public/img/Git/1.jpg","hash":"0896242aa82ff35d92e96e95be723662f564377a","modified":1608528204842},{"_id":"public/img/Git/3.png","hash":"1b039cee7d797f1e59b66eefd6386ba3884bdb5e","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"5eb58f4263f87c543388bf66dec7d1f0b7c5b32c","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"38e6bd17442bb34e0e13a2c9bcbc5299f68be173","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"8b356dc021032d9380af47f7608a6b62a9b6f363","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"2e97930b520222ec3c2e4188ce07cc1904beba48","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1608528204842},{"_id":"public/img/Git/2.png","hash":"5eb99f1619bc8e2fc4718db2adef9d328b97ad6b","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"2417fe03c7330a5160f070d6ab747a2bc4bbd41b","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"5d5d1448b199c38f1b39a49b1e9b3f1381a26cad","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"d378644ff0f7549fa6f217a08dfd2566a770638e","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"453e71a65f2958480b74fdb75a53d41068699dbf","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"3fbe9822118e91350912f51f3080ce4aa9b3ec38","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"9465c5894ca2f93655fa5767b820b762aff6b518","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1608528204842},{"_id":"public/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1608528204842},{"_id":"public/css/main.css","hash":"5c86ffc0698ecf159760f331dac298d94c5bb45e","modified":1608528204842},{"_id":"public/js/lazyload.js","hash":"bb11c0a419de1fc4ce1ef633574ce0f9b91e1441","modified":1608528204842},{"_id":"public/js/local-search.js","hash":"66046f2ad85aa22fd64bbd0e968a498a2c5bfbaa","modified":1608528204842},{"_id":"public/js/main.js","hash":"21ebed6b8c52fe92a7677ebda729f195bf97c9c6","modified":1608528204842},{"_id":"public/js/post.js","hash":"3c4894c77b4f28d61ab017dd61548054ed781dbe","modified":1608528204842},{"_id":"public/lib/anchor/anchor.min.js","hash":"0996588202bd062dad6f592615cb4791e1f8be91","modified":1608528204842},{"_id":"public/lib/fancybox/jquery.fancybox.min.css","hash":"bfa13de0fab7defa3a25c3197e90b600c4897c34","modified":1608528204842},{"_id":"public/lib/github-markdown/github-markdown.min.css","hash":"23ec6f05c5b69aa8ffb12c59c9bf1325ee5a26d1","modified":1608528204842},{"_id":"public/lib/prettify/github-v2.min.css","hash":"da1b8e6d4df1f044d12f461880e677d65dbbf2d3","modified":1608528204842},{"_id":"public/lib/prettify/prettify.min.js","hash":"03044b62cdb1c300537c14dcf424333fcf4c9110","modified":1608528204842},{"_id":"public/lib/prettify/tomorrow-night-eighties.min.css","hash":"a5f2102fc148359a92435b170f3bfb25e1221837","modified":1608528204842},{"_id":"public/lib/prettify/tomorrow-night.min.css","hash":"535256d676d247d3282e9a8ae2777c6f7df4fdc6","modified":1608528204842},{"_id":"public/lib/prettify/tomorrow.min.css","hash":"ea61879c64ca73a5ea233b1315faf7f2fdfebca9","modified":1608528204842},{"_id":"public/lib/smooth-scroll/smooth-scroll.min.js","hash":"ee5dea9ea4c5edb110f30a277e5fca7993f948b5","modified":1608528204842},{"_id":"public/lib/tocbot/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1608528204842},{"_id":"public/lib/typed/typed.min.js","hash":"38b792348023d55caabd7f888ae477ee143e6abe","modified":1608528204842},{"_id":"public/lib/katex/katex.min.css","hash":"f29c27f5b804ec30acdebb8ec0488fc4a9e1538a","modified":1608528204842},{"_id":"public/lib/popper/popper.min.js","hash":"27d61a7e89d12ce0744f34fa804230eeb13ff128","modified":1608528204842},{"_id":"public/lib/fancybox/jquery.fancybox.min.js","hash":"211f4852cbb5662e11b9688bef8415ca328a88ef","modified":1608528204842},{"_id":"public/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1608528204842},{"_id":"public/lib/bootstrap/js/bootstrap.min.js","hash":"8260ff4bf54350c075bc10d18e349d158e1a4af1","modified":1608528204842},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"6f4095f66e56d39ef0adefbe85a1dcfc13bd133b","modified":1608528204842},{"_id":"public/lib/bootstrap/css/bootstrap.min.css","hash":"3665a5389b7a20dd3b2fe9cb0ed3d80bec1cf2a3","modified":1608528204842},{"_id":"public/lib/mdbootstrap/js/mdb.min.js","hash":"fef8d611bbc14ad31ca9ec9e2990bfde4d873bb1","modified":1608528204842},{"_id":"public/lib/mdbootstrap/css/mdb.min.css","hash":"62818e7755b098a1c3b503425356570a2c7474d9","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"f9583bce6740a4125e14d0628ffbd946b7ddfdda","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"2b0ebea58a0bc895400dffe8c5e434c8b12338e3","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"7b280debee5800806092e35a6bc2c6fd9c51cf63","modified":1608528204842},{"_id":"public/img/post_banner.jpg","hash":"b66b0b0dd1c6d11216f662d3693ccc3f2d5bad74","modified":1608528204842},{"_id":"public/img/banner.jpg","hash":"90f43cce3227034aa428ea6b896fae665f72f823","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fcac55c6f9e9993cea6e2ecc729fffc36c7009b2","modified":1608528204842},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3d24b0004b9dac32a46622cefa72cb3173b13115","modified":1608528204842}],"Category":[{"name":"DICOM","_id":"ckiy45ujq0004boui150qfai8"},{"name":"Django","_id":"ckiy45ujz000bbouibldfemvd"},{"name":"Docker","_id":"ckiy45uk9000kbouiepd8diss"},{"name":"Git","_id":"ckiy45ukf000xboui4szm60q3"}],"Data":[],"Page":[{"_content":"# About me\n\n** **\n**    我是谁**：    孙瑞\n\n**          我来自哪里**： 湖北黄冈\n\n**                    我的学校**：    湖北工业大学\n\n**                    我的爱好**：    游戏、篮球、书法、骑行\n\n**                                      微信**：       sr464521059\n\n\n\n","source":"about/About me.md","raw":"# About me\n\n** **\n**    我是谁**：    孙瑞\n\n**          我来自哪里**： 湖北黄冈\n\n**                    我的学校**：    湖北工业大学\n\n**                    我的爱好**：    游戏、篮球、书法、骑行\n\n**                                      微信**：       sr464521059\n\n\n\n","date":"2020-12-21T03:31:40.095Z","updated":"2020-12-21T03:31:40.095Z","path":"about/About me.html","title":"","comments":1,"layout":"page","_id":"ckiy45ujm0001bouih37ngh21","content":"<h1 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h1><hr>\n<p>**    我是谁**：    孙瑞</p>\n<p>**          我来自哪里**： 湖北黄冈</p>\n<p>**                    我的学校**：    湖北工业大学</p>\n<p>**                    我的爱好**：    游戏、篮球、书法、骑行</p>\n<p>**                                      微信**：       sr464521059</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h1><hr>\n<p>**    我是谁**：    孙瑞</p>\n<p>**          我来自哪里**： 湖北黄冈</p>\n<p>**                    我的学校**：    湖北工业大学</p>\n<p>**                    我的爱好**：    游戏、篮球、书法、骑行</p>\n<p>**                                      微信**：       sr464521059</p>\n"},{"title":"About me","date":"2020-01-05T09:41:32.000Z","type":"about","_content":"\n\n**我是谁**：　　　　孙瑞\n\n**我来自哪里**：　　湖北黄冈\n\n**我的工作**：　　　Python Coder\n\n**我的学校**：　　　湖北工业大学\n\n**我的爱好**：　　　游戏、篮球、书法、骑行\n\n**微信**：　　　　　sr464521059\n\n\n","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2020-01-05 17:41:32\ntype: \"about\"\n---\n\n\n**我是谁**：　　　　孙瑞\n\n**我来自哪里**：　　湖北黄冈\n\n**我的工作**：　　　Python Coder\n\n**我的学校**：　　　湖北工业大学\n\n**我的爱好**：　　　游戏、篮球、书法、骑行\n\n**微信**：　　　　　sr464521059\n\n\n","updated":"2020-12-21T03:31:40.095Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckiy45ujp0003bouicltgclnk","content":"<p><strong>我是谁</strong>：　　　　孙瑞</p>\n<p><strong>我来自哪里</strong>：　　湖北黄冈</p>\n<p><strong>我的工作</strong>：　　　Python Coder</p>\n<p><strong>我的学校</strong>：　　　湖北工业大学</p>\n<p><strong>我的爱好</strong>：　　　游戏、篮球、书法、骑行</p>\n<p><strong>微信</strong>：　　　　　sr464521059</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>我是谁</strong>：　　　　孙瑞</p>\n<p><strong>我来自哪里</strong>：　　湖北黄冈</p>\n<p><strong>我的工作</strong>：　　　Python Coder</p>\n<p><strong>我的学校</strong>：　　　湖北工业大学</p>\n<p><strong>我的爱好</strong>：　　　游戏、篮球、书法、骑行</p>\n<p><strong>微信</strong>：　　　　　sr464521059</p>\n"},{"title":"categories","date":"2020-01-05T08:43:33.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-01-05 16:43:33\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-12-21T03:31:40.095Z","path":"categories/index.html","layout":"page","_id":"ckiy45ujt0007bouie8sfdvco","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-01-05T08:41:12.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-05 16:41:12\ntype: \"tags\"\ncomments: false\n---\n","updated":"2020-12-21T03:31:40.095Z","path":"tags/index.html","layout":"page","_id":"ckiy45ujx0009bouigk4aar4x","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DICOM Tag中文编码问题","date":"2019-10-15T09:38:49.000Z","_content":"\nDICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式`SpecificCharacterSet`并不支持中文.\n\n<!--more-->\n\n## 编码问题\n\n常见的DICOM tag编码格式一般是`ISO_IR 100`，存储于`SpecificCharacterSet`（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为`ISO_IR 192`即UTF-8编码。常见的DICOM tag编码对应关系可参考：\n\n```python\n\t'ISO_IR 100': 'latin_1',\n    'ISO_IR 101': 'iso8859_2',\n    'ISO_IR 109': 'iso8859_3',\n    'ISO_IR 110': 'iso8859_4',\n    'ISO_IR 126': 'iso_ir_126',  # Greek\n    'ISO_IR 127': 'iso_ir_127',  # Arabic\n    'ISO_IR 138': 'iso_ir_138',  # Hebrew\n    'ISO_IR 144': 'iso_ir_144',  # Russian\n    'ISO_IR 148': 'iso_ir_148',  # Turkish\n    'ISO_IR 166': 'iso_ir_166',  # Thai\n    'ISO 2022 IR 6': 'iso8859',  # alias for latin_1 too\n    'ISO 2022 IR 13': 'shift_jis',\n    'ISO 2022 IR 87': 'iso2022_jp',\n    'ISO 2022 IR 100': 'latin_1',\n    'ISO 2022 IR 101': 'iso8859_2',\n    'ISO 2022 IR 109': 'iso8859_3',\n    'ISO 2022 IR 110': 'iso8859_4',\n    'ISO 2022 IR 126': 'iso_ir_126',\n    'ISO 2022 IR 127': 'iso_ir_127',\n    'ISO 2022 IR 138': 'iso_ir_138',\n    'ISO 2022 IR 144': 'iso_ir_144',\n    'ISO 2022 IR 148': 'iso_ir_148',\n    'ISO 2022 IR 149': 'euc_kr',\n    'ISO 2022 IR 159': 'iso2022_jp_2',\n    'ISO 2022 IR 166': 'iso_ir_166',\n    'ISO 2022 IR 58': 'iso_ir_58',\n    'ISO_IR 192': 'UTF8',  # from Chinese example, 2008 PS3.5 Annex J p1-4\n    'GB18030': 'GB18030',\n    'ISO 2022 GBK': 'GBK',  # from DICOM correction CP1234\n    'ISO 2022 58': 'GB2312',  # from DICOM correction CP1234\n    'GBK': 'GBK',  # from DICOM correction CP1234\n```\n\n## 使用SimpleITK读取DICOM tag\nDICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变`SpecificCharacterSet`的值为`ISO_IR 192`(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中`PatientName`并改变编码的示例：\n```python\nimport SimpleITK as sitk\n\ndcm_path = '/path_to_dcm'\ndcm = sitk.ReadImage(dcm_path)\npatient_name = dcm.GetMetaData('0010|0010').strip().encode(\"utf-8\", \"surrogateescape\").decode('gbk', 'replace')\n\nds = pydicom.dcmread(dcm_path)\nds.SpecificCharacterSet = 'ISO_IR 192'\nds.PatientName = patient_name\nds.save_as(dcm_path)\n\n```\n\n","source":"_posts/DICOM Tag中文编码问题.md","raw":"---\ntitle: DICOM Tag中文编码问题\ndate: 2019-10-15 17:38:49\ntags: [DICOM,Python,pydicom]\ncategories: DICOM\n---\n\nDICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式`SpecificCharacterSet`并不支持中文.\n\n<!--more-->\n\n## 编码问题\n\n常见的DICOM tag编码格式一般是`ISO_IR 100`，存储于`SpecificCharacterSet`（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为`ISO_IR 192`即UTF-8编码。常见的DICOM tag编码对应关系可参考：\n\n```python\n\t'ISO_IR 100': 'latin_1',\n    'ISO_IR 101': 'iso8859_2',\n    'ISO_IR 109': 'iso8859_3',\n    'ISO_IR 110': 'iso8859_4',\n    'ISO_IR 126': 'iso_ir_126',  # Greek\n    'ISO_IR 127': 'iso_ir_127',  # Arabic\n    'ISO_IR 138': 'iso_ir_138',  # Hebrew\n    'ISO_IR 144': 'iso_ir_144',  # Russian\n    'ISO_IR 148': 'iso_ir_148',  # Turkish\n    'ISO_IR 166': 'iso_ir_166',  # Thai\n    'ISO 2022 IR 6': 'iso8859',  # alias for latin_1 too\n    'ISO 2022 IR 13': 'shift_jis',\n    'ISO 2022 IR 87': 'iso2022_jp',\n    'ISO 2022 IR 100': 'latin_1',\n    'ISO 2022 IR 101': 'iso8859_2',\n    'ISO 2022 IR 109': 'iso8859_3',\n    'ISO 2022 IR 110': 'iso8859_4',\n    'ISO 2022 IR 126': 'iso_ir_126',\n    'ISO 2022 IR 127': 'iso_ir_127',\n    'ISO 2022 IR 138': 'iso_ir_138',\n    'ISO 2022 IR 144': 'iso_ir_144',\n    'ISO 2022 IR 148': 'iso_ir_148',\n    'ISO 2022 IR 149': 'euc_kr',\n    'ISO 2022 IR 159': 'iso2022_jp_2',\n    'ISO 2022 IR 166': 'iso_ir_166',\n    'ISO 2022 IR 58': 'iso_ir_58',\n    'ISO_IR 192': 'UTF8',  # from Chinese example, 2008 PS3.5 Annex J p1-4\n    'GB18030': 'GB18030',\n    'ISO 2022 GBK': 'GBK',  # from DICOM correction CP1234\n    'ISO 2022 58': 'GB2312',  # from DICOM correction CP1234\n    'GBK': 'GBK',  # from DICOM correction CP1234\n```\n\n## 使用SimpleITK读取DICOM tag\nDICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变`SpecificCharacterSet`的值为`ISO_IR 192`(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中`PatientName`并改变编码的示例：\n```python\nimport SimpleITK as sitk\n\ndcm_path = '/path_to_dcm'\ndcm = sitk.ReadImage(dcm_path)\npatient_name = dcm.GetMetaData('0010|0010').strip().encode(\"utf-8\", \"surrogateescape\").decode('gbk', 'replace')\n\nds = pydicom.dcmread(dcm_path)\nds.SpecificCharacterSet = 'ISO_IR 192'\nds.PatientName = patient_name\nds.save_as(dcm_path)\n\n```\n\n","slug":"DICOM Tag中文编码问题","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45ujh0000bouigofa6x1t","content":"<p>DICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式<code>SpecificCharacterSet</code>并不支持中文.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"编码问题\"><a href=\"#编码问题\" class=\"headerlink\" title=\"编码问题\"></a>编码问题</h2><p>常见的DICOM tag编码格式一般是<code>ISO_IR 100</code>，存储于<code>SpecificCharacterSet</code>（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为<code>ISO_IR 192</code>即UTF-8编码。常见的DICOM tag编码对应关系可参考：</p>\n<pre><code class=\"python\">    &#39;ISO_IR 100&#39;: &#39;latin_1&#39;,\n    &#39;ISO_IR 101&#39;: &#39;iso8859_2&#39;,\n    &#39;ISO_IR 109&#39;: &#39;iso8859_3&#39;,\n    &#39;ISO_IR 110&#39;: &#39;iso8859_4&#39;,\n    &#39;ISO_IR 126&#39;: &#39;iso_ir_126&#39;,  # Greek\n    &#39;ISO_IR 127&#39;: &#39;iso_ir_127&#39;,  # Arabic\n    &#39;ISO_IR 138&#39;: &#39;iso_ir_138&#39;,  # Hebrew\n    &#39;ISO_IR 144&#39;: &#39;iso_ir_144&#39;,  # Russian\n    &#39;ISO_IR 148&#39;: &#39;iso_ir_148&#39;,  # Turkish\n    &#39;ISO_IR 166&#39;: &#39;iso_ir_166&#39;,  # Thai\n    &#39;ISO 2022 IR 6&#39;: &#39;iso8859&#39;,  # alias for latin_1 too\n    &#39;ISO 2022 IR 13&#39;: &#39;shift_jis&#39;,\n    &#39;ISO 2022 IR 87&#39;: &#39;iso2022_jp&#39;,\n    &#39;ISO 2022 IR 100&#39;: &#39;latin_1&#39;,\n    &#39;ISO 2022 IR 101&#39;: &#39;iso8859_2&#39;,\n    &#39;ISO 2022 IR 109&#39;: &#39;iso8859_3&#39;,\n    &#39;ISO 2022 IR 110&#39;: &#39;iso8859_4&#39;,\n    &#39;ISO 2022 IR 126&#39;: &#39;iso_ir_126&#39;,\n    &#39;ISO 2022 IR 127&#39;: &#39;iso_ir_127&#39;,\n    &#39;ISO 2022 IR 138&#39;: &#39;iso_ir_138&#39;,\n    &#39;ISO 2022 IR 144&#39;: &#39;iso_ir_144&#39;,\n    &#39;ISO 2022 IR 148&#39;: &#39;iso_ir_148&#39;,\n    &#39;ISO 2022 IR 149&#39;: &#39;euc_kr&#39;,\n    &#39;ISO 2022 IR 159&#39;: &#39;iso2022_jp_2&#39;,\n    &#39;ISO 2022 IR 166&#39;: &#39;iso_ir_166&#39;,\n    &#39;ISO 2022 IR 58&#39;: &#39;iso_ir_58&#39;,\n    &#39;ISO_IR 192&#39;: &#39;UTF8&#39;,  # from Chinese example, 2008 PS3.5 Annex J p1-4\n    &#39;GB18030&#39;: &#39;GB18030&#39;,\n    &#39;ISO 2022 GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234\n    &#39;ISO 2022 58&#39;: &#39;GB2312&#39;,  # from DICOM correction CP1234\n    &#39;GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234</code></pre>\n<h2 id=\"使用SimpleITK读取DICOM-tag\"><a href=\"#使用SimpleITK读取DICOM-tag\" class=\"headerlink\" title=\"使用SimpleITK读取DICOM tag\"></a>使用SimpleITK读取DICOM tag</h2><p>DICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变<code>SpecificCharacterSet</code>的值为<code>ISO_IR 192</code>(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中<code>PatientName</code>并改变编码的示例：</p>\n<pre><code class=\"python\">import SimpleITK as sitk\n\ndcm_path = &#39;/path_to_dcm&#39;\ndcm = sitk.ReadImage(dcm_path)\npatient_name = dcm.GetMetaData(&#39;0010|0010&#39;).strip().encode(&quot;utf-8&quot;, &quot;surrogateescape&quot;).decode(&#39;gbk&#39;, &#39;replace&#39;)\n\nds = pydicom.dcmread(dcm_path)\nds.SpecificCharacterSet = &#39;ISO_IR 192&#39;\nds.PatientName = patient_name\nds.save_as(dcm_path)\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>DICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式<code>SpecificCharacterSet</code>并不支持中文.</p>","more":"<h2 id=\"编码问题\"><a href=\"#编码问题\" class=\"headerlink\" title=\"编码问题\"></a>编码问题</h2><p>常见的DICOM tag编码格式一般是<code>ISO_IR 100</code>，存储于<code>SpecificCharacterSet</code>（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为<code>ISO_IR 192</code>即UTF-8编码。常见的DICOM tag编码对应关系可参考：</p>\n<pre><code class=\"python\">    &#39;ISO_IR 100&#39;: &#39;latin_1&#39;,\n    &#39;ISO_IR 101&#39;: &#39;iso8859_2&#39;,\n    &#39;ISO_IR 109&#39;: &#39;iso8859_3&#39;,\n    &#39;ISO_IR 110&#39;: &#39;iso8859_4&#39;,\n    &#39;ISO_IR 126&#39;: &#39;iso_ir_126&#39;,  # Greek\n    &#39;ISO_IR 127&#39;: &#39;iso_ir_127&#39;,  # Arabic\n    &#39;ISO_IR 138&#39;: &#39;iso_ir_138&#39;,  # Hebrew\n    &#39;ISO_IR 144&#39;: &#39;iso_ir_144&#39;,  # Russian\n    &#39;ISO_IR 148&#39;: &#39;iso_ir_148&#39;,  # Turkish\n    &#39;ISO_IR 166&#39;: &#39;iso_ir_166&#39;,  # Thai\n    &#39;ISO 2022 IR 6&#39;: &#39;iso8859&#39;,  # alias for latin_1 too\n    &#39;ISO 2022 IR 13&#39;: &#39;shift_jis&#39;,\n    &#39;ISO 2022 IR 87&#39;: &#39;iso2022_jp&#39;,\n    &#39;ISO 2022 IR 100&#39;: &#39;latin_1&#39;,\n    &#39;ISO 2022 IR 101&#39;: &#39;iso8859_2&#39;,\n    &#39;ISO 2022 IR 109&#39;: &#39;iso8859_3&#39;,\n    &#39;ISO 2022 IR 110&#39;: &#39;iso8859_4&#39;,\n    &#39;ISO 2022 IR 126&#39;: &#39;iso_ir_126&#39;,\n    &#39;ISO 2022 IR 127&#39;: &#39;iso_ir_127&#39;,\n    &#39;ISO 2022 IR 138&#39;: &#39;iso_ir_138&#39;,\n    &#39;ISO 2022 IR 144&#39;: &#39;iso_ir_144&#39;,\n    &#39;ISO 2022 IR 148&#39;: &#39;iso_ir_148&#39;,\n    &#39;ISO 2022 IR 149&#39;: &#39;euc_kr&#39;,\n    &#39;ISO 2022 IR 159&#39;: &#39;iso2022_jp_2&#39;,\n    &#39;ISO 2022 IR 166&#39;: &#39;iso_ir_166&#39;,\n    &#39;ISO 2022 IR 58&#39;: &#39;iso_ir_58&#39;,\n    &#39;ISO_IR 192&#39;: &#39;UTF8&#39;,  # from Chinese example, 2008 PS3.5 Annex J p1-4\n    &#39;GB18030&#39;: &#39;GB18030&#39;,\n    &#39;ISO 2022 GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234\n    &#39;ISO 2022 58&#39;: &#39;GB2312&#39;,  # from DICOM correction CP1234\n    &#39;GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234</code></pre>\n<h2 id=\"使用SimpleITK读取DICOM-tag\"><a href=\"#使用SimpleITK读取DICOM-tag\" class=\"headerlink\" title=\"使用SimpleITK读取DICOM tag\"></a>使用SimpleITK读取DICOM tag</h2><p>DICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变<code>SpecificCharacterSet</code>的值为<code>ISO_IR 192</code>(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中<code>PatientName</code>并改变编码的示例：</p>\n<pre><code class=\"python\">import SimpleITK as sitk\n\ndcm_path = &#39;/path_to_dcm&#39;\ndcm = sitk.ReadImage(dcm_path)\npatient_name = dcm.GetMetaData(&#39;0010|0010&#39;).strip().encode(&quot;utf-8&quot;, &quot;surrogateescape&quot;).decode(&#39;gbk&#39;, &#39;replace&#39;)\n\nds = pydicom.dcmread(dcm_path)\nds.SpecificCharacterSet = &#39;ISO_IR 192&#39;\nds.PatientName = patient_name\nds.save_as(dcm_path)\n</code></pre>"},{"title":"Django实现单设备登录限制","date":"2017-09-05T12:58:59.000Z","_content":"\n本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。\n\n<!--more-->\n\n## 基本思路\n要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。\n## 使用Mysql数据表\n为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。\n实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。\n\n## 使用Redis缓存session\nDjango项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：\n\n```python\n# 获取当前session的session_key\nsession_key = request.session.session_key\n\n# 获取Redis中所有key\nkey_list = cache.keys(\"*\")\n\n# 遍历获取到的所有key，通过正则筛选django的session记录\nfor key in key_list:\n    s_key = re.match(r'django\\.contrib\\.sessions\\.cache(.*)', key)\n    # 如果session_key和当前session不同，则进行判断\n    if s_key and s_key.group(1) != session_key:\n        cache_session_dict = cache.get(key)\n        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录\n        if cache_session_dict.get('user_id') == user.id:\n            cache.delete(key)\n            logger.info('Account [{}] has logged in elsewhere, delete old session [{}]'.format(username, key))\n            else:\n                continue\n```\n\n## 视图装饰器\n为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。\n\n```python\ndef auth_required(perm):\n    def decorator(view_func):\n        def _wrapped_view(request, *args, **kwargs):\n\n            try:\n                session_key = request.session.session_key\n\n                # session_flag = Session.objects.filter(session_key=session_key)\n                if not session_key:\n                    return JsonResponse({\"respCode\": 4001})\n                else:\n                    role = request.session.get(\"role_id\")\n                    if not role:\n                        return JsonResponse({\"respCode\": 4002})\n                    else:\n                        if int(role) > int(perm):\n                            return JsonResponse({\"respCode\": 4003})\n\n            except Exception as e:\n                logger.error(e)\n                return JsonResponse({\"respCode\": 4004})\n\n            return view_func(request, *args, **kwargs)\n        return _wrapped_view\n    return decorator\n```\n\n","source":"_posts/Django实现单设备登录限制.md","raw":"---\ntitle: Django实现单设备登录限制\ndate: 2017-09-05 20:58:59\ntags: [Django,Python]\ncategories: Django\n---\n\n本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。\n\n<!--more-->\n\n## 基本思路\n要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。\n## 使用Mysql数据表\n为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。\n实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。\n\n## 使用Redis缓存session\nDjango项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：\n\n```python\n# 获取当前session的session_key\nsession_key = request.session.session_key\n\n# 获取Redis中所有key\nkey_list = cache.keys(\"*\")\n\n# 遍历获取到的所有key，通过正则筛选django的session记录\nfor key in key_list:\n    s_key = re.match(r'django\\.contrib\\.sessions\\.cache(.*)', key)\n    # 如果session_key和当前session不同，则进行判断\n    if s_key and s_key.group(1) != session_key:\n        cache_session_dict = cache.get(key)\n        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录\n        if cache_session_dict.get('user_id') == user.id:\n            cache.delete(key)\n            logger.info('Account [{}] has logged in elsewhere, delete old session [{}]'.format(username, key))\n            else:\n                continue\n```\n\n## 视图装饰器\n为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。\n\n```python\ndef auth_required(perm):\n    def decorator(view_func):\n        def _wrapped_view(request, *args, **kwargs):\n\n            try:\n                session_key = request.session.session_key\n\n                # session_flag = Session.objects.filter(session_key=session_key)\n                if not session_key:\n                    return JsonResponse({\"respCode\": 4001})\n                else:\n                    role = request.session.get(\"role_id\")\n                    if not role:\n                        return JsonResponse({\"respCode\": 4002})\n                    else:\n                        if int(role) > int(perm):\n                            return JsonResponse({\"respCode\": 4003})\n\n            except Exception as e:\n                logger.error(e)\n                return JsonResponse({\"respCode\": 4004})\n\n            return view_func(request, *args, **kwargs)\n        return _wrapped_view\n    return decorator\n```\n\n","slug":"Django实现单设备登录限制","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45ujn0002bouiazg92xrz","content":"<p>本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。</p>\n<h2 id=\"使用Mysql数据表\"><a href=\"#使用Mysql数据表\" class=\"headerlink\" title=\"使用Mysql数据表\"></a>使用Mysql数据表</h2><p>为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。<br>实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。</p>\n<h2 id=\"使用Redis缓存session\"><a href=\"#使用Redis缓存session\" class=\"headerlink\" title=\"使用Redis缓存session\"></a>使用Redis缓存session</h2><p>Django项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：</p>\n<pre><code class=\"python\"># 获取当前session的session_key\nsession_key = request.session.session_key\n\n# 获取Redis中所有key\nkey_list = cache.keys(&quot;*&quot;)\n\n# 遍历获取到的所有key，通过正则筛选django的session记录\nfor key in key_list:\n    s_key = re.match(r&#39;django\\.contrib\\.sessions\\.cache(.*)&#39;, key)\n    # 如果session_key和当前session不同，则进行判断\n    if s_key and s_key.group(1) != session_key:\n        cache_session_dict = cache.get(key)\n        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录\n        if cache_session_dict.get(&#39;user_id&#39;) == user.id:\n            cache.delete(key)\n            logger.info(&#39;Account [{}] has logged in elsewhere, delete old session [{}]&#39;.format(username, key))\n            else:\n                continue</code></pre>\n<h2 id=\"视图装饰器\"><a href=\"#视图装饰器\" class=\"headerlink\" title=\"视图装饰器\"></a>视图装饰器</h2><p>为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。</p>\n<pre><code class=\"python\">def auth_required(perm):\n    def decorator(view_func):\n        def _wrapped_view(request, *args, **kwargs):\n\n            try:\n                session_key = request.session.session_key\n\n                # session_flag = Session.objects.filter(session_key=session_key)\n                if not session_key:\n                    return JsonResponse({&quot;respCode&quot;: 4001})\n                else:\n                    role = request.session.get(&quot;role_id&quot;)\n                    if not role:\n                        return JsonResponse({&quot;respCode&quot;: 4002})\n                    else:\n                        if int(role) &gt; int(perm):\n                            return JsonResponse({&quot;respCode&quot;: 4003})\n\n            except Exception as e:\n                logger.error(e)\n                return JsonResponse({&quot;respCode&quot;: 4004})\n\n            return view_func(request, *args, **kwargs)\n        return _wrapped_view\n    return decorator</code></pre>\n","site":{"data":{}},"excerpt":"<p>本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。</p>","more":"<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><p>要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。</p>\n<h2 id=\"使用Mysql数据表\"><a href=\"#使用Mysql数据表\" class=\"headerlink\" title=\"使用Mysql数据表\"></a>使用Mysql数据表</h2><p>为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。<br>实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。</p>\n<h2 id=\"使用Redis缓存session\"><a href=\"#使用Redis缓存session\" class=\"headerlink\" title=\"使用Redis缓存session\"></a>使用Redis缓存session</h2><p>Django项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：</p>\n<pre><code class=\"python\"># 获取当前session的session_key\nsession_key = request.session.session_key\n\n# 获取Redis中所有key\nkey_list = cache.keys(&quot;*&quot;)\n\n# 遍历获取到的所有key，通过正则筛选django的session记录\nfor key in key_list:\n    s_key = re.match(r&#39;django\\.contrib\\.sessions\\.cache(.*)&#39;, key)\n    # 如果session_key和当前session不同，则进行判断\n    if s_key and s_key.group(1) != session_key:\n        cache_session_dict = cache.get(key)\n        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录\n        if cache_session_dict.get(&#39;user_id&#39;) == user.id:\n            cache.delete(key)\n            logger.info(&#39;Account [{}] has logged in elsewhere, delete old session [{}]&#39;.format(username, key))\n            else:\n                continue</code></pre>\n<h2 id=\"视图装饰器\"><a href=\"#视图装饰器\" class=\"headerlink\" title=\"视图装饰器\"></a>视图装饰器</h2><p>为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。</p>\n<pre><code class=\"python\">def auth_required(perm):\n    def decorator(view_func):\n        def _wrapped_view(request, *args, **kwargs):\n\n            try:\n                session_key = request.session.session_key\n\n                # session_flag = Session.objects.filter(session_key=session_key)\n                if not session_key:\n                    return JsonResponse({&quot;respCode&quot;: 4001})\n                else:\n                    role = request.session.get(&quot;role_id&quot;)\n                    if not role:\n                        return JsonResponse({&quot;respCode&quot;: 4002})\n                    else:\n                        if int(role) &gt; int(perm):\n                            return JsonResponse({&quot;respCode&quot;: 4003})\n\n            except Exception as e:\n                logger.error(e)\n                return JsonResponse({&quot;respCode&quot;: 4004})\n\n            return view_func(request, *args, **kwargs)\n        return _wrapped_view\n    return decorator</code></pre>"},{"title":"Django实现语言切换","date":"2018-01-08T10:38:49.000Z","_content":"\nDjango提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：[https://djangobook-cn.readthedocs.io/en/latest/chapter19.html](https://djangobook-cn.readthedocs.io/en/latest/chapter19.html)\n\n<!--more-->\n\n## 配置\n\n- 首先在Django settings文件中加入中间件`django.middleware.locale.LocaleMiddleware`\n```python\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    # django语言国际化中间件\n    'django.middleware.locale.LocaleMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n- 然后增加`LANGUAGES`和`LOCALE_PATHS`配置，`locale`文件夹需要手动创建：\n```python\nLANGUAGES = (\n    ('zh-hans', '中文简体'),\n    ('en', 'English'),\n)\n\nLOCALE_PATHS = (\n    os.path.join(os.path.dirname(BASE_DIR), 'locale'),\n)\n```\n\n## 修改html模板文件\n\n- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面\n```python\n{% load i18n %}\n```\n- 在需要翻译的字符串上加上trans标签,例如：\n```python\n<li><a href=\"/management/language_set\"><i class=\"ti-settings\"></i> {% trans '语言设置' %}</a></li>\n```\n\n- 多次重复翻译的内容可以设置成常量：\n```python\n{% trans \"This is the title\" as the_title %}\n<title>{{ the_title }}</title>\n<meta name=\"description\" content=\"{{ the_title }}\">\n```\n\n- 如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：\n```html\n{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}\n```\n\n## 后端视图\n\n- 如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的`gettext`模块，代码示例如下：\n```python\nfrom django.utils.translation import gettext as _\n\ndef test_views(request):\n    response_str = _(\"中文字符串\")\n    return HttpResponse(response_str)\n    \n```\n\n- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`\n\n## JavaScript中的语言转换\n\n- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：\n```python\nurl(r'^jsi18n/$', JavaScriptCatalog.as_view(packages=['ProjectName']), name='javascript-catalog')\n```\n\n- 然后在模板中引入js(可放在公共页面)\n```python\n<script type=\"text/javascript\" src=\"{% url 'javascript-catalog' %}\"></script>\n```\n\n- 使用`gettext`在js中标记字符串，例如：\n```javascript\nfunction editpwd(){\n        layer.open({\n          type: 1,\n          title: gettext('修改密码'),\n          maxmin: true,\n          shadeClose: true, //点击遮罩关闭层\n          area : ['550px' , ''],\n          content:$('#addsort_style'),\n       })\n    }\n```\n\n- 需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到\n\n## 翻译文件生成与编译\n\n- 添加完翻译的标记后，执行以下命令即可在`locale`文件夹下生成翻译文件：\n\n`python manage.py makemessages -l en`\n`python manage.py makemessages -d djangojs -l en`\n\n- 执行成功后可以发现生成了`django.po`以及`djangojs.po`文件，然后就可以填充翻译后的字符串：\n```python\n#: DrBrain3/templates/Management/series_list.html:46\n#: DrBrain3/templates/Users/new_psw.html:89\nmsgid \"确认修改\"\nmsgstr \"Confirm the changes\"\n```\n需要注意，有时由于识别的错乱，执行`python manage.py makemessages -l en`后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示\n\n- 填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件\n\n`python manage.py compilemessages`\n\n## 如何切换语言\nDjango本身提供了语言切换的功能，可参考如下方法实现：\n\n- 在项目根路由文件`urls.py`中添加切换语言的url\n```python\nurl(r'^i18n/',include('django.conf.urls.i18n'))\n```\n\n- html页面中添加如下form表单\n```python\n<form action=\"{% url 'set_language' %}\" method=\"post\" id=\"change_language_form\" enctype=\"multipart/form-data\">\n\t{% csrf_token %}\n    <input type=\"hidden\" name=\"next\" value=\"\"/>\n\t<select class=\"change_language\" name=\"language\" id=\"language\" onclick=\"changeLan()\">\n\t\t{% for lang in LANGUAGES %}\n        \t<option value=\"{{ lang.0 }}\"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>\n\t\t{% endfor %}\n\t</select>\n</form>\n```\n\n- JavaScript代码\n```javascript\n$('.change_language').change(function (e) {\n    e.preventDefault();\n    $('#change_language_form').submit();\n    return false\n\n});\n```\n\n- 登录时记录用户选择的语言\n\n在用户登录的后端视图中加入：\n```python\nrequest.session['_language']='zh-hans'\n```\n\n","source":"_posts/Django实现语言切换.md","raw":"---\ntitle: Django实现语言切换\ndate: 2018-01-08 18:38:49\ntags: Django\ncategories: Django\n---\n\nDjango提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：[https://djangobook-cn.readthedocs.io/en/latest/chapter19.html](https://djangobook-cn.readthedocs.io/en/latest/chapter19.html)\n\n<!--more-->\n\n## 配置\n\n- 首先在Django settings文件中加入中间件`django.middleware.locale.LocaleMiddleware`\n```python\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    # django语言国际化中间件\n    'django.middleware.locale.LocaleMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n```\n\n- 然后增加`LANGUAGES`和`LOCALE_PATHS`配置，`locale`文件夹需要手动创建：\n```python\nLANGUAGES = (\n    ('zh-hans', '中文简体'),\n    ('en', 'English'),\n)\n\nLOCALE_PATHS = (\n    os.path.join(os.path.dirname(BASE_DIR), 'locale'),\n)\n```\n\n## 修改html模板文件\n\n- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面\n```python\n{% load i18n %}\n```\n- 在需要翻译的字符串上加上trans标签,例如：\n```python\n<li><a href=\"/management/language_set\"><i class=\"ti-settings\"></i> {% trans '语言设置' %}</a></li>\n```\n\n- 多次重复翻译的内容可以设置成常量：\n```python\n{% trans \"This is the title\" as the_title %}\n<title>{{ the_title }}</title>\n<meta name=\"description\" content=\"{{ the_title }}\">\n```\n\n- 如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：\n```html\n{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}\n```\n\n## 后端视图\n\n- 如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的`gettext`模块，代码示例如下：\n```python\nfrom django.utils.translation import gettext as _\n\ndef test_views(request):\n    response_str = _(\"中文字符串\")\n    return HttpResponse(response_str)\n    \n```\n\n- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`\n\n## JavaScript中的语言转换\n\n- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：\n```python\nurl(r'^jsi18n/$', JavaScriptCatalog.as_view(packages=['ProjectName']), name='javascript-catalog')\n```\n\n- 然后在模板中引入js(可放在公共页面)\n```python\n<script type=\"text/javascript\" src=\"{% url 'javascript-catalog' %}\"></script>\n```\n\n- 使用`gettext`在js中标记字符串，例如：\n```javascript\nfunction editpwd(){\n        layer.open({\n          type: 1,\n          title: gettext('修改密码'),\n          maxmin: true,\n          shadeClose: true, //点击遮罩关闭层\n          area : ['550px' , ''],\n          content:$('#addsort_style'),\n       })\n    }\n```\n\n- 需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到\n\n## 翻译文件生成与编译\n\n- 添加完翻译的标记后，执行以下命令即可在`locale`文件夹下生成翻译文件：\n\n`python manage.py makemessages -l en`\n`python manage.py makemessages -d djangojs -l en`\n\n- 执行成功后可以发现生成了`django.po`以及`djangojs.po`文件，然后就可以填充翻译后的字符串：\n```python\n#: DrBrain3/templates/Management/series_list.html:46\n#: DrBrain3/templates/Users/new_psw.html:89\nmsgid \"确认修改\"\nmsgstr \"Confirm the changes\"\n```\n需要注意，有时由于识别的错乱，执行`python manage.py makemessages -l en`后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示\n\n- 填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件\n\n`python manage.py compilemessages`\n\n## 如何切换语言\nDjango本身提供了语言切换的功能，可参考如下方法实现：\n\n- 在项目根路由文件`urls.py`中添加切换语言的url\n```python\nurl(r'^i18n/',include('django.conf.urls.i18n'))\n```\n\n- html页面中添加如下form表单\n```python\n<form action=\"{% url 'set_language' %}\" method=\"post\" id=\"change_language_form\" enctype=\"multipart/form-data\">\n\t{% csrf_token %}\n    <input type=\"hidden\" name=\"next\" value=\"\"/>\n\t<select class=\"change_language\" name=\"language\" id=\"language\" onclick=\"changeLan()\">\n\t\t{% for lang in LANGUAGES %}\n        \t<option value=\"{{ lang.0 }}\"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>\n\t\t{% endfor %}\n\t</select>\n</form>\n```\n\n- JavaScript代码\n```javascript\n$('.change_language').change(function (e) {\n    e.preventDefault();\n    $('#change_language_form').submit();\n    return false\n\n});\n```\n\n- 登录时记录用户选择的语言\n\n在用户登录的后端视图中加入：\n```python\nrequest.session['_language']='zh-hans'\n```\n\n","slug":"Django实现语言切换","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45ujs0006boui52q49dlc","content":"<p>Django提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：<a href=\"https://djangobook-cn.readthedocs.io/en/latest/chapter19.html\" target=\"_blank\" rel=\"noopener\">https://djangobook-cn.readthedocs.io/en/latest/chapter19.html</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li><p>首先在Django settings文件中加入中间件<code>django.middleware.locale.LocaleMiddleware</code></p>\n<pre><code class=\"python\">MIDDLEWARE = [\n  &#39;django.middleware.security.SecurityMiddleware&#39;,\n  &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,\n  # django语言国际化中间件\n  &#39;django.middleware.locale.LocaleMiddleware&#39;,\n  &#39;django.middleware.common.CommonMiddleware&#39;,\n  &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,\n  &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,\n  &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,\n  &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,\n]</code></pre>\n</li>\n<li><p>然后增加<code>LANGUAGES</code>和<code>LOCALE_PATHS</code>配置，<code>locale</code>文件夹需要手动创建：</p>\n<pre><code class=\"python\">LANGUAGES = (\n  (&#39;zh-hans&#39;, &#39;中文简体&#39;),\n  (&#39;en&#39;, &#39;English&#39;),\n)\n</code></pre>\n</li>\n</ul>\n<p>LOCALE_PATHS = (<br>    os.path.join(os.path.dirname(BASE_DIR), ‘locale’),<br>)</p>\n<pre><code>\n## 修改html模板文件\n\n- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面\n```python\n{% load i18n %}</code></pre><ul>\n<li><p>在需要翻译的字符串上加上trans标签,例如：</p>\n<pre><code class=\"python\">&lt;li&gt;&lt;a href=&quot;/management/language_set&quot;&gt;&lt;i class=&quot;ti-settings&quot;&gt;&lt;/i&gt; {% trans '语言设置' %}&lt;/a&gt;&lt;/li&gt;</code></pre>\n</li>\n<li><p>多次重复翻译的内容可以设置成常量：</p>\n<pre><code class=\"python\">{% trans \"This is the title\" as the_title %}\n&lt;title&gt;{{ the_title }}&lt;/title&gt;\n&lt;meta name=&quot;description&quot; content=&quot;{{ the_title }}&quot;&gt;</code></pre>\n</li>\n<li><p>如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：</p>\n<pre><code class=\"html\">{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}</code></pre>\n</li>\n</ul>\n<h2 id=\"后端视图\"><a href=\"#后端视图\" class=\"headerlink\" title=\"后端视图\"></a>后端视图</h2><ul>\n<li>如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的<code>gettext</code>模块，代码示例如下：<pre><code class=\"python\">from django.utils.translation import gettext as _\n</code></pre>\n</li>\n</ul>\n<p>def test_views(request):<br>    response_str = _(“中文字符串”)<br>    return HttpResponse(response_str)</p>\n<pre><code>\n- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`\n\n## JavaScript中的语言转换\n\n- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：\n```python\nurl(r&#39;^jsi18n/$&#39;, JavaScriptCatalog.as_view(packages=[&#39;ProjectName&#39;]), name=&#39;javascript-catalog&#39;)</code></pre><ul>\n<li><p>然后在模板中引入js(可放在公共页面)</p>\n<pre><code class=\"python\">&lt;script type=&quot;text/javascript&quot; src=&quot;{% url 'javascript-catalog' %}&quot;&gt;&lt;/script&gt;</code></pre>\n</li>\n<li><p>使用<code>gettext</code>在js中标记字符串，例如：</p>\n<pre><code class=\"javascript\">function editpwd(){\n      layer.open({\n        type: 1,\n        title: gettext(&#39;修改密码&#39;),\n        maxmin: true,\n        shadeClose: true, //点击遮罩关闭层\n        area : [&#39;550px&#39; , &#39;&#39;],\n        content:$(&#39;#addsort_style&#39;),\n     })\n  }</code></pre>\n</li>\n<li><p>需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到</p>\n</li>\n</ul>\n<h2 id=\"翻译文件生成与编译\"><a href=\"#翻译文件生成与编译\" class=\"headerlink\" title=\"翻译文件生成与编译\"></a>翻译文件生成与编译</h2><ul>\n<li>添加完翻译的标记后，执行以下命令即可在<code>locale</code>文件夹下生成翻译文件：</li>\n</ul>\n<p><code>python manage.py makemessages -l en</code><br><code>python manage.py makemessages -d djangojs -l en</code></p>\n<ul>\n<li><p>执行成功后可以发现生成了<code>django.po</code>以及<code>djangojs.po</code>文件，然后就可以填充翻译后的字符串：</p>\n<pre><code class=\"python\">#: DrBrain3/templates/Management/series_list.html:46\n#: DrBrain3/templates/Users/new_psw.html:89\nmsgid &quot;确认修改&quot;\nmsgstr &quot;Confirm the changes&quot;</code></pre>\n<p>需要注意，有时由于识别的错乱，执行<code>python manage.py makemessages -l en</code>后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示</p>\n</li>\n<li><p>填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件</p>\n</li>\n</ul>\n<p><code>python manage.py compilemessages</code></p>\n<h2 id=\"如何切换语言\"><a href=\"#如何切换语言\" class=\"headerlink\" title=\"如何切换语言\"></a>如何切换语言</h2><p>Django本身提供了语言切换的功能，可参考如下方法实现：</p>\n<ul>\n<li><p>在项目根路由文件<code>urls.py</code>中添加切换语言的url</p>\n<pre><code class=\"python\">url(r&#39;^i18n/&#39;,include(&#39;django.conf.urls.i18n&#39;))</code></pre>\n</li>\n<li><p>html页面中添加如下form表单</p>\n<pre><code class=\"python\">&lt;form action=&quot;{% url 'set_language' %}&quot; method=&quot;post&quot; id=&quot;change_language_form&quot; enctype=&quot;multipart/form-data&quot;&gt;\n  {% csrf_token %}\n  &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot;/&gt;\n  &lt;select class=&quot;change_language&quot; name=&quot;language&quot; id=&quot;language&quot; onclick=&quot;changeLan()&quot;&gt;\n      {% for lang in LANGUAGES %}\n        \t<option value=\"{{ lang.0 }}\"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>\n\t\t{% endfor %}\n  &lt;/select&gt;\n&lt;/form&gt;</code></pre>\n</li>\n<li><p>JavaScript代码</p>\n<pre><code class=\"javascript\">$(&#39;.change_language&#39;).change(function (e) {\n  e.preventDefault();\n  $(&#39;#change_language_form&#39;).submit();\n  return false\n</code></pre>\n</li>\n</ul>\n<p>});</p>\n<pre><code>\n- 登录时记录用户选择的语言\n\n在用户登录的后端视图中加入：\n```python\nrequest.session[&#39;_language&#39;]=&#39;zh-hans&#39;</code></pre>","site":{"data":{}},"excerpt":"<p>Django提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：<a href=\"https://djangobook-cn.readthedocs.io/en/latest/chapter19.html\" target=\"_blank\" rel=\"noopener\">https://djangobook-cn.readthedocs.io/en/latest/chapter19.html</a></p>","more":"<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li><p>首先在Django settings文件中加入中间件<code>django.middleware.locale.LocaleMiddleware</code></p>\n<pre><code class=\"python\">MIDDLEWARE = [\n  &#39;django.middleware.security.SecurityMiddleware&#39;,\n  &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,\n  # django语言国际化中间件\n  &#39;django.middleware.locale.LocaleMiddleware&#39;,\n  &#39;django.middleware.common.CommonMiddleware&#39;,\n  &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,\n  &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,\n  &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,\n  &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,\n]</code></pre>\n</li>\n<li><p>然后增加<code>LANGUAGES</code>和<code>LOCALE_PATHS</code>配置，<code>locale</code>文件夹需要手动创建：</p>\n<pre><code class=\"python\">LANGUAGES = (\n  (&#39;zh-hans&#39;, &#39;中文简体&#39;),\n  (&#39;en&#39;, &#39;English&#39;),\n)\n</code></pre>\n</li>\n</ul>\n<p>LOCALE_PATHS = (<br>    os.path.join(os.path.dirname(BASE_DIR), ‘locale’),<br>)</p>\n<pre><code>\n## 修改html模板文件\n\n- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面\n```python\n{% load i18n %}</code></pre><ul>\n<li><p>在需要翻译的字符串上加上trans标签,例如：</p>\n<pre><code class=\"python\">&lt;li&gt;&lt;a href=&quot;/management/language_set&quot;&gt;&lt;i class=&quot;ti-settings&quot;&gt;&lt;/i&gt; {% trans '语言设置' %}&lt;/a&gt;&lt;/li&gt;</code></pre>\n</li>\n<li><p>多次重复翻译的内容可以设置成常量：</p>\n<pre><code class=\"python\">{% trans \"This is the title\" as the_title %}\n&lt;title&gt;{{ the_title }}&lt;/title&gt;\n&lt;meta name=&quot;description&quot; content=&quot;{{ the_title }}&quot;&gt;</code></pre>\n</li>\n<li><p>如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：</p>\n<pre><code class=\"html\">{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}</code></pre>\n</li>\n</ul>\n<h2 id=\"后端视图\"><a href=\"#后端视图\" class=\"headerlink\" title=\"后端视图\"></a>后端视图</h2><ul>\n<li>如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的<code>gettext</code>模块，代码示例如下：<pre><code class=\"python\">from django.utils.translation import gettext as _\n</code></pre>\n</li>\n</ul>\n<p>def test_views(request):<br>    response_str = _(“中文字符串”)<br>    return HttpResponse(response_str)</p>\n<pre><code>\n- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`\n\n## JavaScript中的语言转换\n\n- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：\n```python\nurl(r&#39;^jsi18n/$&#39;, JavaScriptCatalog.as_view(packages=[&#39;ProjectName&#39;]), name=&#39;javascript-catalog&#39;)</code></pre><ul>\n<li><p>然后在模板中引入js(可放在公共页面)</p>\n<pre><code class=\"python\">&lt;script type=&quot;text/javascript&quot; src=&quot;{% url 'javascript-catalog' %}&quot;&gt;&lt;/script&gt;</code></pre>\n</li>\n<li><p>使用<code>gettext</code>在js中标记字符串，例如：</p>\n<pre><code class=\"javascript\">function editpwd(){\n      layer.open({\n        type: 1,\n        title: gettext(&#39;修改密码&#39;),\n        maxmin: true,\n        shadeClose: true, //点击遮罩关闭层\n        area : [&#39;550px&#39; , &#39;&#39;],\n        content:$(&#39;#addsort_style&#39;),\n     })\n  }</code></pre>\n</li>\n<li><p>需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到</p>\n</li>\n</ul>\n<h2 id=\"翻译文件生成与编译\"><a href=\"#翻译文件生成与编译\" class=\"headerlink\" title=\"翻译文件生成与编译\"></a>翻译文件生成与编译</h2><ul>\n<li>添加完翻译的标记后，执行以下命令即可在<code>locale</code>文件夹下生成翻译文件：</li>\n</ul>\n<p><code>python manage.py makemessages -l en</code><br><code>python manage.py makemessages -d djangojs -l en</code></p>\n<ul>\n<li><p>执行成功后可以发现生成了<code>django.po</code>以及<code>djangojs.po</code>文件，然后就可以填充翻译后的字符串：</p>\n<pre><code class=\"python\">#: DrBrain3/templates/Management/series_list.html:46\n#: DrBrain3/templates/Users/new_psw.html:89\nmsgid &quot;确认修改&quot;\nmsgstr &quot;Confirm the changes&quot;</code></pre>\n<p>需要注意，有时由于识别的错乱，执行<code>python manage.py makemessages -l en</code>后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示</p>\n</li>\n<li><p>填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件</p>\n</li>\n</ul>\n<p><code>python manage.py compilemessages</code></p>\n<h2 id=\"如何切换语言\"><a href=\"#如何切换语言\" class=\"headerlink\" title=\"如何切换语言\"></a>如何切换语言</h2><p>Django本身提供了语言切换的功能，可参考如下方法实现：</p>\n<ul>\n<li><p>在项目根路由文件<code>urls.py</code>中添加切换语言的url</p>\n<pre><code class=\"python\">url(r&#39;^i18n/&#39;,include(&#39;django.conf.urls.i18n&#39;))</code></pre>\n</li>\n<li><p>html页面中添加如下form表单</p>\n<pre><code class=\"python\">&lt;form action=&quot;{% url 'set_language' %}&quot; method=&quot;post&quot; id=&quot;change_language_form&quot; enctype=&quot;multipart/form-data&quot;&gt;\n  {% csrf_token %}\n  &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot;/&gt;\n  &lt;select class=&quot;change_language&quot; name=&quot;language&quot; id=&quot;language&quot; onclick=&quot;changeLan()&quot;&gt;\n      {% for lang in LANGUAGES %}\n        \t<option value=\"{{ lang.0 }}\"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>\n\t\t{% endfor %}\n  &lt;/select&gt;\n&lt;/form&gt;</code></pre>\n</li>\n<li><p>JavaScript代码</p>\n<pre><code class=\"javascript\">$(&#39;.change_language&#39;).change(function (e) {\n  e.preventDefault();\n  $(&#39;#change_language_form&#39;).submit();\n  return false\n</code></pre>\n</li>\n</ul>\n<p>});</p>\n<pre><code>\n- 登录时记录用户选择的语言\n\n在用户登录的后端视图中加入：\n```python\nrequest.session[&#39;_language&#39;]=&#39;zh-hans&#39;</code></pre>"},{"title":"Docker使用总结","date":"2020-01-08T12:54:40.000Z","_content":"\n# Docker使用总结\n\nDocker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。\n\n## 基本概念\n\n- **镜像 image**\n\nDocker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行`docker search python`就可以看到各种python镜像。\n![1.png](/img/Docker/1.png)\n实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。\n\n要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行`docker pull python`就可以直接拉取一个官方python镜像，再执行`docker images`就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。\n![2.png](/img/Docker/2.png)\n\n- **容器 container**\n\n有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行`docker ps -a`或者`docker container ls -a`就可以看到所有正在运行或不在运行的容器：\n![3.png](/img/Docker/3.png)\n\n我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，`IMAGE`一栏表示当前容器是基于哪个镜像创建的；`COMMAND`代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；`PORTS`则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个`nginx`应用绑定`80`端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问`http://宿主机ip:80`将相当于访问`nginx`应用了。\n\n关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用`docker run -xxx xxx image_name`创建容器，常用的一些参数如下：\n\n--后台运行\n通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上`-d`参数\n\n-- 重新启动\n通过`--restart=always`的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：\n`no`:容器退出时不要自动重启（默认值）\n`on-failure[:max-retries]`:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数\n`always`:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器\n`unless-stopped`:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器\n\n-- root权限\n正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上`--privileged=true`来赋予容器真正root权限\n\n-- 文件挂载\n文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了\n\n-- 指定ip\ndocker容器启动后，宿主机默认ip为`172.17.0.1`，启动的容器按照时间顺序绑定ip,例如`172.17.0.2`，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行`docker network create --subnet=192.168.0.0/16 staticnet`创建一个名为staticnet的私有网络，网段为`192.168.0.0/16`,之后在创建容器时，就可以通过`--net staticnet --ip 192.168.0.2`来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。\n\n- **仓库 repository**\n\nDocker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)\n\n## 制作镜像\n我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：\n\n- **docker commit的方式**\n\n--在获取了一个基础镜像后，我们可以基于它启动一个容器，如`docker run -itd --name python_container python /bin/bash`命令创建并启动一个python容器：\n![6.png](/img/Docker/6.png)\n\n查看容器\n![4.png](/img/Docker/4.png)\n\n--随后执行`docker exec -it python_container /bin/bash`进入容器，我们可以在容器中安装依赖环境，例如将项目中的`requirements.txt`放入容器后执行`pip install -r requirements.txt`，执行完毕，退出容器\n\n--最后，通过`docker commit python_container new_python_image`命令将安装好依赖的python容器打包成一个名为`new_python_image`的镜像，此时通过`docker images`就可以看到新的镜像了.\n提交镜像:\n![5.png](/img/Docker/5.png)\n\n查看制作好的镜像:\n![7.png](/img/Docker/7.png)\n\n- **Dockerfile的方式**\n\n通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。\n\nDockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)\n\n下面是一个简单的Dockerfile示例：\n```\n# 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中的/目录下\nCOPY requirements.txt /\n\n# 安装项目所需的python依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n```\n注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过`docker build -t image_name .`开始制作镜像，等待完成即可\n\n## 创建容器\n创建容器最常见的方式是通过`docker run`命令，详细参数可参考：[https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/)\n\n当我们有多个容器需要创建并配置时，可以使用`docker-compose`工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：\n```yaml\n# docker_compose.yaml 配置实例\nversion: \"3\"\nservices: \n    nginx: \n        # 指定镜像\n        image: nginx\n        \n        # 指定容器名称\n        container_name: nginx_container\n        \n        # 端口映射\n        ports: \n            - 8080:8080\n            \n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n            \n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n                \n        # 启动后指定的命令\n        command: nginx -g 'daemon off;'\n        \n        privileged: true\n        restart: always\n        \nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n```\n（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）\n\n编写完docker_compose.yaml文件，就可以在该文件路径下执行`docker-compose up -d .`,一键创建、启动容器。\n\n## 参考及链接\n\n参考文章：[https://zhuanlan.zhihu.com/p/23599229](https://zhuanlan.zhihu.com/p/23599229)\n\nDocker入门介绍及常用命令：[https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7](https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7)\n\n使用Docker部署一套Nginx + uWSGI + Django的范例：[https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/](https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Docker使用总结.md","raw":"---\ntitle: Docker使用总结\ndate: 2020-01-08 20:54:40\ntags: Docker\ncategories: Docker\n---\n\n# Docker使用总结\n\nDocker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。\n\n## 基本概念\n\n- **镜像 image**\n\nDocker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行`docker search python`就可以看到各种python镜像。\n![1.png](/img/Docker/1.png)\n实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。\n\n要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行`docker pull python`就可以直接拉取一个官方python镜像，再执行`docker images`就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。\n![2.png](/img/Docker/2.png)\n\n- **容器 container**\n\n有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行`docker ps -a`或者`docker container ls -a`就可以看到所有正在运行或不在运行的容器：\n![3.png](/img/Docker/3.png)\n\n我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，`IMAGE`一栏表示当前容器是基于哪个镜像创建的；`COMMAND`代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；`PORTS`则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个`nginx`应用绑定`80`端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问`http://宿主机ip:80`将相当于访问`nginx`应用了。\n\n关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用`docker run -xxx xxx image_name`创建容器，常用的一些参数如下：\n\n--后台运行\n通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上`-d`参数\n\n-- 重新启动\n通过`--restart=always`的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：\n`no`:容器退出时不要自动重启（默认值）\n`on-failure[:max-retries]`:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数\n`always`:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器\n`unless-stopped`:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器\n\n-- root权限\n正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上`--privileged=true`来赋予容器真正root权限\n\n-- 文件挂载\n文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了\n\n-- 指定ip\ndocker容器启动后，宿主机默认ip为`172.17.0.1`，启动的容器按照时间顺序绑定ip,例如`172.17.0.2`，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行`docker network create --subnet=192.168.0.0/16 staticnet`创建一个名为staticnet的私有网络，网段为`192.168.0.0/16`,之后在创建容器时，就可以通过`--net staticnet --ip 192.168.0.2`来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。\n\n- **仓库 repository**\n\nDocker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)\n\n## 制作镜像\n我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：\n\n- **docker commit的方式**\n\n--在获取了一个基础镜像后，我们可以基于它启动一个容器，如`docker run -itd --name python_container python /bin/bash`命令创建并启动一个python容器：\n![6.png](/img/Docker/6.png)\n\n查看容器\n![4.png](/img/Docker/4.png)\n\n--随后执行`docker exec -it python_container /bin/bash`进入容器，我们可以在容器中安装依赖环境，例如将项目中的`requirements.txt`放入容器后执行`pip install -r requirements.txt`，执行完毕，退出容器\n\n--最后，通过`docker commit python_container new_python_image`命令将安装好依赖的python容器打包成一个名为`new_python_image`的镜像，此时通过`docker images`就可以看到新的镜像了.\n提交镜像:\n![5.png](/img/Docker/5.png)\n\n查看制作好的镜像:\n![7.png](/img/Docker/7.png)\n\n- **Dockerfile的方式**\n\n通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。\n\nDockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)\n\n下面是一个简单的Dockerfile示例：\n```\n# 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中的/目录下\nCOPY requirements.txt /\n\n# 安装项目所需的python依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n```\n注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过`docker build -t image_name .`开始制作镜像，等待完成即可\n\n## 创建容器\n创建容器最常见的方式是通过`docker run`命令，详细参数可参考：[https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/)\n\n当我们有多个容器需要创建并配置时，可以使用`docker-compose`工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：\n```yaml\n# docker_compose.yaml 配置实例\nversion: \"3\"\nservices: \n    nginx: \n        # 指定镜像\n        image: nginx\n        \n        # 指定容器名称\n        container_name: nginx_container\n        \n        # 端口映射\n        ports: \n            - 8080:8080\n            \n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n            \n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n                \n        # 启动后指定的命令\n        command: nginx -g 'daemon off;'\n        \n        privileged: true\n        restart: always\n        \nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n```\n（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）\n\n编写完docker_compose.yaml文件，就可以在该文件路径下执行`docker-compose up -d .`,一键创建、启动容器。\n\n## 参考及链接\n\n参考文章：[https://zhuanlan.zhihu.com/p/23599229](https://zhuanlan.zhihu.com/p/23599229)\n\nDocker入门介绍及常用命令：[https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7](https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7)\n\n使用Docker部署一套Nginx + uWSGI + Django的范例：[https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/](https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Docker使用总结","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45ujw0008bouihrxr394v","content":"<h1 id=\"Docker使用总结\"><a href=\"#Docker使用总结\" class=\"headerlink\" title=\"Docker使用总结\"></a>Docker使用总结</h1><p>Docker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><strong>镜像 image</strong></li>\n</ul>\n<p>Docker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行<code>docker search python</code>就可以看到各种python镜像。<br><img src=\"/img/Docker/1.png\" srcset=\"/img/loading.gif\" alt=\"1.png\"><br>实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。</p>\n<p>要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行<code>docker pull python</code>就可以直接拉取一个官方python镜像，再执行<code>docker images</code>就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。<br><img src=\"/img/Docker/2.png\" srcset=\"/img/loading.gif\" alt=\"2.png\"></p>\n<ul>\n<li><strong>容器 container</strong></li>\n</ul>\n<p>有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行<code>docker ps -a</code>或者<code>docker container ls -a</code>就可以看到所有正在运行或不在运行的容器：<br><img src=\"/img/Docker/3.png\" srcset=\"/img/loading.gif\" alt=\"3.png\"></p>\n<p>我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，<code>IMAGE</code>一栏表示当前容器是基于哪个镜像创建的；<code>COMMAND</code>代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；<code>PORTS</code>则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个<code>nginx</code>应用绑定<code>80</code>端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问<code>http://宿主机ip:80</code>将相当于访问<code>nginx</code>应用了。</p>\n<p>关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用<code>docker run -xxx xxx image_name</code>创建容器，常用的一些参数如下：</p>\n<p>–后台运行<br>通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上<code>-d</code>参数</p>\n<p>– 重新启动<br>通过<code>--restart=always</code>的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：<br><code>no</code>:容器退出时不要自动重启（默认值）<br><code>on-failure[:max-retries]</code>:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数<br><code>always</code>:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器<br><code>unless-stopped</code>:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p>\n<p>– root权限<br>正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上<code>--privileged=true</code>来赋予容器真正root权限</p>\n<p>– 文件挂载<br>文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了</p>\n<p>– 指定ip<br>docker容器启动后，宿主机默认ip为<code>172.17.0.1</code>，启动的容器按照时间顺序绑定ip,例如<code>172.17.0.2</code>，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行<code>docker network create --subnet=192.168.0.0/16 staticnet</code>创建一个名为staticnet的私有网络，网段为<code>192.168.0.0/16</code>,之后在创建容器时，就可以通过<code>--net staticnet --ip 192.168.0.2</code>来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。</p>\n<ul>\n<li><strong>仓库 repository</strong></li>\n</ul>\n<p>Docker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a></p>\n<h2 id=\"制作镜像\"><a href=\"#制作镜像\" class=\"headerlink\" title=\"制作镜像\"></a>制作镜像</h2><p>我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：</p>\n<ul>\n<li><strong>docker commit的方式</strong></li>\n</ul>\n<p>–在获取了一个基础镜像后，我们可以基于它启动一个容器，如<code>docker run -itd --name python_container python /bin/bash</code>命令创建并启动一个python容器：<br><img src=\"/img/Docker/6.png\" srcset=\"/img/loading.gif\" alt=\"6.png\"></p>\n<p>查看容器<br><img src=\"/img/Docker/4.png\" srcset=\"/img/loading.gif\" alt=\"4.png\"></p>\n<p>–随后执行<code>docker exec -it python_container /bin/bash</code>进入容器，我们可以在容器中安装依赖环境，例如将项目中的<code>requirements.txt</code>放入容器后执行<code>pip install -r requirements.txt</code>，执行完毕，退出容器</p>\n<p>–最后，通过<code>docker commit python_container new_python_image</code>命令将安装好依赖的python容器打包成一个名为<code>new_python_image</code>的镜像，此时通过<code>docker images</code>就可以看到新的镜像了.<br>提交镜像:<br><img src=\"/img/Docker/5.png\" srcset=\"/img/loading.gif\" alt=\"5.png\"></p>\n<p>查看制作好的镜像:<br><img src=\"/img/Docker/7.png\" srcset=\"/img/loading.gif\" alt=\"7.png\"></p>\n<ul>\n<li><strong>Dockerfile的方式</strong></li>\n</ul>\n<p>通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。</p>\n<p>Dockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考<a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/builder/</a></p>\n<p>下面是一个简单的Dockerfile示例：</p>\n<pre><code># 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中的/目录下\nCOPY requirements.txt /\n\n# 安装项目所需的python依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</code></pre><p>注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过<code>docker build -t image_name .</code>开始制作镜像，等待完成即可</p>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><p>创建容器最常见的方式是通过<code>docker run</code>命令，详细参数可参考：<a href=\"https://docs.docker.com/engine/reference/commandline/run/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/commandline/run/</a></p>\n<p>当我们有多个容器需要创建并配置时，可以使用<code>docker-compose</code>工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：</p>\n<pre><code class=\"yaml\"># docker_compose.yaml 配置实例\nversion: &quot;3&quot;\nservices: \n    nginx: \n        # 指定镜像\n        image: nginx\n\n        # 指定容器名称\n        container_name: nginx_container\n\n        # 端口映射\n        ports: \n            - 8080:8080\n\n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n\n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n\n        # 启动后指定的命令\n        command: nginx -g &#39;daemon off;&#39;\n\n        privileged: true\n        restart: always\n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16</code></pre>\n<p>（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）</p>\n<p>编写完docker_compose.yaml文件，就可以在该文件路径下执行<code>docker-compose up -d .</code>,一键创建、启动容器。</p>\n<h2 id=\"参考及链接\"><a href=\"#参考及链接\" class=\"headerlink\" title=\"参考及链接\"></a>参考及链接</h2><p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/23599229\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23599229</a></p>\n<p>Docker入门介绍及常用命令：<a href=\"https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&amp;mid=2247488151&amp;idx=1&amp;sn=b65d355055746b8720c0a989b704666a&amp;chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&amp;ascene=1&amp;uin=NjE4ODY0Mzg0&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7</a></p>\n<p>使用Docker部署一套Nginx + uWSGI + Django的范例：<a href=\"https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/\">https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Docker使用总结\"><a href=\"#Docker使用总结\" class=\"headerlink\" title=\"Docker使用总结\"></a>Docker使用总结</h1><p>Docker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><strong>镜像 image</strong></li>\n</ul>\n<p>Docker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行<code>docker search python</code>就可以看到各种python镜像。<br><img src=\"/img/Docker/1.png\" srcset=\"/img/loading.gif\" alt=\"1.png\"><br>实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。</p>\n<p>要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行<code>docker pull python</code>就可以直接拉取一个官方python镜像，再执行<code>docker images</code>就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。<br><img src=\"/img/Docker/2.png\" srcset=\"/img/loading.gif\" alt=\"2.png\"></p>\n<ul>\n<li><strong>容器 container</strong></li>\n</ul>\n<p>有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行<code>docker ps -a</code>或者<code>docker container ls -a</code>就可以看到所有正在运行或不在运行的容器：<br><img src=\"/img/Docker/3.png\" srcset=\"/img/loading.gif\" alt=\"3.png\"></p>\n<p>我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，<code>IMAGE</code>一栏表示当前容器是基于哪个镜像创建的；<code>COMMAND</code>代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；<code>PORTS</code>则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个<code>nginx</code>应用绑定<code>80</code>端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问<code>http://宿主机ip:80</code>将相当于访问<code>nginx</code>应用了。</p>\n<p>关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用<code>docker run -xxx xxx image_name</code>创建容器，常用的一些参数如下：</p>\n<p>–后台运行<br>通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上<code>-d</code>参数</p>\n<p>– 重新启动<br>通过<code>--restart=always</code>的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：<br><code>no</code>:容器退出时不要自动重启（默认值）<br><code>on-failure[:max-retries]</code>:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数<br><code>always</code>:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器<br><code>unless-stopped</code>:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p>\n<p>– root权限<br>正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上<code>--privileged=true</code>来赋予容器真正root权限</p>\n<p>– 文件挂载<br>文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了</p>\n<p>– 指定ip<br>docker容器启动后，宿主机默认ip为<code>172.17.0.1</code>，启动的容器按照时间顺序绑定ip,例如<code>172.17.0.2</code>，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行<code>docker network create --subnet=192.168.0.0/16 staticnet</code>创建一个名为staticnet的私有网络，网段为<code>192.168.0.0/16</code>,之后在创建容器时，就可以通过<code>--net staticnet --ip 192.168.0.2</code>来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。</p>\n<ul>\n<li><strong>仓库 repository</strong></li>\n</ul>\n<p>Docker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a></p>\n<h2 id=\"制作镜像\"><a href=\"#制作镜像\" class=\"headerlink\" title=\"制作镜像\"></a>制作镜像</h2><p>我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：</p>\n<ul>\n<li><strong>docker commit的方式</strong></li>\n</ul>\n<p>–在获取了一个基础镜像后，我们可以基于它启动一个容器，如<code>docker run -itd --name python_container python /bin/bash</code>命令创建并启动一个python容器：<br><img src=\"/img/Docker/6.png\" srcset=\"/img/loading.gif\" alt=\"6.png\"></p>\n<p>查看容器<br><img src=\"/img/Docker/4.png\" srcset=\"/img/loading.gif\" alt=\"4.png\"></p>\n<p>–随后执行<code>docker exec -it python_container /bin/bash</code>进入容器，我们可以在容器中安装依赖环境，例如将项目中的<code>requirements.txt</code>放入容器后执行<code>pip install -r requirements.txt</code>，执行完毕，退出容器</p>\n<p>–最后，通过<code>docker commit python_container new_python_image</code>命令将安装好依赖的python容器打包成一个名为<code>new_python_image</code>的镜像，此时通过<code>docker images</code>就可以看到新的镜像了.<br>提交镜像:<br><img src=\"/img/Docker/5.png\" srcset=\"/img/loading.gif\" alt=\"5.png\"></p>\n<p>查看制作好的镜像:<br><img src=\"/img/Docker/7.png\" srcset=\"/img/loading.gif\" alt=\"7.png\"></p>\n<ul>\n<li><strong>Dockerfile的方式</strong></li>\n</ul>\n<p>通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。</p>\n<p>Dockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考<a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/builder/</a></p>\n<p>下面是一个简单的Dockerfile示例：</p>\n<pre><code># 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中的/目录下\nCOPY requirements.txt /\n\n# 安装项目所需的python依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</code></pre><p>注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过<code>docker build -t image_name .</code>开始制作镜像，等待完成即可</p>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><p>创建容器最常见的方式是通过<code>docker run</code>命令，详细参数可参考：<a href=\"https://docs.docker.com/engine/reference/commandline/run/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/commandline/run/</a></p>\n<p>当我们有多个容器需要创建并配置时，可以使用<code>docker-compose</code>工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：</p>\n<pre><code class=\"yaml\"># docker_compose.yaml 配置实例\nversion: &quot;3&quot;\nservices: \n    nginx: \n        # 指定镜像\n        image: nginx\n\n        # 指定容器名称\n        container_name: nginx_container\n\n        # 端口映射\n        ports: \n            - 8080:8080\n\n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n\n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n\n        # 启动后指定的命令\n        command: nginx -g &#39;daemon off;&#39;\n\n        privileged: true\n        restart: always\n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16</code></pre>\n<p>（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）</p>\n<p>编写完docker_compose.yaml文件，就可以在该文件路径下执行<code>docker-compose up -d .</code>,一键创建、启动容器。</p>\n<h2 id=\"参考及链接\"><a href=\"#参考及链接\" class=\"headerlink\" title=\"参考及链接\"></a>参考及链接</h2><p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/23599229\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23599229</a></p>\n<p>Docker入门介绍及常用命令：<a href=\"https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&amp;mid=2247488151&amp;idx=1&amp;sn=b65d355055746b8720c0a989b704666a&amp;chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&amp;ascene=1&amp;uin=NjE4ODY0Mzg0&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7</a></p>\n<p>使用Docker部署一套Nginx + uWSGI + Django的范例：<a href=\"https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/\">https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</a></p>\n"},{"title":"Docker部署Nginx + uWSGI + Django实践","date":"2019-12-10T12:29:49.000Z","_content":"\n## 简介\nDocker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.\n\n<!--more-->\n\n阅读前需要对一些基本技术有所了解，以下仅供参考：\n\nDocker:  [https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html](https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html)\n [https://zhuanlan.zhihu.com/p/23599229](https://zhuanlan.zhihu.com/p/23599229)\nNginx、uWSGI：[https://blog.csdn.net/weixin_40907382/article/details/80824167](https://blog.csdn.net/weixin_40907382/article/details/80824167)\n\n## Docker安装\n\n```shell\n# 查看centos系统版本，内核版本要求不低于3.10\nuname -r\n\n# 更新yum\nsudo yum -y update\n\n# 安装需要的软件包\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 设置yum源\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n# 查看仓库中所有docker版本\nyum list docker-ce --showduplicates | sort -r\n\n# 选择其中一个版本安装\nyum -y install docker-ce-18.06.3.ce\n\n# 启动Docker服务，并设置为开机启动\nsystemctl start docker\nsystemctl enable docker\n\n# 测试是否安装成功\ndocker version\n\n# 安装docker-compose工具（用于容器编排）\nsudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n\n```\n\n## 镜像准备\nNginx：可直接从docker hub中拉取，执行`docker pull nginx`\nPython：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：`docker pull python:3.6.8`\n\n接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用`docker commit`打包为镜像，但这样做有一些坏处：\n在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用`docker commit`制作镜像，会导致镜像越来越臃肿；其次，由于使用`docker commit`制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。\n因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：[https://yeasy.gitbooks.io/docker_practice/content/image/build.html](https://yeasy.gitbooks.io/docker_practice/content/image/build.html)，一个简单的Dockerfile如下：\n```shell\n# 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中\nCOPY requirements.txt /\n\n# 安装依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n\n# 创建uwsgi软链接\nRUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi\n```\n\n## 创建容器\n镜像制作完成，就可以开始创建容器了，可以直接使用`docker run`命令来创建，也可以使用`docker-compose`工具，下面首先介绍`docker run`的方式：\n\nNginx: \n```shell\ndocker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx\n```\n\nuWSGI：\n```shell\ndocker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n```\n\n参数解释：\n`-it`：让Docker分配一个伪终端,并绑定到容器的标准输入上\n`--name`：指定容器的名称\n`--privileged`：让容器内的root用户拥有真正root权限\n`-p`：指定端口映射，将宿主机的端口映射到容器端口\n`-v`：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器\n  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。\n`--net`：指定容器所在的网段（需要提前创建一个网段）\n`--ip`：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动\n`--restart`：在容器退出时总是重启容器，保证容器始终运行\n`-d`：让容器在后台运行\n\n## 使用docker-compose工具\n使用`docker run`命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个`docker_compose.yaml`文件，然后通过`docker-compose up -d .`命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：\n\n```shell\nversion: \"3\"\nservices: \n    nginx: \n    \t\t# 指定镜像\n        image: nginx\n        \n        # 指定容器名称\n        container_name: nginx_container\n        \n        # 端口映射\n        ports: \n            - 8080:8080\n            \n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n            \n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n                \n        # 启动后指定的命令\n        command: nginx -g 'daemon off;'\n        \n        privileged: true\n        restart: always\n    \n    uwsgi:\n        container_name: uwsgi_container\n        ports: \n            - 8090:8090\n        volumes:\n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages\n        networks:\n            extnetwork: \n                ipv4_address: 192.168.0.3\n        privileged: true\n        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n        restart: always        \n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n\n\n\n```\n\n注意：Nginx容器的启动命令是`nginx -g 'daemon off;'`，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上`daemon off`参数。\n\n## 总结\n以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。\n","source":"_posts/Docker部署Nginx + uWSGI + Django实践.md","raw":"---\ntitle: Docker部署Nginx + uWSGI + Django实践\ndate: 2019-12-10 20:29:49\ntags: [Docker,Django,Nginx]\ncategories: Docker\n---\n\n## 简介\nDocker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.\n\n<!--more-->\n\n阅读前需要对一些基本技术有所了解，以下仅供参考：\n\nDocker:  [https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html](https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html)\n [https://zhuanlan.zhihu.com/p/23599229](https://zhuanlan.zhihu.com/p/23599229)\nNginx、uWSGI：[https://blog.csdn.net/weixin_40907382/article/details/80824167](https://blog.csdn.net/weixin_40907382/article/details/80824167)\n\n## Docker安装\n\n```shell\n# 查看centos系统版本，内核版本要求不低于3.10\nuname -r\n\n# 更新yum\nsudo yum -y update\n\n# 安装需要的软件包\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 设置yum源\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n# 查看仓库中所有docker版本\nyum list docker-ce --showduplicates | sort -r\n\n# 选择其中一个版本安装\nyum -y install docker-ce-18.06.3.ce\n\n# 启动Docker服务，并设置为开机启动\nsystemctl start docker\nsystemctl enable docker\n\n# 测试是否安装成功\ndocker version\n\n# 安装docker-compose工具（用于容器编排）\nsudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n\n```\n\n## 镜像准备\nNginx：可直接从docker hub中拉取，执行`docker pull nginx`\nPython：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：`docker pull python:3.6.8`\n\n接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用`docker commit`打包为镜像，但这样做有一些坏处：\n在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用`docker commit`制作镜像，会导致镜像越来越臃肿；其次，由于使用`docker commit`制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。\n因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：[https://yeasy.gitbooks.io/docker_practice/content/image/build.html](https://yeasy.gitbooks.io/docker_practice/content/image/build.html)，一个简单的Dockerfile如下：\n```shell\n# 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中\nCOPY requirements.txt /\n\n# 安装依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n\n# 创建uwsgi软链接\nRUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi\n```\n\n## 创建容器\n镜像制作完成，就可以开始创建容器了，可以直接使用`docker run`命令来创建，也可以使用`docker-compose`工具，下面首先介绍`docker run`的方式：\n\nNginx: \n```shell\ndocker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx\n```\n\nuWSGI：\n```shell\ndocker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n```\n\n参数解释：\n`-it`：让Docker分配一个伪终端,并绑定到容器的标准输入上\n`--name`：指定容器的名称\n`--privileged`：让容器内的root用户拥有真正root权限\n`-p`：指定端口映射，将宿主机的端口映射到容器端口\n`-v`：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器\n  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。\n`--net`：指定容器所在的网段（需要提前创建一个网段）\n`--ip`：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动\n`--restart`：在容器退出时总是重启容器，保证容器始终运行\n`-d`：让容器在后台运行\n\n## 使用docker-compose工具\n使用`docker run`命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个`docker_compose.yaml`文件，然后通过`docker-compose up -d .`命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：\n\n```shell\nversion: \"3\"\nservices: \n    nginx: \n    \t\t# 指定镜像\n        image: nginx\n        \n        # 指定容器名称\n        container_name: nginx_container\n        \n        # 端口映射\n        ports: \n            - 8080:8080\n            \n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n            \n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n                \n        # 启动后指定的命令\n        command: nginx -g 'daemon off;'\n        \n        privileged: true\n        restart: always\n    \n    uwsgi:\n        container_name: uwsgi_container\n        ports: \n            - 8090:8090\n        volumes:\n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages\n        networks:\n            extnetwork: \n                ipv4_address: 192.168.0.3\n        privileged: true\n        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n        restart: always        \n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n\n\n\n```\n\n注意：Nginx容器的启动命令是`nginx -g 'daemon off;'`，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上`daemon off`参数。\n\n## 总结\n以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。\n","slug":"Docker部署Nginx + uWSGI + Django实践","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45ujy000abouihi6rb3ou","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Docker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.</p>\n<a id=\"more\"></a>\n\n<p>阅读前需要对一些基本技术有所了解，以下仅供参考：</p>\n<p>Docker:  <a href=\"https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a><br> <a href=\"https://zhuanlan.zhihu.com/p/23599229\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23599229</a><br>Nginx、uWSGI：<a href=\"https://blog.csdn.net/weixin_40907382/article/details/80824167\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_40907382/article/details/80824167</a></p>\n<h2 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h2><pre><code class=\"shell\"># 查看centos系统版本，内核版本要求不低于3.10\nuname -r\n\n# 更新yum\nsudo yum -y update\n\n# 安装需要的软件包\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 设置yum源\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n# 查看仓库中所有docker版本\nyum list docker-ce --showduplicates | sort -r\n\n# 选择其中一个版本安装\nyum -y install docker-ce-18.06.3.ce\n\n# 启动Docker服务，并设置为开机启动\nsystemctl start docker\nsystemctl enable docker\n\n# 测试是否安装成功\ndocker version\n\n# 安装docker-compose工具（用于容器编排）\nsudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n</code></pre>\n<h2 id=\"镜像准备\"><a href=\"#镜像准备\" class=\"headerlink\" title=\"镜像准备\"></a>镜像准备</h2><p>Nginx：可直接从docker hub中拉取，执行<code>docker pull nginx</code><br>Python：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：<code>docker pull python:3.6.8</code></p>\n<p>接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用<code>docker commit</code>打包为镜像，但这样做有一些坏处：<br>在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用<code>docker commit</code>制作镜像，会导致镜像越来越臃肿；其次，由于使用<code>docker commit</code>制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。<br>因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：<a href=\"https://yeasy.gitbooks.io/docker_practice/content/image/build.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a>，一个简单的Dockerfile如下：</p>\n<pre><code class=\"shell\"># 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中\nCOPY requirements.txt /\n\n# 安装依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n\n# 创建uwsgi软链接\nRUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><p>镜像制作完成，就可以开始创建容器了，可以直接使用<code>docker run</code>命令来创建，也可以使用<code>docker-compose</code>工具，下面首先介绍<code>docker run</code>的方式：</p>\n<p>Nginx: </p>\n<pre><code class=\"shell\">docker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx</code></pre>\n<p>uWSGI：</p>\n<pre><code class=\"shell\">docker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</code></pre>\n<p>参数解释：<br><code>-it</code>：让Docker分配一个伪终端,并绑定到容器的标准输入上<br><code>--name</code>：指定容器的名称<br><code>--privileged</code>：让容器内的root用户拥有真正root权限<br><code>-p</code>：指定端口映射，将宿主机的端口映射到容器端口<br><code>-v</code>：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器<br>  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。<br><code>--net</code>：指定容器所在的网段（需要提前创建一个网段）<br><code>--ip</code>：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动<br><code>--restart</code>：在容器退出时总是重启容器，保证容器始终运行<br><code>-d</code>：让容器在后台运行</p>\n<h2 id=\"使用docker-compose工具\"><a href=\"#使用docker-compose工具\" class=\"headerlink\" title=\"使用docker-compose工具\"></a>使用docker-compose工具</h2><p>使用<code>docker run</code>命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个<code>docker_compose.yaml</code>文件，然后通过<code>docker-compose up -d .</code>命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：</p>\n<pre><code class=\"shell\">version: &quot;3&quot;\nservices: \n    nginx: \n            # 指定镜像\n        image: nginx\n\n        # 指定容器名称\n        container_name: nginx_container\n\n        # 端口映射\n        ports: \n            - 8080:8080\n\n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n\n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n\n        # 启动后指定的命令\n        command: nginx -g &#39;daemon off;&#39;\n\n        privileged: true\n        restart: always\n\n    uwsgi:\n        container_name: uwsgi_container\n        ports: \n            - 8090:8090\n        volumes:\n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages\n        networks:\n            extnetwork: \n                ipv4_address: 192.168.0.3\n        privileged: true\n        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n        restart: always        \n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n\n\n</code></pre>\n<p>注意：Nginx容器的启动命令是<code>nginx -g &#39;daemon off;&#39;</code>，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上<code>daemon off</code>参数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Docker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.</p>","more":"<p>阅读前需要对一些基本技术有所了解，以下仅供参考：</p>\n<p>Docker:  <a href=\"https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a><br> <a href=\"https://zhuanlan.zhihu.com/p/23599229\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/23599229</a><br>Nginx、uWSGI：<a href=\"https://blog.csdn.net/weixin_40907382/article/details/80824167\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_40907382/article/details/80824167</a></p>\n<h2 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h2><pre><code class=\"shell\"># 查看centos系统版本，内核版本要求不低于3.10\nuname -r\n\n# 更新yum\nsudo yum -y update\n\n# 安装需要的软件包\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 设置yum源\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n# 查看仓库中所有docker版本\nyum list docker-ce --showduplicates | sort -r\n\n# 选择其中一个版本安装\nyum -y install docker-ce-18.06.3.ce\n\n# 启动Docker服务，并设置为开机启动\nsystemctl start docker\nsystemctl enable docker\n\n# 测试是否安装成功\ndocker version\n\n# 安装docker-compose工具（用于容器编排）\nsudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n</code></pre>\n<h2 id=\"镜像准备\"><a href=\"#镜像准备\" class=\"headerlink\" title=\"镜像准备\"></a>镜像准备</h2><p>Nginx：可直接从docker hub中拉取，执行<code>docker pull nginx</code><br>Python：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：<code>docker pull python:3.6.8</code></p>\n<p>接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用<code>docker commit</code>打包为镜像，但这样做有一些坏处：<br>在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用<code>docker commit</code>制作镜像，会导致镜像越来越臃肿；其次，由于使用<code>docker commit</code>制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。<br>因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：<a href=\"https://yeasy.gitbooks.io/docker_practice/content/image/build.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a>，一个简单的Dockerfile如下：</p>\n<pre><code class=\"shell\"># 基于python3.6.8镜像\nFROM python:3.6.8\n\n# 复制Django项目所需的依赖文件清单到容器中\nCOPY requirements.txt /\n\n# 安装依赖\nRUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt\n\n# 创建uwsgi软链接\nRUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre>\n<h2 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h2><p>镜像制作完成，就可以开始创建容器了，可以直接使用<code>docker run</code>命令来创建，也可以使用<code>docker-compose</code>工具，下面首先介绍<code>docker run</code>的方式：</p>\n<p>Nginx: </p>\n<pre><code class=\"shell\">docker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx</code></pre>\n<p>uWSGI：</p>\n<pre><code class=\"shell\">docker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</code></pre>\n<p>参数解释：<br><code>-it</code>：让Docker分配一个伪终端,并绑定到容器的标准输入上<br><code>--name</code>：指定容器的名称<br><code>--privileged</code>：让容器内的root用户拥有真正root权限<br><code>-p</code>：指定端口映射，将宿主机的端口映射到容器端口<br><code>-v</code>：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器<br>  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。<br><code>--net</code>：指定容器所在的网段（需要提前创建一个网段）<br><code>--ip</code>：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动<br><code>--restart</code>：在容器退出时总是重启容器，保证容器始终运行<br><code>-d</code>：让容器在后台运行</p>\n<h2 id=\"使用docker-compose工具\"><a href=\"#使用docker-compose工具\" class=\"headerlink\" title=\"使用docker-compose工具\"></a>使用docker-compose工具</h2><p>使用<code>docker run</code>命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个<code>docker_compose.yaml</code>文件，然后通过<code>docker-compose up -d .</code>命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：</p>\n<pre><code class=\"shell\">version: &quot;3&quot;\nservices: \n    nginx: \n            # 指定镜像\n        image: nginx\n\n        # 指定容器名称\n        container_name: nginx_container\n\n        # 端口映射\n        ports: \n            - 8080:8080\n\n        # 文件挂载路径\n        volumes: \n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /nginx.conf:/etc/nginx/nginx.conf\n\n        # 网络和ip\n        networks: \n            extnetwork: \n                ipv4_address: 192.168.0.2\n\n        # 启动后指定的命令\n        command: nginx -g &#39;daemon off;&#39;\n\n        privileged: true\n        restart: always\n\n    uwsgi:\n        container_name: uwsgi_container\n        ports: \n            - 8090:8090\n        volumes:\n            - /DJANGO_PROJECT:/DJANGO_PROJECT\n            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages\n        networks:\n            extnetwork: \n                ipv4_address: 192.168.0.3\n        privileged: true\n        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini\n        restart: always        \n\nnetworks: \n    extnetwork: \n        ipam: \n            config: \n            - subnet: 192.168.0.0/16\n\n\n</code></pre>\n<p>注意：Nginx容器的启动命令是<code>nginx -g &#39;daemon off;&#39;</code>，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上<code>daemon off</code>参数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。</p>"},{"title":"Git简介及常用操作","date":"2020-02-20T05:38:20.000Z","_content":"\nGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。\n\n<!--more-->\n\n## 1.Git基本概念\nGit是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。\n\n- 工作区 (Workspace)\n\n即我们进行代码/文件的增、删、改等操作的本机目录\n\n- 暂存区 (Index/Stage)\n\n用来暂存被改动文件的空间。在本地修改代码后，可以通过`git add`命令将变动保存到暂存区\n暂存区的作用：` commit`操作是原子性的，我们可以挑选自己想记录提交的内容形成一次`commit`\n     方便撤销修改`git checkout`\n     对比工作区和暂存区的文件差异`git diff`\n\n- 本地仓库 (Repository)\n\n即项目目录下的`.git`文件夹，保存了所有和该项目有关的历史记录，`commit`的结果被保存在本地仓库中\n`git init`命令可以初始化一个git本地仓库\n\n\n- 远程仓库 (Remote)\n\n用于项目协作的远程仓库，存放在远程主机上\n\n![1.jpg](/img/Git/1.jpg)\n\n\n## 2.常用操作\n\n- **git init**\n\n初始化一个git本地仓库，即生成`.git`文件夹\n\n- **git clone**\n\n从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。\n克隆时，所使用的远程主机自动被命名为`origin`,可以通过`-o`参数自定义命名，例如`git clone -o jQuery https://github.com/jquery/jquery.git`\n\n- **git add**\n\n在工作区修改完文件，可以通过`git add .`将所有改动提交到暂存区，也可以指定个别文件，如`git add a.txt`\n\n- **git commit**\n\n暂存区的文件需要经过`git commit -m 'commit info'`才会提交到本地仓库中，`commit`会生成一条版本记录\n\n- **git push**\n\n推送代码到远程仓库，例如`git push 远程主机名 本地分支名:远程分支名`\n如果当前分支与远程分支存在追踪关系，则可以写成`git push origin`\n如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写`git push`\n如果当前分支与多个远程主机存在追踪关系，则可使用`-u`参数指定默认主机，如`git push -u origin master`,之后`git push`便会默认推送到`origin`主机\n\n\n注意，`git push`有`matching`模式和`simple`模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用`matching`模式，之后默认`simple`模式。可以通过`git config`修改：`git config --global push.default simple`\n\n\n- **git pull**\n\n拉取远程主机的某个分支，并与本地分支合并，例如`git pull 远程主机名 远程分支名:本地分支名`\n如果需要拉取的远程分支是与当前分支合并，则可以写成`git pull origin master`,这一步相当于先执行`git fetch origin`,再执行`git merge origin/master`\n\n- **git status**\n\n查看文件状态\n\n\n- **git log**\n\n查看`commit`历史\n\n\n- **git branch**\n\n`git branch -a`查看本地与远程主机的所有分支\n`git branch branch_name` 新建一个名为branch_name的分支，但仍然停留在当前分支\n`git checkout -b branch_name` 新建一个名为branch_name的分支，并切换到该分支\n`git branch --set-upstream local_branch remote_branch` 将本地分支local_branch与远程分支remote_branch建立追踪关系\n`git branch -d branch_name` 删除本地分支\n`git push origin --delete remote_branch` 删除远程分支\n\n\n- **git checkout**\n\n拉取远程主机的分支后，可以在它的基础上新建分支，如`git checkout -b new_branch`\n使用`git checout branch_name`可以在本地将工作区切换到另一个分支\n也可用于切换到某次commit : `git checkout commit_id`\n\n- **git remote**\n\n为了便于管理，每个远程主机都必须指定一个主机名，`git remote -v`可以列出所有远程主机名及其地址\n`git remote add 主机名 项目地址` 用于添加远程主机\n`git remote rm 主机名` 用于删除远程主机\n`git remote rename 原主机名 新主机名` 可以重命名远程主机\n\n- **git reset**\n\n`git reset`可以重置当前分支到指定`commit`,有3种模式：`mixed`、`soft`、`hard`\n`git reset --mixed commit_id`：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n`git reset --soft commit_id`：重置当前分支的指针为指定commit，但保持暂存区和工作区不变\n`git reset --hard commit_id`：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)\n\n![2.png](/img/Git/2.png)\n\n- **git tag**\n\n在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.\n`git tag` 查看所有标签\n`git tag -a tag_name -m \"tag description\"` 给当前分支打上名称为tag_name的标签，描述为\"tag description\"\n`git push origin tag_name` 推送指定tag到远程\n`git push origin --tags` 推送所有tag到远程\n`git tag -d tag_name` 删除指定tag\n\n\n## 3.其他\n\n- **gitignore**\n\n有时项目中有些文件不需要放入远程仓库，可以创建一个`.gitignore`文件来配置推送时需要忽略的文件，例如：\n*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件\n.idea/        忽略.idea文件夹\n\n- **配置公钥**\n\n如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例\n-- 生成公钥\n`ssh-keygen -t rsa -C \"YOUR EMAIL\"`\n-- 查看公钥并复制\n`cat ~/.ssh/id_rsa.pub`\n-- 将公钥添加到Gitlab\nSettings >> SSH Keys\n\n![3.png](/img/Git/3.png)\n\n## 4.参考链接\nGit原理入门： [http://www.ruanyifeng.com/blog/2018/10/git-internals.html](http://www.ruanyifeng.com/blog/2018/10/git-internals.html)\nGit常用命令清单：[https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\nGit reset三种模式：[https://www.jianshu.com/p/c2ec5f06cf1a](https://www.jianshu.com/p/c2ec5f06cf1a)\n","source":"_posts/Git简介及常用操作.md","raw":"---\ntitle: Git简介及常用操作\ndate: 2020-02-20 13:38:20\ntags: [Git]\ncategories: Git\n---\n\nGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。\n\n<!--more-->\n\n## 1.Git基本概念\nGit是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。\n\n- 工作区 (Workspace)\n\n即我们进行代码/文件的增、删、改等操作的本机目录\n\n- 暂存区 (Index/Stage)\n\n用来暂存被改动文件的空间。在本地修改代码后，可以通过`git add`命令将变动保存到暂存区\n暂存区的作用：` commit`操作是原子性的，我们可以挑选自己想记录提交的内容形成一次`commit`\n     方便撤销修改`git checkout`\n     对比工作区和暂存区的文件差异`git diff`\n\n- 本地仓库 (Repository)\n\n即项目目录下的`.git`文件夹，保存了所有和该项目有关的历史记录，`commit`的结果被保存在本地仓库中\n`git init`命令可以初始化一个git本地仓库\n\n\n- 远程仓库 (Remote)\n\n用于项目协作的远程仓库，存放在远程主机上\n\n![1.jpg](/img/Git/1.jpg)\n\n\n## 2.常用操作\n\n- **git init**\n\n初始化一个git本地仓库，即生成`.git`文件夹\n\n- **git clone**\n\n从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。\n克隆时，所使用的远程主机自动被命名为`origin`,可以通过`-o`参数自定义命名，例如`git clone -o jQuery https://github.com/jquery/jquery.git`\n\n- **git add**\n\n在工作区修改完文件，可以通过`git add .`将所有改动提交到暂存区，也可以指定个别文件，如`git add a.txt`\n\n- **git commit**\n\n暂存区的文件需要经过`git commit -m 'commit info'`才会提交到本地仓库中，`commit`会生成一条版本记录\n\n- **git push**\n\n推送代码到远程仓库，例如`git push 远程主机名 本地分支名:远程分支名`\n如果当前分支与远程分支存在追踪关系，则可以写成`git push origin`\n如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写`git push`\n如果当前分支与多个远程主机存在追踪关系，则可使用`-u`参数指定默认主机，如`git push -u origin master`,之后`git push`便会默认推送到`origin`主机\n\n\n注意，`git push`有`matching`模式和`simple`模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用`matching`模式，之后默认`simple`模式。可以通过`git config`修改：`git config --global push.default simple`\n\n\n- **git pull**\n\n拉取远程主机的某个分支，并与本地分支合并，例如`git pull 远程主机名 远程分支名:本地分支名`\n如果需要拉取的远程分支是与当前分支合并，则可以写成`git pull origin master`,这一步相当于先执行`git fetch origin`,再执行`git merge origin/master`\n\n- **git status**\n\n查看文件状态\n\n\n- **git log**\n\n查看`commit`历史\n\n\n- **git branch**\n\n`git branch -a`查看本地与远程主机的所有分支\n`git branch branch_name` 新建一个名为branch_name的分支，但仍然停留在当前分支\n`git checkout -b branch_name` 新建一个名为branch_name的分支，并切换到该分支\n`git branch --set-upstream local_branch remote_branch` 将本地分支local_branch与远程分支remote_branch建立追踪关系\n`git branch -d branch_name` 删除本地分支\n`git push origin --delete remote_branch` 删除远程分支\n\n\n- **git checkout**\n\n拉取远程主机的分支后，可以在它的基础上新建分支，如`git checkout -b new_branch`\n使用`git checout branch_name`可以在本地将工作区切换到另一个分支\n也可用于切换到某次commit : `git checkout commit_id`\n\n- **git remote**\n\n为了便于管理，每个远程主机都必须指定一个主机名，`git remote -v`可以列出所有远程主机名及其地址\n`git remote add 主机名 项目地址` 用于添加远程主机\n`git remote rm 主机名` 用于删除远程主机\n`git remote rename 原主机名 新主机名` 可以重命名远程主机\n\n- **git reset**\n\n`git reset`可以重置当前分支到指定`commit`,有3种模式：`mixed`、`soft`、`hard`\n`git reset --mixed commit_id`：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n`git reset --soft commit_id`：重置当前分支的指针为指定commit，但保持暂存区和工作区不变\n`git reset --hard commit_id`：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)\n\n![2.png](/img/Git/2.png)\n\n- **git tag**\n\n在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.\n`git tag` 查看所有标签\n`git tag -a tag_name -m \"tag description\"` 给当前分支打上名称为tag_name的标签，描述为\"tag description\"\n`git push origin tag_name` 推送指定tag到远程\n`git push origin --tags` 推送所有tag到远程\n`git tag -d tag_name` 删除指定tag\n\n\n## 3.其他\n\n- **gitignore**\n\n有时项目中有些文件不需要放入远程仓库，可以创建一个`.gitignore`文件来配置推送时需要忽略的文件，例如：\n*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件\n.idea/        忽略.idea文件夹\n\n- **配置公钥**\n\n如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例\n-- 生成公钥\n`ssh-keygen -t rsa -C \"YOUR EMAIL\"`\n-- 查看公钥并复制\n`cat ~/.ssh/id_rsa.pub`\n-- 将公钥添加到Gitlab\nSettings >> SSH Keys\n\n![3.png](/img/Git/3.png)\n\n## 4.参考链接\nGit原理入门： [http://www.ruanyifeng.com/blog/2018/10/git-internals.html](http://www.ruanyifeng.com/blog/2018/10/git-internals.html)\nGit常用命令清单：[https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\nGit reset三种模式：[https://www.jianshu.com/p/c2ec5f06cf1a](https://www.jianshu.com/p/c2ec5f06cf1a)\n","slug":"Git简介及常用操作","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45uk0000dbouibvh00bmy","content":"<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-Git基本概念\"><a href=\"#1-Git基本概念\" class=\"headerlink\" title=\"1.Git基本概念\"></a>1.Git基本概念</h2><p>Git是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p>\n<ul>\n<li>工作区 (Workspace)</li>\n</ul>\n<p>即我们进行代码/文件的增、删、改等操作的本机目录</p>\n<ul>\n<li>暂存区 (Index/Stage)</li>\n</ul>\n<p>用来暂存被改动文件的空间。在本地修改代码后，可以通过<code>git add</code>命令将变动保存到暂存区<br>暂存区的作用：<code>commit</code>操作是原子性的，我们可以挑选自己想记录提交的内容形成一次<code>commit</code><br>     方便撤销修改<code>git checkout</code><br>     对比工作区和暂存区的文件差异<code>git diff</code></p>\n<ul>\n<li>本地仓库 (Repository)</li>\n</ul>\n<p>即项目目录下的<code>.git</code>文件夹，保存了所有和该项目有关的历史记录，<code>commit</code>的结果被保存在本地仓库中<br><code>git init</code>命令可以初始化一个git本地仓库</p>\n<ul>\n<li>远程仓库 (Remote)</li>\n</ul>\n<p>用于项目协作的远程仓库，存放在远程主机上</p>\n<p><img src=\"/img/Git/1.jpg\" srcset=\"/img/loading.gif\" alt=\"1.jpg\"></p>\n<h2 id=\"2-常用操作\"><a href=\"#2-常用操作\" class=\"headerlink\" title=\"2.常用操作\"></a>2.常用操作</h2><ul>\n<li><strong>git init</strong></li>\n</ul>\n<p>初始化一个git本地仓库，即生成<code>.git</code>文件夹</p>\n<ul>\n<li><strong>git clone</strong></li>\n</ul>\n<p>从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。<br>克隆时，所使用的远程主机自动被命名为<code>origin</code>,可以通过<code>-o</code>参数自定义命名，例如<code>git clone -o jQuery https://github.com/jquery/jquery.git</code></p>\n<ul>\n<li><strong>git add</strong></li>\n</ul>\n<p>在工作区修改完文件，可以通过<code>git add .</code>将所有改动提交到暂存区，也可以指定个别文件，如<code>git add a.txt</code></p>\n<ul>\n<li><strong>git commit</strong></li>\n</ul>\n<p>暂存区的文件需要经过<code>git commit -m &#39;commit info&#39;</code>才会提交到本地仓库中，<code>commit</code>会生成一条版本记录</p>\n<ul>\n<li><strong>git push</strong></li>\n</ul>\n<p>推送代码到远程仓库，例如<code>git push 远程主机名 本地分支名:远程分支名</code><br>如果当前分支与远程分支存在追踪关系，则可以写成<code>git push origin</code><br>如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写<code>git push</code><br>如果当前分支与多个远程主机存在追踪关系，则可使用<code>-u</code>参数指定默认主机，如<code>git push -u origin master</code>,之后<code>git push</code>便会默认推送到<code>origin</code>主机</p>\n<p>注意，<code>git push</code>有<code>matching</code>模式和<code>simple</code>模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用<code>matching</code>模式，之后默认<code>simple</code>模式。可以通过<code>git config</code>修改：<code>git config --global push.default simple</code></p>\n<ul>\n<li><strong>git pull</strong></li>\n</ul>\n<p>拉取远程主机的某个分支，并与本地分支合并，例如<code>git pull 远程主机名 远程分支名:本地分支名</code><br>如果需要拉取的远程分支是与当前分支合并，则可以写成<code>git pull origin master</code>,这一步相当于先执行<code>git fetch origin</code>,再执行<code>git merge origin/master</code></p>\n<ul>\n<li><strong>git status</strong></li>\n</ul>\n<p>查看文件状态</p>\n<ul>\n<li><strong>git log</strong></li>\n</ul>\n<p>查看<code>commit</code>历史</p>\n<ul>\n<li><strong>git branch</strong></li>\n</ul>\n<p><code>git branch -a</code>查看本地与远程主机的所有分支<br><code>git branch branch_name</code> 新建一个名为branch_name的分支，但仍然停留在当前分支<br><code>git checkout -b branch_name</code> 新建一个名为branch_name的分支，并切换到该分支<br><code>git branch --set-upstream local_branch remote_branch</code> 将本地分支local_branch与远程分支remote_branch建立追踪关系<br><code>git branch -d branch_name</code> 删除本地分支<br><code>git push origin --delete remote_branch</code> 删除远程分支</p>\n<ul>\n<li><strong>git checkout</strong></li>\n</ul>\n<p>拉取远程主机的分支后，可以在它的基础上新建分支，如<code>git checkout -b new_branch</code><br>使用<code>git checout branch_name</code>可以在本地将工作区切换到另一个分支<br>也可用于切换到某次commit : <code>git checkout commit_id</code></p>\n<ul>\n<li><strong>git remote</strong></li>\n</ul>\n<p>为了便于管理，每个远程主机都必须指定一个主机名，<code>git remote -v</code>可以列出所有远程主机名及其地址<br><code>git remote add 主机名 项目地址</code> 用于添加远程主机<br><code>git remote rm 主机名</code> 用于删除远程主机<br><code>git remote rename 原主机名 新主机名</code> 可以重命名远程主机</p>\n<ul>\n<li><strong>git reset</strong></li>\n</ul>\n<p><code>git reset</code>可以重置当前分支到指定<code>commit</code>,有3种模式：<code>mixed</code>、<code>soft</code>、<code>hard</code><br><code>git reset --mixed commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset --soft commit_id</code>：重置当前分支的指针为指定commit，但保持暂存区和工作区不变<br><code>git reset --hard commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)</p>\n<p><img src=\"/img/Git/2.png\" srcset=\"/img/loading.gif\" alt=\"2.png\"></p>\n<ul>\n<li><strong>git tag</strong></li>\n</ul>\n<p>在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.<br><code>git tag</code> 查看所有标签<br><code>git tag -a tag_name -m &quot;tag description&quot;</code> 给当前分支打上名称为tag_name的标签，描述为”tag description”<br><code>git push origin tag_name</code> 推送指定tag到远程<br><code>git push origin --tags</code> 推送所有tag到远程<br><code>git tag -d tag_name</code> 删除指定tag</p>\n<h2 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3.其他\"></a>3.其他</h2><ul>\n<li><strong>gitignore</strong></li>\n</ul>\n<p>有时项目中有些文件不需要放入远程仓库，可以创建一个<code>.gitignore</code>文件来配置推送时需要忽略的文件，例如：<br>*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件<br>.idea/        忽略.idea文件夹</p>\n<ul>\n<li><strong>配置公钥</strong></li>\n</ul>\n<p>如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例<br>– 生成公钥<br><code>ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</code><br>– 查看公钥并复制<br><code>cat ~/.ssh/id_rsa.pub</code><br>– 将公钥添加到Gitlab<br>Settings &gt;&gt; SSH Keys</p>\n<p><img src=\"/img/Git/3.png\" srcset=\"/img/loading.gif\" alt=\"3.png\"></p>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4.参考链接\"></a>4.参考链接</h2><p>Git原理入门： <a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a><br>Git常用命令清单：<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>Git reset三种模式：<a href=\"https://www.jianshu.com/p/c2ec5f06cf1a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c2ec5f06cf1a</a></p>\n","site":{"data":{}},"excerpt":"<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。</p>","more":"<h2 id=\"1-Git基本概念\"><a href=\"#1-Git基本概念\" class=\"headerlink\" title=\"1.Git基本概念\"></a>1.Git基本概念</h2><p>Git是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p>\n<ul>\n<li>工作区 (Workspace)</li>\n</ul>\n<p>即我们进行代码/文件的增、删、改等操作的本机目录</p>\n<ul>\n<li>暂存区 (Index/Stage)</li>\n</ul>\n<p>用来暂存被改动文件的空间。在本地修改代码后，可以通过<code>git add</code>命令将变动保存到暂存区<br>暂存区的作用：<code>commit</code>操作是原子性的，我们可以挑选自己想记录提交的内容形成一次<code>commit</code><br>     方便撤销修改<code>git checkout</code><br>     对比工作区和暂存区的文件差异<code>git diff</code></p>\n<ul>\n<li>本地仓库 (Repository)</li>\n</ul>\n<p>即项目目录下的<code>.git</code>文件夹，保存了所有和该项目有关的历史记录，<code>commit</code>的结果被保存在本地仓库中<br><code>git init</code>命令可以初始化一个git本地仓库</p>\n<ul>\n<li>远程仓库 (Remote)</li>\n</ul>\n<p>用于项目协作的远程仓库，存放在远程主机上</p>\n<p><img src=\"/img/Git/1.jpg\" srcset=\"/img/loading.gif\" alt=\"1.jpg\"></p>\n<h2 id=\"2-常用操作\"><a href=\"#2-常用操作\" class=\"headerlink\" title=\"2.常用操作\"></a>2.常用操作</h2><ul>\n<li><strong>git init</strong></li>\n</ul>\n<p>初始化一个git本地仓库，即生成<code>.git</code>文件夹</p>\n<ul>\n<li><strong>git clone</strong></li>\n</ul>\n<p>从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。<br>克隆时，所使用的远程主机自动被命名为<code>origin</code>,可以通过<code>-o</code>参数自定义命名，例如<code>git clone -o jQuery https://github.com/jquery/jquery.git</code></p>\n<ul>\n<li><strong>git add</strong></li>\n</ul>\n<p>在工作区修改完文件，可以通过<code>git add .</code>将所有改动提交到暂存区，也可以指定个别文件，如<code>git add a.txt</code></p>\n<ul>\n<li><strong>git commit</strong></li>\n</ul>\n<p>暂存区的文件需要经过<code>git commit -m &#39;commit info&#39;</code>才会提交到本地仓库中，<code>commit</code>会生成一条版本记录</p>\n<ul>\n<li><strong>git push</strong></li>\n</ul>\n<p>推送代码到远程仓库，例如<code>git push 远程主机名 本地分支名:远程分支名</code><br>如果当前分支与远程分支存在追踪关系，则可以写成<code>git push origin</code><br>如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写<code>git push</code><br>如果当前分支与多个远程主机存在追踪关系，则可使用<code>-u</code>参数指定默认主机，如<code>git push -u origin master</code>,之后<code>git push</code>便会默认推送到<code>origin</code>主机</p>\n<p>注意，<code>git push</code>有<code>matching</code>模式和<code>simple</code>模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用<code>matching</code>模式，之后默认<code>simple</code>模式。可以通过<code>git config</code>修改：<code>git config --global push.default simple</code></p>\n<ul>\n<li><strong>git pull</strong></li>\n</ul>\n<p>拉取远程主机的某个分支，并与本地分支合并，例如<code>git pull 远程主机名 远程分支名:本地分支名</code><br>如果需要拉取的远程分支是与当前分支合并，则可以写成<code>git pull origin master</code>,这一步相当于先执行<code>git fetch origin</code>,再执行<code>git merge origin/master</code></p>\n<ul>\n<li><strong>git status</strong></li>\n</ul>\n<p>查看文件状态</p>\n<ul>\n<li><strong>git log</strong></li>\n</ul>\n<p>查看<code>commit</code>历史</p>\n<ul>\n<li><strong>git branch</strong></li>\n</ul>\n<p><code>git branch -a</code>查看本地与远程主机的所有分支<br><code>git branch branch_name</code> 新建一个名为branch_name的分支，但仍然停留在当前分支<br><code>git checkout -b branch_name</code> 新建一个名为branch_name的分支，并切换到该分支<br><code>git branch --set-upstream local_branch remote_branch</code> 将本地分支local_branch与远程分支remote_branch建立追踪关系<br><code>git branch -d branch_name</code> 删除本地分支<br><code>git push origin --delete remote_branch</code> 删除远程分支</p>\n<ul>\n<li><strong>git checkout</strong></li>\n</ul>\n<p>拉取远程主机的分支后，可以在它的基础上新建分支，如<code>git checkout -b new_branch</code><br>使用<code>git checout branch_name</code>可以在本地将工作区切换到另一个分支<br>也可用于切换到某次commit : <code>git checkout commit_id</code></p>\n<ul>\n<li><strong>git remote</strong></li>\n</ul>\n<p>为了便于管理，每个远程主机都必须指定一个主机名，<code>git remote -v</code>可以列出所有远程主机名及其地址<br><code>git remote add 主机名 项目地址</code> 用于添加远程主机<br><code>git remote rm 主机名</code> 用于删除远程主机<br><code>git remote rename 原主机名 新主机名</code> 可以重命名远程主机</p>\n<ul>\n<li><strong>git reset</strong></li>\n</ul>\n<p><code>git reset</code>可以重置当前分支到指定<code>commit</code>,有3种模式：<code>mixed</code>、<code>soft</code>、<code>hard</code><br><code>git reset --mixed commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset --soft commit_id</code>：重置当前分支的指针为指定commit，但保持暂存区和工作区不变<br><code>git reset --hard commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)</p>\n<p><img src=\"/img/Git/2.png\" srcset=\"/img/loading.gif\" alt=\"2.png\"></p>\n<ul>\n<li><strong>git tag</strong></li>\n</ul>\n<p>在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.<br><code>git tag</code> 查看所有标签<br><code>git tag -a tag_name -m &quot;tag description&quot;</code> 给当前分支打上名称为tag_name的标签，描述为”tag description”<br><code>git push origin tag_name</code> 推送指定tag到远程<br><code>git push origin --tags</code> 推送所有tag到远程<br><code>git tag -d tag_name</code> 删除指定tag</p>\n<h2 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3.其他\"></a>3.其他</h2><ul>\n<li><strong>gitignore</strong></li>\n</ul>\n<p>有时项目中有些文件不需要放入远程仓库，可以创建一个<code>.gitignore</code>文件来配置推送时需要忽略的文件，例如：<br>*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件<br>.idea/        忽略.idea文件夹</p>\n<ul>\n<li><strong>配置公钥</strong></li>\n</ul>\n<p>如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例<br>– 生成公钥<br><code>ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</code><br>– 查看公钥并复制<br><code>cat ~/.ssh/id_rsa.pub</code><br>– 将公钥添加到Gitlab<br>Settings &gt;&gt; SSH Keys</p>\n<p><img src=\"/img/Git/3.png\" srcset=\"/img/loading.gif\" alt=\"3.png\"></p>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4.参考链接\"></a>4.参考链接</h2><p>Git原理入门： <a href=\"http://www.ruanyifeng.com/blog/2018/10/git-internals.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a><br>Git常用命令清单：<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>Git reset三种模式：<a href=\"https://www.jianshu.com/p/c2ec5f06cf1a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c2ec5f06cf1a</a></p>"},{"title":"Orthanc + OHIF 搭建DICOM web viewer","date":"2019-12-08T14:38:01.000Z","_content":"\n常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server `Orhtanc`以及DICOM web viewer `OHIF viewer`搭建一套DICOM阅片系统。\n\n<!--more-->\n\n## Orthanc\nOrthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。\n\n关于Orthanc的使用可以参考其官方文档：\n[https://book.orthanc-server.com/index.html](https://book.orthanc-server.com/index.html)\n\nOrthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：\n\n- 查看镜像\n\n`docker search orthanc`\n\n![lgt2jJ.png](https://s2.ax1x.com/2020/01/08/lgt2jJ.png)\n- 拉取镜像(注意，只有orthanc-plugins才提供REST API)\n\n`docker pull jodogne/orthanc-plugins`\n\n- 启动容器\n\n`mkdir /tmp/orthanc-db` (创建文件夹用于存放orthanc数据,即DICOM数据)\n`sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins`\n\n- 网页查看\n\n`http://orthanc所在的服务器ip:8042`\n默认账号：  orthanc\n默认密码：  orthanc\n可以通过Upload按钮进行文件上传页面，上传DICOM影像\n\n至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：[https://book.orthanc-server.com/users/rest.html](https://book.orthanc-server.com/users/rest.html)\n\n在前面创建容器时挂载的目录`/var/lib/orthanc/db`即orthanc中DICOM文件存放的路径，对应宿主机即`/tmp/orthanc-db/`.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下\n![lgafBj.png](https://s2.ax1x.com/2020/01/08/lgafBj.png)\n\n## OHIF Viewer\nOHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：[https://github.com/OHIF/Viewers](https://github.com/OHIF/Viewers)\n\n启动项目非常简单，只需要clone下来然后在项目根目录执行`yarn install`、`yarn run dev`即可（官方文档[https://docs.ohif.org/](https://docs.ohif.org/)），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。\n打开`platform/viewer/package.json`修改proxy的值为之前启动的Orthanc服务地址，例如`\"proxy\": \"http://192.168.0.23:8042\"`，然后执行`yarn run dev:orthanc`即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。\n","source":"_posts/Orthanc + OHIF 搭建DICOM web viewer.md","raw":"---\ntitle: Orthanc + OHIF 搭建DICOM web viewer\ndate: 2019-12-08 22:38:01\ntags: [Orthanc,OHIF,DICOM]\ncategories: DICOM\n---\n\n常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server `Orhtanc`以及DICOM web viewer `OHIF viewer`搭建一套DICOM阅片系统。\n\n<!--more-->\n\n## Orthanc\nOrthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。\n\n关于Orthanc的使用可以参考其官方文档：\n[https://book.orthanc-server.com/index.html](https://book.orthanc-server.com/index.html)\n\nOrthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：\n\n- 查看镜像\n\n`docker search orthanc`\n\n![lgt2jJ.png](https://s2.ax1x.com/2020/01/08/lgt2jJ.png)\n- 拉取镜像(注意，只有orthanc-plugins才提供REST API)\n\n`docker pull jodogne/orthanc-plugins`\n\n- 启动容器\n\n`mkdir /tmp/orthanc-db` (创建文件夹用于存放orthanc数据,即DICOM数据)\n`sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins`\n\n- 网页查看\n\n`http://orthanc所在的服务器ip:8042`\n默认账号：  orthanc\n默认密码：  orthanc\n可以通过Upload按钮进行文件上传页面，上传DICOM影像\n\n至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：[https://book.orthanc-server.com/users/rest.html](https://book.orthanc-server.com/users/rest.html)\n\n在前面创建容器时挂载的目录`/var/lib/orthanc/db`即orthanc中DICOM文件存放的路径，对应宿主机即`/tmp/orthanc-db/`.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下\n![lgafBj.png](https://s2.ax1x.com/2020/01/08/lgafBj.png)\n\n## OHIF Viewer\nOHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：[https://github.com/OHIF/Viewers](https://github.com/OHIF/Viewers)\n\n启动项目非常简单，只需要clone下来然后在项目根目录执行`yarn install`、`yarn run dev`即可（官方文档[https://docs.ohif.org/](https://docs.ohif.org/)），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。\n打开`platform/viewer/package.json`修改proxy的值为之前启动的Orthanc服务地址，例如`\"proxy\": \"http://192.168.0.23:8042\"`，然后执行`yarn run dev:orthanc`即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。\n","slug":"Orthanc + OHIF 搭建DICOM web viewer","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45uk2000eboui00zb6zly","content":"<p>常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server <code>Orhtanc</code>以及DICOM web viewer <code>OHIF viewer</code>搭建一套DICOM阅片系统。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Orthanc\"><a href=\"#Orthanc\" class=\"headerlink\" title=\"Orthanc\"></a>Orthanc</h2><p>Orthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。</p>\n<p>关于Orthanc的使用可以参考其官方文档：<br><a href=\"https://book.orthanc-server.com/index.html\" target=\"_blank\" rel=\"noopener\">https://book.orthanc-server.com/index.html</a></p>\n<p>Orthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：</p>\n<ul>\n<li>查看镜像</li>\n</ul>\n<p><code>docker search orthanc</code></p>\n<p><img src=\"https://s2.ax1x.com/2020/01/08/lgt2jJ.png\" srcset=\"/img/loading.gif\" alt=\"lgt2jJ.png\"></p>\n<ul>\n<li>拉取镜像(注意，只有orthanc-plugins才提供REST API)</li>\n</ul>\n<p><code>docker pull jodogne/orthanc-plugins</code></p>\n<ul>\n<li>启动容器</li>\n</ul>\n<p><code>mkdir /tmp/orthanc-db</code> (创建文件夹用于存放orthanc数据,即DICOM数据)<br><code>sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins</code></p>\n<ul>\n<li>网页查看</li>\n</ul>\n<p><code>http://orthanc所在的服务器ip:8042</code><br>默认账号：  orthanc<br>默认密码：  orthanc<br>可以通过Upload按钮进行文件上传页面，上传DICOM影像</p>\n<p>至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：<a href=\"https://book.orthanc-server.com/users/rest.html\" target=\"_blank\" rel=\"noopener\">https://book.orthanc-server.com/users/rest.html</a></p>\n<p>在前面创建容器时挂载的目录<code>/var/lib/orthanc/db</code>即orthanc中DICOM文件存放的路径，对应宿主机即<code>/tmp/orthanc-db/</code>.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下<br><img src=\"https://s2.ax1x.com/2020/01/08/lgafBj.png\" srcset=\"/img/loading.gif\" alt=\"lgafBj.png\"></p>\n<h2 id=\"OHIF-Viewer\"><a href=\"#OHIF-Viewer\" class=\"headerlink\" title=\"OHIF Viewer\"></a>OHIF Viewer</h2><p>OHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：<a href=\"https://github.com/OHIF/Viewers\" target=\"_blank\" rel=\"noopener\">https://github.com/OHIF/Viewers</a></p>\n<p>启动项目非常简单，只需要clone下来然后在项目根目录执行<code>yarn install</code>、<code>yarn run dev</code>即可（官方文档<a href=\"https://docs.ohif.org/\" target=\"_blank\" rel=\"noopener\">https://docs.ohif.org/</a>），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。<br>打开<code>platform/viewer/package.json</code>修改proxy的值为之前启动的Orthanc服务地址，例如<code>&quot;proxy&quot;: &quot;http://192.168.0.23:8042&quot;</code>，然后执行<code>yarn run dev:orthanc</code>即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。</p>\n","site":{"data":{}},"excerpt":"<p>常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server <code>Orhtanc</code>以及DICOM web viewer <code>OHIF viewer</code>搭建一套DICOM阅片系统。</p>","more":"<h2 id=\"Orthanc\"><a href=\"#Orthanc\" class=\"headerlink\" title=\"Orthanc\"></a>Orthanc</h2><p>Orthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。</p>\n<p>关于Orthanc的使用可以参考其官方文档：<br><a href=\"https://book.orthanc-server.com/index.html\" target=\"_blank\" rel=\"noopener\">https://book.orthanc-server.com/index.html</a></p>\n<p>Orthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：</p>\n<ul>\n<li>查看镜像</li>\n</ul>\n<p><code>docker search orthanc</code></p>\n<p><img src=\"https://s2.ax1x.com/2020/01/08/lgt2jJ.png\" srcset=\"/img/loading.gif\" alt=\"lgt2jJ.png\"></p>\n<ul>\n<li>拉取镜像(注意，只有orthanc-plugins才提供REST API)</li>\n</ul>\n<p><code>docker pull jodogne/orthanc-plugins</code></p>\n<ul>\n<li>启动容器</li>\n</ul>\n<p><code>mkdir /tmp/orthanc-db</code> (创建文件夹用于存放orthanc数据,即DICOM数据)<br><code>sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins</code></p>\n<ul>\n<li>网页查看</li>\n</ul>\n<p><code>http://orthanc所在的服务器ip:8042</code><br>默认账号：  orthanc<br>默认密码：  orthanc<br>可以通过Upload按钮进行文件上传页面，上传DICOM影像</p>\n<p>至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：<a href=\"https://book.orthanc-server.com/users/rest.html\" target=\"_blank\" rel=\"noopener\">https://book.orthanc-server.com/users/rest.html</a></p>\n<p>在前面创建容器时挂载的目录<code>/var/lib/orthanc/db</code>即orthanc中DICOM文件存放的路径，对应宿主机即<code>/tmp/orthanc-db/</code>.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下<br><img src=\"https://s2.ax1x.com/2020/01/08/lgafBj.png\" srcset=\"/img/loading.gif\" alt=\"lgafBj.png\"></p>\n<h2 id=\"OHIF-Viewer\"><a href=\"#OHIF-Viewer\" class=\"headerlink\" title=\"OHIF Viewer\"></a>OHIF Viewer</h2><p>OHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：<a href=\"https://github.com/OHIF/Viewers\" target=\"_blank\" rel=\"noopener\">https://github.com/OHIF/Viewers</a></p>\n<p>启动项目非常简单，只需要clone下来然后在项目根目录执行<code>yarn install</code>、<code>yarn run dev</code>即可（官方文档<a href=\"https://docs.ohif.org/\" target=\"_blank\" rel=\"noopener\">https://docs.ohif.org/</a>），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。<br>打开<code>platform/viewer/package.json</code>修改proxy的值为之前启动的Orthanc服务地址，例如<code>&quot;proxy&quot;: &quot;http://192.168.0.23:8042&quot;</code>，然后执行<code>yarn run dev:orthanc</code>即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。</p>"},{"title":"使用SimpleITK读取DICOM","date":"2019-06-08T11:38:01.000Z","_content":"\nSimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。\n\n<!--more-->\n\n## 安装\n`pip install SimpleITK`\n\n## 读取DICOM影像\n\n- 读取单张DICOM影像\n\n```python\nimport SimpleITK as sitk\n\nfile = sitk.ReadImage(filepath)\n \n # 图像大小\nfile.GetSize()\n# 坐标原点\nfile.GetOrigin()\n# 像素间距\nfile.GetSpacing()\n# 方向\nfile.GetDirection()\n\n# 获取影像元数据(返回DICOM tags元组)\nfile.GetMetaDataKeys()\n\n# 像素矩阵\npixel_array = sitk.GetArrayFromImage(file)\n```\n\n- 读取DICOM序列\n\n```python\nimport os\nimport SimpleITK as sitk\n\npath = \"/dicom_study_dir\"\n\nreader = sitk.ImageSeriesReader()\nseriesIDs = reader.GetGDCMSeriesIDs(path)\ndicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])\nreader.SetFileNames(dicom_names)\nimage = reader.Execute()\n\n```\n\n## 读取特定序列并保存为NIfTI格式\n医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：\n```python\nimport logging\nimport os\nimport SimpleITK as sitk\n\n# 从DICOM影像中读取Tag信息\ndef get_tag(dcm, key, default_value=''):\n    try:\n        value = dcm.GetMetaData(key).strip()\n    except Exception as e:\n        logging.error(e)\n        value = default_value\n\n    return value\n\n# 从DICOM study文件夹中提取需要的序列并转换\ndef extract_series(study_dir, series_desc):\n    # 获取所有series id,返回一个元组\n    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)\n    for series_id in series_ids:\n        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组\n        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)\n        reader = sitk.ImageSeriesReader()\n        reader.SetFileNames(files)\n        try:\n            img = reader.Execute()\n        except RuntimeError as e:\n            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常\n            if 'The file in the series have unsupported 3 dimensions' in str(e):\n                img = sitk.ReadImage(files[0])\n            else:\n                logging.error('Error in reading image, dir %s, series id %s, detail message: %s' % (study_dir, series_id, e))\n                continue\n\t\t# 从当前序列取一张影像，便于读取其Tag信息                \n        dcm = sitk.ReadImage(files[0])\n        # 获取当前序列的序列描述\n        series_description = get_tag(dcm, '0008|103e')\n        # 判断是否是需要的序列\n        if series_description == series_desc:\n            nii_name = str(series_id) + \"nii.gz\"\n            # 写入nii.gz文件\n            sitk.WriteImage(img, os.path.join(study_dir, nii_name))\n        else:\n            continue\n\n```\n\n","source":"_posts/使用SimpleITK读取DICOM.md","raw":"---\ntitle: 使用SimpleITK读取DICOM\ndate: 2019-06-08 19:38:01\ntags: [SimpleITK,DICOM,Python]\ncategories: DICOM\n---\n\nSimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。\n\n<!--more-->\n\n## 安装\n`pip install SimpleITK`\n\n## 读取DICOM影像\n\n- 读取单张DICOM影像\n\n```python\nimport SimpleITK as sitk\n\nfile = sitk.ReadImage(filepath)\n \n # 图像大小\nfile.GetSize()\n# 坐标原点\nfile.GetOrigin()\n# 像素间距\nfile.GetSpacing()\n# 方向\nfile.GetDirection()\n\n# 获取影像元数据(返回DICOM tags元组)\nfile.GetMetaDataKeys()\n\n# 像素矩阵\npixel_array = sitk.GetArrayFromImage(file)\n```\n\n- 读取DICOM序列\n\n```python\nimport os\nimport SimpleITK as sitk\n\npath = \"/dicom_study_dir\"\n\nreader = sitk.ImageSeriesReader()\nseriesIDs = reader.GetGDCMSeriesIDs(path)\ndicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])\nreader.SetFileNames(dicom_names)\nimage = reader.Execute()\n\n```\n\n## 读取特定序列并保存为NIfTI格式\n医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：\n```python\nimport logging\nimport os\nimport SimpleITK as sitk\n\n# 从DICOM影像中读取Tag信息\ndef get_tag(dcm, key, default_value=''):\n    try:\n        value = dcm.GetMetaData(key).strip()\n    except Exception as e:\n        logging.error(e)\n        value = default_value\n\n    return value\n\n# 从DICOM study文件夹中提取需要的序列并转换\ndef extract_series(study_dir, series_desc):\n    # 获取所有series id,返回一个元组\n    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)\n    for series_id in series_ids:\n        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组\n        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)\n        reader = sitk.ImageSeriesReader()\n        reader.SetFileNames(files)\n        try:\n            img = reader.Execute()\n        except RuntimeError as e:\n            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常\n            if 'The file in the series have unsupported 3 dimensions' in str(e):\n                img = sitk.ReadImage(files[0])\n            else:\n                logging.error('Error in reading image, dir %s, series id %s, detail message: %s' % (study_dir, series_id, e))\n                continue\n\t\t# 从当前序列取一张影像，便于读取其Tag信息                \n        dcm = sitk.ReadImage(files[0])\n        # 获取当前序列的序列描述\n        series_description = get_tag(dcm, '0008|103e')\n        # 判断是否是需要的序列\n        if series_description == series_desc:\n            nii_name = str(series_id) + \"nii.gz\"\n            # 写入nii.gz文件\n            sitk.WriteImage(img, os.path.join(study_dir, nii_name))\n        else:\n            continue\n\n```\n\n","slug":"使用SimpleITK读取DICOM","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45uk6000ibouib82n67we","content":"<p>SimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>pip install SimpleITK</code></p>\n<h2 id=\"读取DICOM影像\"><a href=\"#读取DICOM影像\" class=\"headerlink\" title=\"读取DICOM影像\"></a>读取DICOM影像</h2><ul>\n<li>读取单张DICOM影像</li>\n</ul>\n<pre><code class=\"python\">import SimpleITK as sitk\n\nfile = sitk.ReadImage(filepath)\n\n # 图像大小\nfile.GetSize()\n# 坐标原点\nfile.GetOrigin()\n# 像素间距\nfile.GetSpacing()\n# 方向\nfile.GetDirection()\n\n# 获取影像元数据(返回DICOM tags元组)\nfile.GetMetaDataKeys()\n\n# 像素矩阵\npixel_array = sitk.GetArrayFromImage(file)</code></pre>\n<ul>\n<li>读取DICOM序列</li>\n</ul>\n<pre><code class=\"python\">import os\nimport SimpleITK as sitk\n\npath = &quot;/dicom_study_dir&quot;\n\nreader = sitk.ImageSeriesReader()\nseriesIDs = reader.GetGDCMSeriesIDs(path)\ndicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])\nreader.SetFileNames(dicom_names)\nimage = reader.Execute()\n</code></pre>\n<h2 id=\"读取特定序列并保存为NIfTI格式\"><a href=\"#读取特定序列并保存为NIfTI格式\" class=\"headerlink\" title=\"读取特定序列并保存为NIfTI格式\"></a>读取特定序列并保存为NIfTI格式</h2><p>医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：</p>\n<pre><code class=\"python\">import logging\nimport os\nimport SimpleITK as sitk\n\n# 从DICOM影像中读取Tag信息\ndef get_tag(dcm, key, default_value=&#39;&#39;):\n    try:\n        value = dcm.GetMetaData(key).strip()\n    except Exception as e:\n        logging.error(e)\n        value = default_value\n\n    return value\n\n# 从DICOM study文件夹中提取需要的序列并转换\ndef extract_series(study_dir, series_desc):\n    # 获取所有series id,返回一个元组\n    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)\n    for series_id in series_ids:\n        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组\n        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)\n        reader = sitk.ImageSeriesReader()\n        reader.SetFileNames(files)\n        try:\n            img = reader.Execute()\n        except RuntimeError as e:\n            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常\n            if &#39;The file in the series have unsupported 3 dimensions&#39; in str(e):\n                img = sitk.ReadImage(files[0])\n            else:\n                logging.error(&#39;Error in reading image, dir %s, series id %s, detail message: %s&#39; % (study_dir, series_id, e))\n                continue\n        # 从当前序列取一张影像，便于读取其Tag信息                \n        dcm = sitk.ReadImage(files[0])\n        # 获取当前序列的序列描述\n        series_description = get_tag(dcm, &#39;0008|103e&#39;)\n        # 判断是否是需要的序列\n        if series_description == series_desc:\n            nii_name = str(series_id) + &quot;nii.gz&quot;\n            # 写入nii.gz文件\n            sitk.WriteImage(img, os.path.join(study_dir, nii_name))\n        else:\n            continue\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>SimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。</p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>pip install SimpleITK</code></p>\n<h2 id=\"读取DICOM影像\"><a href=\"#读取DICOM影像\" class=\"headerlink\" title=\"读取DICOM影像\"></a>读取DICOM影像</h2><ul>\n<li>读取单张DICOM影像</li>\n</ul>\n<pre><code class=\"python\">import SimpleITK as sitk\n\nfile = sitk.ReadImage(filepath)\n\n # 图像大小\nfile.GetSize()\n# 坐标原点\nfile.GetOrigin()\n# 像素间距\nfile.GetSpacing()\n# 方向\nfile.GetDirection()\n\n# 获取影像元数据(返回DICOM tags元组)\nfile.GetMetaDataKeys()\n\n# 像素矩阵\npixel_array = sitk.GetArrayFromImage(file)</code></pre>\n<ul>\n<li>读取DICOM序列</li>\n</ul>\n<pre><code class=\"python\">import os\nimport SimpleITK as sitk\n\npath = &quot;/dicom_study_dir&quot;\n\nreader = sitk.ImageSeriesReader()\nseriesIDs = reader.GetGDCMSeriesIDs(path)\ndicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])\nreader.SetFileNames(dicom_names)\nimage = reader.Execute()\n</code></pre>\n<h2 id=\"读取特定序列并保存为NIfTI格式\"><a href=\"#读取特定序列并保存为NIfTI格式\" class=\"headerlink\" title=\"读取特定序列并保存为NIfTI格式\"></a>读取特定序列并保存为NIfTI格式</h2><p>医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：</p>\n<pre><code class=\"python\">import logging\nimport os\nimport SimpleITK as sitk\n\n# 从DICOM影像中读取Tag信息\ndef get_tag(dcm, key, default_value=&#39;&#39;):\n    try:\n        value = dcm.GetMetaData(key).strip()\n    except Exception as e:\n        logging.error(e)\n        value = default_value\n\n    return value\n\n# 从DICOM study文件夹中提取需要的序列并转换\ndef extract_series(study_dir, series_desc):\n    # 获取所有series id,返回一个元组\n    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)\n    for series_id in series_ids:\n        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组\n        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)\n        reader = sitk.ImageSeriesReader()\n        reader.SetFileNames(files)\n        try:\n            img = reader.Execute()\n        except RuntimeError as e:\n            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常\n            if &#39;The file in the series have unsupported 3 dimensions&#39; in str(e):\n                img = sitk.ReadImage(files[0])\n            else:\n                logging.error(&#39;Error in reading image, dir %s, series id %s, detail message: %s&#39; % (study_dir, series_id, e))\n                continue\n        # 从当前序列取一张影像，便于读取其Tag信息                \n        dcm = sitk.ReadImage(files[0])\n        # 获取当前序列的序列描述\n        series_description = get_tag(dcm, &#39;0008|103e&#39;)\n        # 判断是否是需要的序列\n        if series_description == series_desc:\n            nii_name = str(series_id) + &quot;nii.gz&quot;\n            # 写入nii.gz文件\n            sitk.WriteImage(img, os.path.join(study_dir, nii_name))\n        else:\n            continue\n</code></pre>"},{"title":"使用python将PDF转换为DICOM格式","date":"2019-06-25T02:38:01.000Z","_content":"\n由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。\n\n<!--more-->\n\n## 思路\nDICOM影像通常分为三个层级：`Study`、`Series`、`Instance`，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。\n\nDICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分`Pixel Data`字段中。\n\n为了将PDF报告转换成DICOM格式，可以先利用`pdf2image`将PDF转换为常见的图片格式，再将图片转换为`bytes`类型数据，写入DICOM tag中的`Pixel Data`字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。\n\n## 代码\n以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件\n\n```python\nimport os\nimport tempfile\nimport datetime\nimport pydicom\nfrom pydicom.dataset import Dataset, FileDataset\nfrom pdf2image import convert_from_path\n\n\n# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典\ndef read_dcm(dicom_dir):\n    dicom_list = os.listdir(dicom_dir)\n    info_list = []\n    for dicom in dicom_list:\n        # 使用pydicom读取DICOM影像信息\n        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))\n\n        info_dict = {\n            'MediaStorageSOPInstanceUID': ds.file_meta.MediaStorageSOPInstanceUID,\n            'MediaStorageSOPClassUID': ds.file_meta.MediaStorageSOPClassUID,\n            'ImplementationClassUID': ds.file_meta.ImplementationClassUID,\n            'PatientName': ds.PatientName,\n            'PatientID': ds.PatientID,\n            'PatientSex': ds.PatientSex,\n            'PatientBirthDate': ds.PatientBirthDate,\n            'PatientAge': ds.PatientAge,\n            'ContentDate': ds.ContentDate,\n            'ContentTime': ds.ContentTime,\n            'SOPClassUID': ds.SOPClassUID,\n            'SOPInstanceUID': ds.SOPInstanceUID,\n            'StudyInstanceUID': ds.StudyInstanceUID,\n            'SeriesInstanceUID': ds.SeriesInstanceUID,\n            'InstanceNumber': ds.InstanceNumber,\n            'SeriesNumber': ds.SeriesNumber,\n        }\n        info_list.append(info_dict)\n\n    # 根据InstanceUID排序\n    sort_list = sorted(info_list, key=lambda x: x['MediaStorageSOPInstanceUID'])\n\n    return sort_list[-1]\n\n\n# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中\ndef write_dcm(index, img, dicom, dicom_dir):\n    # 用于将InstanceUID尾数加1\n    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))\n\n    # 创建临时文件名\n    suffix = '.dcm'\n    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n\n    # 填充DICOM文件头必要信息\n    file_meta = Dataset()\n    file_meta.MediaStorageSOPClassUID = dicom['MediaStorageSOPClassUID']\n    file_meta.MediaStorageSOPInstanceUID = chguid(dicom['MediaStorageSOPInstanceUID'])\n    file_meta.ImplementationClassUID = dicom['ImplementationClassUID']\n\n    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)\n    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b\"\\0\" * 128)\n\n    # 加入DICOM tag信息（不包含所有）\n    ds.PatientName = dicom['PatientName']\n    ds.PatientID = dicom['PatientID']\n    ds.PatientSex = dicom['PatientSex']\n    ds.PatientBirthDate = dicom['PatientBirthDate']\n    ds.PatientAge = dicom['PatientAge']\n\n    # Set the transfer syntax\n    # ds.is_little_endian = True\n    # ds.is_implicit_VR = True\n\n    # 加入DICOM tag信息（不包含所有）\n    dt = datetime.datetime.now()\n    ds.ContentDate = dt\n    time_str = dt.strftime('%H%M%S.%f')\n    ds.ContentTime = time_str\n\n    # 生成StudyUID, SeriesUID, InstanceUID\n    ds.SOPClassUID = dicom['SOPClassUID']\n    ds.SOPInstanceUID = chguid(dicom['SOPInstanceUID'])\n    ds.StudyInstanceUID = dicom['StudyInstanceUID']\n    ds.SeriesInstanceUID = dicom['SeriesInstanceUID'] + '.1'\n    ds.InstanceNumber = index + 1\n    ds.SeriesNumber = str(int(dicom['SeriesNumber']) + 1)\n\n    # 指定影像参数\n    ds.Rows = img.size[1]\n    ds.Columns = img.size[0]\n    ds.SamplesPerPixel = 3\n    ds.PhotometricInterpretation = \"RGB\"\n    ds.HighBit = 7\n    ds.BitsStored = 8\n    ds.BitsAllocated = 8\n    ds.PixelRepresentation = 0\n\n    # 将img对象转换为bytes类型，写入PixelData字段\n    ds.PixelData = img.tobytes()\n\n    # 指定TransferSyntax等信息\n    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian\n    ds.is_little_endian = False\n    ds.is_implicit_VR = False\n\n    # 保存影像文件\n    file_name = 'report_{}.dcm'.format(index)\n    file_path = os.path.join(dicom_dir, file_name)\n    ds.save_as(file_path)\n\n\ndef main(pdf_path, dicom_dir):\n    # 将pdf转换为图片\n    images_list = convert_from_path(pdf_path)\n\n    # 从DICOM文件夹中读取最后一张影像的信息\n    dicom_info = read_dcm(dicom_dir)\n\n    # 创建DICOM影像并写入图片数据\n    for index, img in enumerate(images_list):\n        write_dcm(index, img, dicom_info, dicom_dir)\n\n\nif __name__ == '__main__':\n    pdf_path = '/home/ray/dcm_report/report.pdf'\n    dicom_dir = '/home/ray/dcm_report/dcm_data'\n\n    main(pdf_path, dicom_dir)\n\n```\n\n\n\n","source":"_posts/使用python将PDF转换为DICOM格式.md","raw":"---\ntitle: 使用python将PDF转换为DICOM格式\ndate: 2019-06-25 10:38:01\ntags: [DICOM,Python]\ncategories: DICOM\n---\n\n由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。\n\n<!--more-->\n\n## 思路\nDICOM影像通常分为三个层级：`Study`、`Series`、`Instance`，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。\n\nDICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分`Pixel Data`字段中。\n\n为了将PDF报告转换成DICOM格式，可以先利用`pdf2image`将PDF转换为常见的图片格式，再将图片转换为`bytes`类型数据，写入DICOM tag中的`Pixel Data`字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。\n\n## 代码\n以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件\n\n```python\nimport os\nimport tempfile\nimport datetime\nimport pydicom\nfrom pydicom.dataset import Dataset, FileDataset\nfrom pdf2image import convert_from_path\n\n\n# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典\ndef read_dcm(dicom_dir):\n    dicom_list = os.listdir(dicom_dir)\n    info_list = []\n    for dicom in dicom_list:\n        # 使用pydicom读取DICOM影像信息\n        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))\n\n        info_dict = {\n            'MediaStorageSOPInstanceUID': ds.file_meta.MediaStorageSOPInstanceUID,\n            'MediaStorageSOPClassUID': ds.file_meta.MediaStorageSOPClassUID,\n            'ImplementationClassUID': ds.file_meta.ImplementationClassUID,\n            'PatientName': ds.PatientName,\n            'PatientID': ds.PatientID,\n            'PatientSex': ds.PatientSex,\n            'PatientBirthDate': ds.PatientBirthDate,\n            'PatientAge': ds.PatientAge,\n            'ContentDate': ds.ContentDate,\n            'ContentTime': ds.ContentTime,\n            'SOPClassUID': ds.SOPClassUID,\n            'SOPInstanceUID': ds.SOPInstanceUID,\n            'StudyInstanceUID': ds.StudyInstanceUID,\n            'SeriesInstanceUID': ds.SeriesInstanceUID,\n            'InstanceNumber': ds.InstanceNumber,\n            'SeriesNumber': ds.SeriesNumber,\n        }\n        info_list.append(info_dict)\n\n    # 根据InstanceUID排序\n    sort_list = sorted(info_list, key=lambda x: x['MediaStorageSOPInstanceUID'])\n\n    return sort_list[-1]\n\n\n# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中\ndef write_dcm(index, img, dicom, dicom_dir):\n    # 用于将InstanceUID尾数加1\n    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))\n\n    # 创建临时文件名\n    suffix = '.dcm'\n    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n\n    # 填充DICOM文件头必要信息\n    file_meta = Dataset()\n    file_meta.MediaStorageSOPClassUID = dicom['MediaStorageSOPClassUID']\n    file_meta.MediaStorageSOPInstanceUID = chguid(dicom['MediaStorageSOPInstanceUID'])\n    file_meta.ImplementationClassUID = dicom['ImplementationClassUID']\n\n    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)\n    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b\"\\0\" * 128)\n\n    # 加入DICOM tag信息（不包含所有）\n    ds.PatientName = dicom['PatientName']\n    ds.PatientID = dicom['PatientID']\n    ds.PatientSex = dicom['PatientSex']\n    ds.PatientBirthDate = dicom['PatientBirthDate']\n    ds.PatientAge = dicom['PatientAge']\n\n    # Set the transfer syntax\n    # ds.is_little_endian = True\n    # ds.is_implicit_VR = True\n\n    # 加入DICOM tag信息（不包含所有）\n    dt = datetime.datetime.now()\n    ds.ContentDate = dt\n    time_str = dt.strftime('%H%M%S.%f')\n    ds.ContentTime = time_str\n\n    # 生成StudyUID, SeriesUID, InstanceUID\n    ds.SOPClassUID = dicom['SOPClassUID']\n    ds.SOPInstanceUID = chguid(dicom['SOPInstanceUID'])\n    ds.StudyInstanceUID = dicom['StudyInstanceUID']\n    ds.SeriesInstanceUID = dicom['SeriesInstanceUID'] + '.1'\n    ds.InstanceNumber = index + 1\n    ds.SeriesNumber = str(int(dicom['SeriesNumber']) + 1)\n\n    # 指定影像参数\n    ds.Rows = img.size[1]\n    ds.Columns = img.size[0]\n    ds.SamplesPerPixel = 3\n    ds.PhotometricInterpretation = \"RGB\"\n    ds.HighBit = 7\n    ds.BitsStored = 8\n    ds.BitsAllocated = 8\n    ds.PixelRepresentation = 0\n\n    # 将img对象转换为bytes类型，写入PixelData字段\n    ds.PixelData = img.tobytes()\n\n    # 指定TransferSyntax等信息\n    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian\n    ds.is_little_endian = False\n    ds.is_implicit_VR = False\n\n    # 保存影像文件\n    file_name = 'report_{}.dcm'.format(index)\n    file_path = os.path.join(dicom_dir, file_name)\n    ds.save_as(file_path)\n\n\ndef main(pdf_path, dicom_dir):\n    # 将pdf转换为图片\n    images_list = convert_from_path(pdf_path)\n\n    # 从DICOM文件夹中读取最后一张影像的信息\n    dicom_info = read_dcm(dicom_dir)\n\n    # 创建DICOM影像并写入图片数据\n    for index, img in enumerate(images_list):\n        write_dcm(index, img, dicom_info, dicom_dir)\n\n\nif __name__ == '__main__':\n    pdf_path = '/home/ray/dcm_report/report.pdf'\n    dicom_dir = '/home/ray/dcm_report/dcm_data'\n\n    main(pdf_path, dicom_dir)\n\n```\n\n\n\n","slug":"使用python将PDF转换为DICOM格式","published":1,"updated":"2020-12-21T03:31:40.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiy45uk7000jboui52mhhl97","content":"<p>由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DICOM影像通常分为三个层级：<code>Study</code>、<code>Series</code>、<code>Instance</code>，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。</p>\n<p>DICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分<code>Pixel Data</code>字段中。</p>\n<p>为了将PDF报告转换成DICOM格式，可以先利用<code>pdf2image</code>将PDF转换为常见的图片格式，再将图片转换为<code>bytes</code>类型数据，写入DICOM tag中的<code>Pixel Data</code>字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件</p>\n<pre><code class=\"python\">import os\nimport tempfile\nimport datetime\nimport pydicom\nfrom pydicom.dataset import Dataset, FileDataset\nfrom pdf2image import convert_from_path\n\n\n# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典\ndef read_dcm(dicom_dir):\n    dicom_list = os.listdir(dicom_dir)\n    info_list = []\n    for dicom in dicom_list:\n        # 使用pydicom读取DICOM影像信息\n        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))\n\n        info_dict = {\n            &#39;MediaStorageSOPInstanceUID&#39;: ds.file_meta.MediaStorageSOPInstanceUID,\n            &#39;MediaStorageSOPClassUID&#39;: ds.file_meta.MediaStorageSOPClassUID,\n            &#39;ImplementationClassUID&#39;: ds.file_meta.ImplementationClassUID,\n            &#39;PatientName&#39;: ds.PatientName,\n            &#39;PatientID&#39;: ds.PatientID,\n            &#39;PatientSex&#39;: ds.PatientSex,\n            &#39;PatientBirthDate&#39;: ds.PatientBirthDate,\n            &#39;PatientAge&#39;: ds.PatientAge,\n            &#39;ContentDate&#39;: ds.ContentDate,\n            &#39;ContentTime&#39;: ds.ContentTime,\n            &#39;SOPClassUID&#39;: ds.SOPClassUID,\n            &#39;SOPInstanceUID&#39;: ds.SOPInstanceUID,\n            &#39;StudyInstanceUID&#39;: ds.StudyInstanceUID,\n            &#39;SeriesInstanceUID&#39;: ds.SeriesInstanceUID,\n            &#39;InstanceNumber&#39;: ds.InstanceNumber,\n            &#39;SeriesNumber&#39;: ds.SeriesNumber,\n        }\n        info_list.append(info_dict)\n\n    # 根据InstanceUID排序\n    sort_list = sorted(info_list, key=lambda x: x[&#39;MediaStorageSOPInstanceUID&#39;])\n\n    return sort_list[-1]\n\n\n# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中\ndef write_dcm(index, img, dicom, dicom_dir):\n    # 用于将InstanceUID尾数加1\n    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))\n\n    # 创建临时文件名\n    suffix = &#39;.dcm&#39;\n    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n\n    # 填充DICOM文件头必要信息\n    file_meta = Dataset()\n    file_meta.MediaStorageSOPClassUID = dicom[&#39;MediaStorageSOPClassUID&#39;]\n    file_meta.MediaStorageSOPInstanceUID = chguid(dicom[&#39;MediaStorageSOPInstanceUID&#39;])\n    file_meta.ImplementationClassUID = dicom[&#39;ImplementationClassUID&#39;]\n\n    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)\n    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b&quot;\\0&quot; * 128)\n\n    # 加入DICOM tag信息（不包含所有）\n    ds.PatientName = dicom[&#39;PatientName&#39;]\n    ds.PatientID = dicom[&#39;PatientID&#39;]\n    ds.PatientSex = dicom[&#39;PatientSex&#39;]\n    ds.PatientBirthDate = dicom[&#39;PatientBirthDate&#39;]\n    ds.PatientAge = dicom[&#39;PatientAge&#39;]\n\n    # Set the transfer syntax\n    # ds.is_little_endian = True\n    # ds.is_implicit_VR = True\n\n    # 加入DICOM tag信息（不包含所有）\n    dt = datetime.datetime.now()\n    ds.ContentDate = dt\n    time_str = dt.strftime(&#39;%H%M%S.%f&#39;)\n    ds.ContentTime = time_str\n\n    # 生成StudyUID, SeriesUID, InstanceUID\n    ds.SOPClassUID = dicom[&#39;SOPClassUID&#39;]\n    ds.SOPInstanceUID = chguid(dicom[&#39;SOPInstanceUID&#39;])\n    ds.StudyInstanceUID = dicom[&#39;StudyInstanceUID&#39;]\n    ds.SeriesInstanceUID = dicom[&#39;SeriesInstanceUID&#39;] + &#39;.1&#39;\n    ds.InstanceNumber = index + 1\n    ds.SeriesNumber = str(int(dicom[&#39;SeriesNumber&#39;]) + 1)\n\n    # 指定影像参数\n    ds.Rows = img.size[1]\n    ds.Columns = img.size[0]\n    ds.SamplesPerPixel = 3\n    ds.PhotometricInterpretation = &quot;RGB&quot;\n    ds.HighBit = 7\n    ds.BitsStored = 8\n    ds.BitsAllocated = 8\n    ds.PixelRepresentation = 0\n\n    # 将img对象转换为bytes类型，写入PixelData字段\n    ds.PixelData = img.tobytes()\n\n    # 指定TransferSyntax等信息\n    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian\n    ds.is_little_endian = False\n    ds.is_implicit_VR = False\n\n    # 保存影像文件\n    file_name = &#39;report_{}.dcm&#39;.format(index)\n    file_path = os.path.join(dicom_dir, file_name)\n    ds.save_as(file_path)\n\n\ndef main(pdf_path, dicom_dir):\n    # 将pdf转换为图片\n    images_list = convert_from_path(pdf_path)\n\n    # 从DICOM文件夹中读取最后一张影像的信息\n    dicom_info = read_dcm(dicom_dir)\n\n    # 创建DICOM影像并写入图片数据\n    for index, img in enumerate(images_list):\n        write_dcm(index, img, dicom_info, dicom_dir)\n\n\nif __name__ == &#39;__main__&#39;:\n    pdf_path = &#39;/home/ray/dcm_report/report.pdf&#39;\n    dicom_dir = &#39;/home/ray/dcm_report/dcm_data&#39;\n\n    main(pdf_path, dicom_dir)\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DICOM影像通常分为三个层级：<code>Study</code>、<code>Series</code>、<code>Instance</code>，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。</p>\n<p>DICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分<code>Pixel Data</code>字段中。</p>\n<p>为了将PDF报告转换成DICOM格式，可以先利用<code>pdf2image</code>将PDF转换为常见的图片格式，再将图片转换为<code>bytes</code>类型数据，写入DICOM tag中的<code>Pixel Data</code>字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件</p>\n<pre><code class=\"python\">import os\nimport tempfile\nimport datetime\nimport pydicom\nfrom pydicom.dataset import Dataset, FileDataset\nfrom pdf2image import convert_from_path\n\n\n# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典\ndef read_dcm(dicom_dir):\n    dicom_list = os.listdir(dicom_dir)\n    info_list = []\n    for dicom in dicom_list:\n        # 使用pydicom读取DICOM影像信息\n        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))\n\n        info_dict = {\n            &#39;MediaStorageSOPInstanceUID&#39;: ds.file_meta.MediaStorageSOPInstanceUID,\n            &#39;MediaStorageSOPClassUID&#39;: ds.file_meta.MediaStorageSOPClassUID,\n            &#39;ImplementationClassUID&#39;: ds.file_meta.ImplementationClassUID,\n            &#39;PatientName&#39;: ds.PatientName,\n            &#39;PatientID&#39;: ds.PatientID,\n            &#39;PatientSex&#39;: ds.PatientSex,\n            &#39;PatientBirthDate&#39;: ds.PatientBirthDate,\n            &#39;PatientAge&#39;: ds.PatientAge,\n            &#39;ContentDate&#39;: ds.ContentDate,\n            &#39;ContentTime&#39;: ds.ContentTime,\n            &#39;SOPClassUID&#39;: ds.SOPClassUID,\n            &#39;SOPInstanceUID&#39;: ds.SOPInstanceUID,\n            &#39;StudyInstanceUID&#39;: ds.StudyInstanceUID,\n            &#39;SeriesInstanceUID&#39;: ds.SeriesInstanceUID,\n            &#39;InstanceNumber&#39;: ds.InstanceNumber,\n            &#39;SeriesNumber&#39;: ds.SeriesNumber,\n        }\n        info_list.append(info_dict)\n\n    # 根据InstanceUID排序\n    sort_list = sorted(info_list, key=lambda x: x[&#39;MediaStorageSOPInstanceUID&#39;])\n\n    return sort_list[-1]\n\n\n# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中\ndef write_dcm(index, img, dicom, dicom_dir):\n    # 用于将InstanceUID尾数加1\n    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))\n\n    # 创建临时文件名\n    suffix = &#39;.dcm&#39;\n    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name\n\n    # 填充DICOM文件头必要信息\n    file_meta = Dataset()\n    file_meta.MediaStorageSOPClassUID = dicom[&#39;MediaStorageSOPClassUID&#39;]\n    file_meta.MediaStorageSOPInstanceUID = chguid(dicom[&#39;MediaStorageSOPInstanceUID&#39;])\n    file_meta.ImplementationClassUID = dicom[&#39;ImplementationClassUID&#39;]\n\n    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)\n    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b&quot;\\0&quot; * 128)\n\n    # 加入DICOM tag信息（不包含所有）\n    ds.PatientName = dicom[&#39;PatientName&#39;]\n    ds.PatientID = dicom[&#39;PatientID&#39;]\n    ds.PatientSex = dicom[&#39;PatientSex&#39;]\n    ds.PatientBirthDate = dicom[&#39;PatientBirthDate&#39;]\n    ds.PatientAge = dicom[&#39;PatientAge&#39;]\n\n    # Set the transfer syntax\n    # ds.is_little_endian = True\n    # ds.is_implicit_VR = True\n\n    # 加入DICOM tag信息（不包含所有）\n    dt = datetime.datetime.now()\n    ds.ContentDate = dt\n    time_str = dt.strftime(&#39;%H%M%S.%f&#39;)\n    ds.ContentTime = time_str\n\n    # 生成StudyUID, SeriesUID, InstanceUID\n    ds.SOPClassUID = dicom[&#39;SOPClassUID&#39;]\n    ds.SOPInstanceUID = chguid(dicom[&#39;SOPInstanceUID&#39;])\n    ds.StudyInstanceUID = dicom[&#39;StudyInstanceUID&#39;]\n    ds.SeriesInstanceUID = dicom[&#39;SeriesInstanceUID&#39;] + &#39;.1&#39;\n    ds.InstanceNumber = index + 1\n    ds.SeriesNumber = str(int(dicom[&#39;SeriesNumber&#39;]) + 1)\n\n    # 指定影像参数\n    ds.Rows = img.size[1]\n    ds.Columns = img.size[0]\n    ds.SamplesPerPixel = 3\n    ds.PhotometricInterpretation = &quot;RGB&quot;\n    ds.HighBit = 7\n    ds.BitsStored = 8\n    ds.BitsAllocated = 8\n    ds.PixelRepresentation = 0\n\n    # 将img对象转换为bytes类型，写入PixelData字段\n    ds.PixelData = img.tobytes()\n\n    # 指定TransferSyntax等信息\n    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian\n    ds.is_little_endian = False\n    ds.is_implicit_VR = False\n\n    # 保存影像文件\n    file_name = &#39;report_{}.dcm&#39;.format(index)\n    file_path = os.path.join(dicom_dir, file_name)\n    ds.save_as(file_path)\n\n\ndef main(pdf_path, dicom_dir):\n    # 将pdf转换为图片\n    images_list = convert_from_path(pdf_path)\n\n    # 从DICOM文件夹中读取最后一张影像的信息\n    dicom_info = read_dcm(dicom_dir)\n\n    # 创建DICOM影像并写入图片数据\n    for index, img in enumerate(images_list):\n        write_dcm(index, img, dicom_info, dicom_dir)\n\n\nif __name__ == &#39;__main__&#39;:\n    pdf_path = &#39;/home/ray/dcm_report/report.pdf&#39;\n    dicom_dir = &#39;/home/ray/dcm_report/dcm_data&#39;\n\n    main(pdf_path, dicom_dir)\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckiy45ujh0000bouigofa6x1t","category_id":"ckiy45ujq0004boui150qfai8","_id":"ckiy45uk4000fbouib16t98hn"},{"post_id":"ckiy45ujn0002bouiazg92xrz","category_id":"ckiy45ujz000bbouibldfemvd","_id":"ckiy45uk9000lboui6872afjl"},{"post_id":"ckiy45uk2000eboui00zb6zly","category_id":"ckiy45ujq0004boui150qfai8","_id":"ckiy45ukb000nboui7prahqjh"},{"post_id":"ckiy45uk6000ibouib82n67we","category_id":"ckiy45ujq0004boui150qfai8","_id":"ckiy45ukc000pboui8zok8ddu"},{"post_id":"ckiy45ujs0006boui52q49dlc","category_id":"ckiy45ujz000bbouibldfemvd","_id":"ckiy45uke000tboui5jr92dq1"},{"post_id":"ckiy45uk7000jboui52mhhl97","category_id":"ckiy45ujq0004boui150qfai8","_id":"ckiy45ukf000vboui6in6f274"},{"post_id":"ckiy45ujw0008bouihrxr394v","category_id":"ckiy45uk9000kbouiepd8diss","_id":"ckiy45ukg000zboui1e0xd27h"},{"post_id":"ckiy45ujy000abouihi6rb3ou","category_id":"ckiy45uk9000kbouiepd8diss","_id":"ckiy45ukh0012bouiggag1pwg"},{"post_id":"ckiy45uk0000dbouibvh00bmy","category_id":"ckiy45ukf000xboui4szm60q3","_id":"ckiy45uki0016boui5bg9bxqu"}],"PostTag":[{"post_id":"ckiy45ujh0000bouigofa6x1t","tag_id":"ckiy45ujr0005bouie12v719j","_id":"ckiy45ukc000oboui32fpeft6"},{"post_id":"ckiy45ujh0000bouigofa6x1t","tag_id":"ckiy45ujz000cbouif1d3e61d","_id":"ckiy45ukc000qbouifd5972hs"},{"post_id":"ckiy45ujh0000bouigofa6x1t","tag_id":"ckiy45uk4000hboui91sa9o8a","_id":"ckiy45uke000ubouifgor4ale"},{"post_id":"ckiy45uk7000jboui52mhhl97","tag_id":"ckiy45ujr0005bouie12v719j","_id":"ckiy45ukf000wbouiblatbuir"},{"post_id":"ckiy45uk7000jboui52mhhl97","tag_id":"ckiy45ujz000cbouif1d3e61d","_id":"ckiy45ukg0010boui8lp50644"},{"post_id":"ckiy45ujn0002bouiazg92xrz","tag_id":"ckiy45uk9000mboui0cy5fjjq","_id":"ckiy45ukh0011boui3r0u83sj"},{"post_id":"ckiy45ujn0002bouiazg92xrz","tag_id":"ckiy45ujz000cbouif1d3e61d","_id":"ckiy45uki0014boui7u90ggk9"},{"post_id":"ckiy45ujs0006boui52q49dlc","tag_id":"ckiy45uk9000mboui0cy5fjjq","_id":"ckiy45uki0015bouibllvf7mc"},{"post_id":"ckiy45ujw0008bouihrxr394v","tag_id":"ckiy45ukh0013boui3zog29fa","_id":"ckiy45ukj0018bouib0863ypw"},{"post_id":"ckiy45ujy000abouihi6rb3ou","tag_id":"ckiy45ukh0013boui3zog29fa","_id":"ckiy45ukm001cboui4cz58j8r"},{"post_id":"ckiy45ujy000abouihi6rb3ou","tag_id":"ckiy45uk9000mboui0cy5fjjq","_id":"ckiy45ukm001dboui14hnc1c6"},{"post_id":"ckiy45ujy000abouihi6rb3ou","tag_id":"ckiy45ukk001abouia36z3qki","_id":"ckiy45ukn001fboui1oha42pl"},{"post_id":"ckiy45uk0000dbouibvh00bmy","tag_id":"ckiy45ukl001bbouidi5u7sew","_id":"ckiy45ukn001gboui1mr31nub"},{"post_id":"ckiy45uk2000eboui00zb6zly","tag_id":"ckiy45ukm001ebouie0klg2ns","_id":"ckiy45ukp001jbouift3baf8s"},{"post_id":"ckiy45uk2000eboui00zb6zly","tag_id":"ckiy45ukn001hboui822dhgb7","_id":"ckiy45ukp001kbouifctrdwc0"},{"post_id":"ckiy45uk2000eboui00zb6zly","tag_id":"ckiy45ujr0005bouie12v719j","_id":"ckiy45ukq001lbouifrew4sg0"},{"post_id":"ckiy45uk6000ibouib82n67we","tag_id":"ckiy45uko001iboui9lc942lq","_id":"ckiy45ukq001mbouiapc0fdwt"},{"post_id":"ckiy45uk6000ibouib82n67we","tag_id":"ckiy45ujr0005bouie12v719j","_id":"ckiy45ukq001nboui25wpb4o7"},{"post_id":"ckiy45uk6000ibouib82n67we","tag_id":"ckiy45ujz000cbouif1d3e61d","_id":"ckiy45ukr001obouiet0m6skh"}],"Tag":[{"name":"DICOM","_id":"ckiy45ujr0005bouie12v719j"},{"name":"Python","_id":"ckiy45ujz000cbouif1d3e61d"},{"name":"pydicom","_id":"ckiy45uk4000hboui91sa9o8a"},{"name":"Django","_id":"ckiy45uk9000mboui0cy5fjjq"},{"name":"Docker","_id":"ckiy45ukh0013boui3zog29fa"},{"name":"Nginx","_id":"ckiy45ukk001abouia36z3qki"},{"name":"Git","_id":"ckiy45ukl001bbouidi5u7sew"},{"name":"Orthanc","_id":"ckiy45ukm001ebouie0klg2ns"},{"name":"OHIF","_id":"ckiy45ukn001hboui822dhgb7"},{"name":"SimpleITK","_id":"ckiy45uko001iboui9lc942lq"}]}}