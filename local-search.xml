<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Asyncio基本用法</title>
    <link href="/2023/12/13/Asyncio%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2023/12/13/Asyncio%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a name="RIY15"></a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul><li><p>Asyncio是Python3.4加入的异步编程模块，用来取代yield，实现协程。asyncio 模块在单线程上启动一个事件循环（event loop），时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束</p></li><li><p>官方文档：<a href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#">https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#</a></p></li><li><p>基本概念</p></li></ul><p><code>event_loop</code> 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数</p><p><code>coroutine</code> 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用</p><p><code>task</code> 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态</p><p><code>future</code>： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</p><p><code>async/await</code> 关键字：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口</p><p><a name="XtfG0"></a></p><h2 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h2><ul><li>简单示例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;One&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Two&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(count(), count(), count())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>注意，直接执行main()函数并不会运行代码，需要使用asyncio.run()将main函数注册到事件循环并等待运行结束</p><ul><li>并发执行协程函数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;p&#125;</span> complete&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    create_task在python3.7加入，python3.7之前可用asyncio.ensure_future()函数;</span></span><br><span class="line"><span class="string">    asyncio.create_task只能在协程函数中调用，因为这个函数中需要用到事件循环(event_loop);</span></span><br><span class="line"><span class="string">    如果使用的是 asyncio.gather创建协程对象，那么await的返回值就是协程运行的结果;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># tasks = [asyncio.create_task(test(i)) for i in range(10)]</span></span><br><span class="line">    <span class="comment"># result = await asyncio.gather(*tasks)</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    gather接收的参数可以是task或者协程对象，而wait不可以直接接收协程对象</span></span><br><span class="line"><span class="string">    gather返回值的顺序是按照原始顺序排列</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="keyword">await</span> asyncio.gather(*[test(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    如果使用的是 asyncio.wait，那么返回值是(已完成任务，等待中任务)的集合</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># tasks = [asyncio.create_task(test(i)) for i in range(10)]</span></span><br><span class="line">    <span class="comment"># done, pending = await asyncio.wait(tasks)</span></span><br><span class="line">    <span class="comment"># for task in done:</span></span><br><span class="line">    <span class="comment">#     print(task.result())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过event_loop执行协程函数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = asyncio.gather(*[test(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line">    result = loop.run_until_complete(tasks)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main3</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    - asyncio.gather和asyncio.wait区别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    gather只会返回协程结果，而wait会返回封装的task， wait支持自定义返回的时机，通过接受参数return_when，可选值有ALL_COMPLETED/FIRST_COMPLETED/FIRST_EXCEPTION。因此，如果需要取消task、添加回调函数、自定义返回时机，那么就可以使用wait</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - asyncio.create_task、loop.create_task、asyncio.ensure_future区别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    asyncio.create_task源码是调用的loop.create_task</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    loop.create_task接收的参数只能是协程，而ensure_future则可以接收三种参数：</span></span><br><span class="line"><span class="string">    1.接收协程，调用loop.create_task，返回task对象</span></span><br><span class="line"><span class="string">    2.接收Future对象，直接返回</span></span><br><span class="line"><span class="string">    3.接收一个awaitable对象，会await这个对象的__await__方法，再执行一次ensure_future，最后返回Task或者Future</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [asyncio.ensure_future(test(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    done, pending = loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> done:</span><br><span class="line">        <span class="built_in">print</span>(task.result())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for task in tasks:</span></span><br><span class="line">    <span class="comment">#     print(task.result())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><ul><li>利用<code>run_in_executor</code> 开启多线程执行阻塞任务</li></ul><p>由于很多第三方库还未直接支持await的写法，因此碰到一些I/O阻塞的任务（比如request, selenium等），还是需要通过多线程并发执行<br />官方文档：<a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor</a></p><p><code>loop.run_in_executor(executor, func, *args)</code> 接收三个参数：<br /><code>executor</code>: 必须是一个<a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.Executor">concurrent.futures.Executor</a>，如果未指定则使用默认executor<br /><code>func</code> 要执行的函数<br /><code>*args</code> 要传递给函数func的参数<br />使用示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line">executor = futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">blocked_sleep</span>(<span class="params">name, t</span>):</span><br><span class="line">    <span class="built_in">print</span>(strftime(<span class="string">&#x27;[%H:%M:%S]&#x27;</span>),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sleep &#123;&#125; is running &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(name, t))</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, sleep, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(strftime(<span class="string">&#x27;[%H:%M:%S]&#x27;</span>),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sleep &#123;&#125; is end&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    future = (blocked_sleep(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">    fs = asyncio.gather(*future)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> fs</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>利用asyncio实现异步爬虫的示例</li></ul><p><a href="https://github.com/Ray-SR/fund_query">https://github.com/Ray-SR/fund_query</a></p><p><a name="aYcCA"></a></p><h2 id="3-参考文章"><a href="#3-参考文章" class="headerlink" title="3.参考文章"></a>3.参考文章</h2><p>《Python黑魔法 — 异步IO（ asyncio） 协程》<br /><a href="https://www.jianshu.com/p/b5e347b3a17c">https://www.jianshu.com/p/b5e347b3a17c</a></p><p>《asyncio中使用阻塞函数》<br /><a href="https://juejin.cn/post/6844903576825774093">https://juejin.cn/post/6844903576825774093</a></p><p>《深入理解asyncio》<br /><a href="https://zhuanlan.zhihu.com/p/73568282">https://zhuanlan.zhihu.com/p/73568282</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的管道符和偏函数</title>
    <link href="/2023/11/01/Python%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E7%AC%A6%E5%92%8C%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/01/Python%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E7%AC%A6%E5%92%8C%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-偏函数partial"><a href="#1-偏函数partial" class="headerlink" title="1.偏函数partial"></a>1.偏函数partial</h2><p>偏函数的作用类似装饰器，它可以在不改变原有函数的基础上，扩展函数的功能。在频繁调用某个函数时，某些参数是已知的固定值，如果不想每次都传入，可以利用partial来扩展这个函数。例如我们想要对一些数字求和，在求和的结果上再加100，那么常用的办法可以这么写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args) + <span class="number">100</span></span><br></pre></td></tr></table></figure><p>但是如果我们想要修改固定值100，那么就得改变<code>add</code>这个函数，下面使用partial实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_100 = partial(add, <span class="number">100</span>)</span><br><span class="line">add_200 = partial(add, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add_100(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 106</span></span><br><span class="line"><span class="built_in">print</span>(add_200(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 206</span></span><br></pre></td></tr></table></figure><p>可以看到我们使用以原函数<code>add</code>、<code>固定值</code>作为参数，传入parital类，返回了一个新函数，这样在调用新函数时，就不需要再传入固定值了。偏函数接收三个参数，它们可以扩展和覆盖原函数的参数：<br /><code>func</code> 需要被扩展的函数<br /><code>*args</code> 需要被固定的位置参数<br /><code>**kwargs</code> 需要被固定的关键字参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类func = functools.partial(func, *args, **keywords)</span><br></pre></td></tr></table></figure><p><a name="TJszd"></a></p><h2 id="2-管道符"><a href="#2-管道符" class="headerlink" title="2.管道符 |"></a>2.管道符 |</h2><p>python中的管道符 | 用于逻辑运算<code>或</code> ，它是通过内置魔法方法<code>__ror__</code>来实现的，因此我们可以重写这个方法来实现想要的效果。下面的例子中，我们重写的类A的<code>__ror__</code>方法，返回的是它接收的参数<code>other</code>和100的和，<br />可以看到，在执行<code>1 | A()</code>时，实际上是以1作为参数传入了A()实例的<code>__ror__</code>方法，这个语句的返回值就是<code>__ror__</code>方法的返回值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ror__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span> + other</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = <span class="number">1</span> | A()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 101</span></span><br></pre></td></tr></table></figure><p><a name="Bpw2R"></a></p><h2 id="3-用Python实现shell命令中的管道"><a href="#3-用Python实现shell命令中的管道" class="headerlink" title="3.用Python实现shell命令中的管道"></a>3.用Python实现shell命令中的管道</h2><p>python中的管道符通常使用在逻辑或的运算，如果要实现类似shell命令中的管道，就可以利用上面提到的偏函数以及重写<code>__ror__</code>方法，这个思路来自于<code>v2ex</code>上网友的分享，原贴地址：<br /><a href="https://www.v2ex.com/t/743574#reply112">https://www.v2ex.com/t/743574#reply112</a></p><p>下面是代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(<span class="title class_ inherited__">partial</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    partial接收3个参数,需要扩展的函数/不定长参数/关键字参数,返回一个新函数,</span></span><br><span class="line"><span class="string">    新函数会默认带上旧函数的参数,并且可以重写或扩展这些参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ror__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        __ror__方法是python中管道符&quot;|&quot;对应的方法,接收的参数other就是&quot;|&quot;左边的值</span></span><br><span class="line"><span class="string">        例如类A实现了__ror__方法,那么在执行 x | A() 的时候,就是以x为参数传入类A的__ror__方法,执行的结果就是__ror__的返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, <span class="built_in">tuple</span>):</span><br><span class="line">            <span class="keyword">return</span> self(*other)</span><br><span class="line">        <span class="keyword">return</span> self(other)</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(*args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> args <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) | F(<span class="built_in">filter</span>) | F(add)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>可以看到，这里是继承了python的partial类，并重写了其<code>__ror__</code>方法，那么在执行<code>(1, 2, 3, 4) | F(filter)</code>时，就会以（1,2,3,4）为参数传入<code>__ror__</code>方法，在这个方法里面，<code>self</code>指向的是<code>F(filter)</code>这个对象。那么这个对象是什么呢，在第一节中我们知道，它实际上是一个扩展了<code>filter</code>函数的新函数，只不过这里没有额外传入其他参数也就没有进行扩展，因此<code>self(*other)</code>实际上是执行了<code>filter(*other)</code>， 其结果就是[2, 4]，这个结果又会作为参数传入<code>F(add)</code> 中，最终执行了<code>add(*[2, 4])</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes基础</title>
    <link href="/2022/12/27/Kubernetes%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/12/27/Kubernetes%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>k8s 把数量众多的服务器重新抽象为一个统一的资源池</strong>，对于运维人员来说，他们面前没有服务器1、服务器2的概念，而是一个统一的资源池，增加新的服务器对运维人员来说，只是增加自资源池的可用量。不仅如此，k8s 把所有能用的东西都抽象成了资源的概念，从而提供了一套更统一，更简洁的管理方式。</p><span id="more"></span><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-Pod"><a href="#1-1-Pod" class="headerlink" title="1.1 Pod"></a>1.1 Pod</h3><p>Pod是K8S中的最小工作单位， 和Docker中的容器类似， 不过pod是将一个或多个docker容器封装成一个统一的整体进行管理，并对外提供服务，同一个Pod内的容器可以共享网络栈、存储卷等。</p><p>例如查看本机有哪些pod:  <code>kubectl get pods</code><br>查看命名空间为kube-system下的所有pod: <code>kubectl get pods -n kube-system</code></p><ul><li><strong>创建资源</strong></li></ul><p>k8s中所有资源都可以通过<code>kube create</code>命令创建，使用create创建资源有2种方式，一种是直接使用命令指定参数，另一种是通过<code>yaml</code>文件创建。例如新建一个名为<code>kubia-pod.yaml</code>的文件如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>然后使用<code>kubectl create -f kubia-pod.yaml</code> 就可以创建一个pod<br>之后如果修改了配置，可以使用<code>kubectl apply -f kubia-pod.yaml</code>来重新应用配置</p><h3 id="1-2-namespace"><a href="#1-2-namespace" class="headerlink" title="1.2 namespace"></a>1.2 namespace</h3><p>命名空间namespace是k8s中组的概念，提供同一服务的pod应该被放置在同一命名空间下， 如果不指定，pod默认被放在命名空间<code>default</code> 下</p><h3 id="1-3-ReplicationController（副本控制器）"><a href="#1-3-ReplicationController（副本控制器）" class="headerlink" title="1.3 ReplicationController（副本控制器）"></a>1.3 ReplicationController（副本控制器）</h3><p>ReplicationController(RC)是pod的复制抽象，用于解决pod的扩容缩容问题, 它会确保任何时间Kubernetes中都有指定数量的Pod在运行。在此基础上，RC还提供了一些更高级的特性，比如滚动升级、升级回滚等。<br>RC通过label来关联pod， 对于pod，需要设置其自身的label进行表示，label是一些列的key/value对。在创建RC的时候，需要指定<strong>标签选择器</strong>(Label Selector)，生成之后，它就会通过选择器查找pod并将其纳入自己的管辖</p><ul><li><strong>标签：标签是k8s中用于分类资源而提供的一个属性，一个标签包含<code>标签名</code>和<code>标签值</code>， 例如<code>app=kubia</code>, k8s中绝大多数资源都是通过标签来筛选和控制pod的</strong></li></ul><p>一个简单的RC配置文件<code>kubia-rc.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="comment"># 说明类型为 rc</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-controller</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 这里指定了期望的副本数量</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># 这里指定了目标 pod 的选择器</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="comment"># 目标 pod: app 标签的值为 kubia</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="comment"># pod 模板</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="comment"># 指定 pod 的标签</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 指定 pod 容器的内容</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>使用<code>kubectl create -f kubia-rc.yaml</code>即可创建该副本控制器<br>此后，即使我们使用<code>kubectl delete</code>删除了该副本控制器管辖的3个pod，它仍然会自动创建新的。需要注意，RC是通过<strong>标签</strong>来管理pod的，如果修改了某个pod的标签，那么它就自动脱离了RC的控制</p><ul><li><strong>存活探针</strong></li></ul><p>副本控制器RC是通过存活探针来讲pod的数量控制在期望数量， 存活探针的检测方式包括3种：<code>HTTP GET请求</code> 、<code>TCP套接字</code> 、<code>Exec执行命令</code><br>一个带有存活探针的pod配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia-unhealthy</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="comment"># 这下面就是探针！</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="1-4-ReplicationSet"><a href="#1-4-ReplicationSet" class="headerlink" title="1.4 ReplicationSet"></a>1.4 ReplicationSet</h3><p>ReplicationSet(RS)是升级版的RC，区别在于RS引入了对基于子集的selector查询条件，而RC仅支持基于值相等的selector条件查询<br>一个RS的配置文件<code>kubia-rs.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要指定对应的 apiVersion</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="comment"># 只有这里和 rc 的写法不同</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="1-5-Deployment"><a href="#1-5-Deployment" class="headerlink" title="1.5 Deployment"></a>1.5 Deployment</h3><p>Deployment为pod和RS提供声明式的更新能力, 通过在Deployment中描述期望的集群状态， Deployment Controller会将现在的集群状态逐步更新为期望的集群状态，其职责同样是为了保证pod的数量和健康，并且提供了RS之外的新特性：<br>事件和状态查看：可以查看Deployment的升级详细进度和状态。<br>　　　　<strong>回滚</strong>：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。<br>　　　　<strong>版本记录</strong>: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。<br>　　　　<strong>暂停和启动</strong>：对于每一次升级，都能够随时暂停和启动。<br>　　　　<strong>多种升级方案</strong>：Recreate—-删除所有已存在的pod,重新创建新的; RollingUpdate—-滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。</p><h3 id="1-6-Service"><a href="#1-6-Service" class="headerlink" title="1.6 Service"></a>1.6 Service</h3><p>由于pod在受到RC调控时，其副本和虚拟ip的变化的，比如发生迁移或伸缩的时候。因此需要一个统一固定的ip或域名来访问，Service是pod的路由代理抽象，用于解决pod之间的路由发现问题，访问端只需要知道service的地址，由service来提供代理，Service和Pod之间同样是通过label来进行关联<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607671122045-2e14c059-845e-4090-a9ba-35935b1dd1f9.png#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&name=service.png&originHeight=421&originWidth=864&size=28962&status=done&style=stroke&width=864" alt="service.png"><br>接下来演示如何创建一个service:</p><ul><li><p>首先使用1.4小节中的<code>kubia-rs.yaml</code>来创建3个pod：<code>kubectl create -f kubia-rs.yaml</code></p><p>创建成功之后就可以看到3个pod<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673418280-1df7615c-7200-4101-9f33-5a7268923a6d.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&name=rs.png&originHeight=160&originWidth=1268&size=39467&status=done&style=none&width=1268" alt="rs.png"></p></li><li><p>接下来新建service来提供对这3个pod的访问，新建<code>kubia-svc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">port80</span> <span class="comment"># 为所有端口指定名称</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 对外开放的服务端口</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 后方 pod 的服务端口</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><p>执行<code>kubectl create -f kubia-svc.yaml</code>来创建该服务，之后就可以看到它的信息：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673617273-2a231480-7e30-49c8-bda5-94b31baeb8b4.png#align=left&display=inline&height=141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=1360&size=44737&status=done&style=none&width=1360" alt="image.png"><br>CLUSTER-IP一栏就是该服务的ip，节点内其他pod就可以通过这个ip来访问服务，例如通过pod<code>kubia-4p45t</code>来访问服务：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673956066-7132bfd9-1b31-4e11-8399-fb9f45bb3330.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=service3.png&originHeight=136&originWidth=1058&size=32024&status=done&style=none&width=1058" alt="service3.png"><br>可以看到请求被转向了<code>kubia-k66bq</code>和<code>kubia-5dlks</code>这2个pod，并且实现了负载均衡</p></li></ul><h3 id="1-7-Endpoints"><a href="#1-7-Endpoints" class="headerlink" title="1.7 Endpoints"></a>1.7 Endpoints</h3><p>因为<code>svc</code>是通过我们事先定义好的标签选择器来查找 pod 的，所以 pod 的 ip 地址变动对于<code>svc</code>毫无影响，其实在<code>svc</code>和<code>pod</code>之间还包含了一个资源叫做<code>endpoint</code>，<code>endpoint</code>(简称<code>ep</code>)是一组地址及其端口的合集，如下图，只要一个<code>svc</code>有标签选择器的话，他就会自动创建一个同名的<code>ep</code>来标记出自己的要管理的 pod</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607671225632-e4497afa-1552-49cc-99d0-03fc94e1ea0e.png#align=left&display=inline&height=513&margin=%5Bobject%20Object%5D&name=endpoint.png&originHeight=513&originWidth=408&size=23720&status=done&style=stroke&width=408" alt="endpoint.png"></p><ul><li>通过域名访问服务</li></ul><p>在1.6小节中我们通过ip的方式访问了服务，实际上k8s也提供了<code>FQDN</code>（全限定域名）的方式访问服务：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607674417105-d629ed47-b1ff-4666-83bf-537d92ace1b3.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=name.png&originHeight=68&originWidth=1142&size=16547&status=done&style=none&width=1142" alt="name.png"><br>上图中的kubia就是我们在创建<code>service</code>时指定的<code>name</code> 属性<br>(这种方式可以访问同一命名空间中的服务，k8s还支持访问不同命名空间中的服务)</p><ul><li>访问集群外部服务</li></ul><p>如果一个集群内部的pod要访问外部服务器，如云数据库、公共API等，就可以利用<code>Endpoint</code>来指定外部 服务的ip和端口，并将其绑定到一个服务<code>serivce</code>上<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607674767028-ba0918b6-aca8-4fae-9fba-e4105948242b.png#align=left&display=inline&height=503&margin=%5Bobject%20Object%5D&name=13523736-e4c4aa978679fee1.png&originHeight=503&originWidth=177&size=15742&status=done&style=stroke&width=177" alt="13523736-e4c4aa978679fee1.png"><br>新建<code>external-service.yaml</code>如下，它只是提供了一个80端口供其他pod访问：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>然后新建<code>external-endpoints.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 和 svc 相同的名称</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">    <span class="comment"># 这里指定了外部服务的 ip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">13.125</span><span class="number">.137</span><span class="number">.129</span></span><br><span class="line">    <span class="comment"># 可以指定多个</span></span><br><span class="line">    <span class="comment"># - ip: 22.22.22.22</span></span><br><span class="line">    <span class="comment"># 还要指定端口号</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>执行创建命令： <code>kubectl create -f external-service.yaml</code><br><code>kubectl create -f external-endpoints.yaml</code><br>然后查看服务详情，可以看到他已经和endpoint完成绑定<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675210199-c22fbed8-b99c-4337-94b5-decd1ee35364.png#align=left&display=inline&height=497&margin=%5Bobject%20Object%5D&name=endpoint2.png&originHeight=497&originWidth=1381&size=90330&status=done&style=none&width=1381" alt="endpoint2.png"></p><p>另外，也可以指定svc的类型type为<code>ExternalName</code>,再通过<code>ExternalName</code>字段来指定外部服务的域名，如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 要先指定 svc 的类型</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="comment"># 再在这里指定外部服务的完全限定域名</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">someapi.some.company.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><table><thead><tr><th align="center"><code>get</code></th><th align="center">查</th><th align="center">列出某个类型的下属资源</th></tr></thead></table><table><thead><tr><th align="center"><code>describe</code></th><th align="center">查</th><th align="center">查看某个资源的详细信息</th></tr></thead></table><table><thead><tr><th align="center"><code>logs</code></th><th align="center">查</th><th align="center">查看某个 pod 的日志</th></tr></thead></table><table><thead><tr><th align="center"><code>create</code></th><th align="center">增</th><th align="center">新建资源</th></tr></thead></table><table><thead><tr><th align="center"><code>explain</code></th><th align="center">查</th><th align="center">查看某个资源的配置项</th></tr></thead></table><table><thead><tr><th align="center"><code>delete</code></th><th align="center">删</th><th align="center">删除某个资源</th></tr></thead></table><table><thead><tr><th align="center"><code>edit</code></th><th align="center">改</th><th align="center">修改某个资源的配置项</th></tr></thead></table><table><thead><tr><th align="center"><code>apply</code></th><th align="center">改</th><th align="center">应用某个资源的配置项</th></tr></thead></table><h2 id="3-对外提供服务"><a href="#3-对外提供服务" class="headerlink" title="3.对外提供服务"></a>3.对外提供服务</h2><p>k8s对外提供服务通常有<code>post-forward</code> 、<code>NodePort</code> 、<code>Ingress</code>几种方式</p><h3 id="3-1-port-forward"><a href="#3-1-port-forward" class="headerlink" title="3.1 port-forward"></a>3.1 port-forward</h3><p>port-forward适用于测试某个资源是否可用<br><code>kubectl port-forward &lt;资源类型&gt;/&lt;资源名&gt; &lt;本机端口&gt;:&lt;资源端口&gt;</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675899436-0495205f-ceb4-4497-931a-ffdc034bc6a0.png#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&name=port-forward1.png&originHeight=367&originWidth=1193&size=81825&status=done&style=none&width=1193" alt="port-forward1.png"><br>访问：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675911713-f948514d-cc07-4469-863e-ffe09ec45833.png#align=left&display=inline&height=58&margin=%5Bobject%20Object%5D&name=port-forward2.png&originHeight=58&originWidth=790&size=13271&status=done&style=none&width=790" alt="port-forward2.png"></p><h3 id="3-2-NodePort"><a href="#3-2-NodePort" class="headerlink" title="3.2 NodePort"></a>3.2 NodePort</h3><p>NodePort可以将服务转发到所有k8s节点的指定端口上，其本质上也是一个<code>Service</code> 资源，通过指定<code>nodePort</code>来将服务映射到节点的端口上，配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30123</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><p>创建后，就可以通过<code>curl 节点ip:端口号</code> 来访问了，节点ip可以通过<code>kubectl describe node &lt;节点名&gt;</code>来查看</p><h3 id="3-3-Ingress"><a href="#3-3-Ingress" class="headerlink" title="3.3 Ingress"></a>3.3 Ingress</h3><p>使用NodePort已经可以满足暴露服务的需求，但是如果有多个服务，虽然可以通过nginx服务器来实现转发，但是如果服务有变更，就需要再次手动配置nginx，而k8s提供了另一种方式：Ingress</p><p>Ingress由2部分构成，服务转发服务的<code>ingress-controller</code>和<code>Ingress</code>资源，Ingress-controller根据Ingress资源提供的配置来转发流量， k8s本身没有自带Ingress-controller，这里我们使用官方推荐的<code>nginx-ingress-controller</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607676497846-8e24895e-6dd8-4337-b79c-15685f658724.png#align=left&display=inline&height=605&margin=%5Bobject%20Object%5D&name=ingress1.png&originHeight=605&originWidth=515&size=29492&status=done&style=stroke&width=515" alt="ingress1.png"></p><ul><li>安装nginx-ingress-controller</li></ul><p>官方配置文件： <a href="https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml">https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml</a><br>注意，官方的配置文件中，指定的<code>image</code>镜像源无法用国内网络访问，需要替换为国内镜像源。另外，<strong><code>Ingress-controller</code>本身只是一个pod,它并不直接对外暴露端口</strong>，因此还需要新建一个NodePort将其暴露出去，完整配置文件如下：<br><a href="/ingress-nginx-controller.yml">ingress-nginx.yaml</a></p><p>使用<code>kubectl create -f ingress-nginx.yaml</code>之后，就可以查看创建成功的Controller<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607677258423-54901efa-ebb0-4140-a13f-e80586a03b28.png#align=left&display=inline&height=84&margin=%5Bobject%20Object%5D&name=controller1.png&originHeight=84&originWidth=1069&size=23181&status=done&style=none&width=1069" alt="controller1.png"></p><ul><li>创建ingress资源</li></ul><p>（注意，在这一步之前需要创建一个<code>service</code>及其<code>pod</code>，具体可参考1.6小节中的步骤）<br>新建<code>kubia-ingress.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="comment"># 将服务映射到该域名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">        <span class="comment"># 通过 /kubia 路径就可以访问该服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kubia</span></span><br><span class="line">        <span class="comment"># 该服务后端 svc 的名称及端口号</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>配置域名映射</li></ul><p>在<code>ingress-nginx.yaml</code>中，我们已经将<code>nginx-ingress-controller</code>这个pod以30010端口暴露到主机上，接下来需要配置域名映射<br><code>sudo vim /etc/hosts</code><br>加入<code>172.17.0.3(节点ip) kubia.example.com</code></p><p>接下来就可以在主机上通过<code>curl http://kubia.example.com:30010/kubia</code> 来访问服务了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607678407869-d644cd7a-dafb-4f40-a51d-52d2b15059b6.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&name=kubia.png&originHeight=212&originWidth=976&size=59226&status=done&style=none&width=976" alt="kubia.png"></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://www.jianshu.com/p/8d60ce1587e1">https://www.jianshu.com/p/8d60ce1587e1</a><br><a href="https://www.jianshu.com/p/116ce601a60f">https://www.jianshu.com/p/116ce601a60f</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django日志配置与告警</title>
    <link href="/2022/07/20/Django%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%91%8A%E8%AD%A6/"/>
    <url>/2022/07/20/Django%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%91%8A%E8%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><a name="BewR4"></a></p><h2 id="1-Django日志配置"><a href="#1-Django日志配置" class="headerlink" title="1.Django日志配置"></a>1.Django日志配置</h2><p>Django的日志配置主要通过<code>settings.py</code>中<code>LOGGING</code>配置来实现，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(asctime)s] [%(levelname)s] [%(pathname)s:%(lineno)d] [%(module)s:%(funcName)s] \n %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;celery&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(asctime)s-%(name)s-%(levelname)s-%(filename)s-%(message)s&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;require_debug_true&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(os.path.dirname(os.path.dirname(BASE_DIR)), <span class="string">&quot;logs/api.log&quot;</span>),</span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">300</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;main_logger&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>formatters</strong></li></ul><p>格式化器，这里可以指定我们需要记录在日志中的信息以及呈现在日志中的格式，可用的属性参考python logging模块的文档:<br /><a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">https://docs.python.org/3/library/logging.html#logrecord-attributes</a></p><ul><li><strong>filters</strong></li></ul><p>过滤器，可以对日志内容进行过滤，通过自定义过滤器，还可以向日志中加入我们想要的字段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogFilter</span>(logging.Filter):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义日志过滤器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, record: logging.LogRecord</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        record.xxx = xxx</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><strong>handlers</strong></li></ul><p>处理器，这里主要定义了日志的输出，可以输出到终端、文件，以及发送到第三方日志处理应用</p><ul><li><strong>loggers</strong></li></ul><p>日志器，通过指定不同的<code>handler</code>，可以根据需要让不同类型的日志输出到不同位置、不同文件等，做到业务或者代码层面的日志区分</p><p><a name="ZdaDQ"></a></p><h2 id="2-Django日志发送到ELK"><a href="#2-Django日志发送到ELK" class="headerlink" title="2.Django日志发送到ELK"></a>2.Django日志发送到ELK</h2><p>ELK可以作为一个日志存储、分析、查询的工具，我们可以将日志发送到<code>Logstash</code>，然后通过<code>Kibana</code>展示</p><ul><li><strong>python-logstash包</strong></li></ul><p>要将Django日志发送到<code>Logstash</code>，可以使用<code>python-logstash</code>这个包<br /><code>[https://github.com/vklochan/python-logstash](https://github.com/vklochan/python-logstash)</code><br />使用方法十分简单，pip安装完后，在<code>LOGGING</code>配置中加入一个<code>handlers</code>配置:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;logstash&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logstash.handler_tcp.TCPLogstashHandler&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;172.18.100.93&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;message_type&#x27;</span>: <span class="string">&#x27;logstash&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fqdn&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;tag_name&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>loggers</code>配置中加入这个<code>handler</code>即可</p><ul><li><strong>ELK部署及配置</strong></li></ul><p>ELK可以通过Docker来部署: <a href="https://github.com/deviantony/docker-elk">https://github.com/deviantony/docker-elk</a><br />部署完成后，还需要配置<code>logstash</code>，在部署根目录下的<code>logstash/config</code>文件夹下新建<code>logstash.conf</code>,配置logstash的输入、输出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> &#123;</span><br><span class="line">        beats &#123;</span><br><span class="line">                port =&gt; <span class="number">5044</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tcp &#123;</span><br><span class="line">                port =&gt; <span class="number">5000</span></span><br><span class="line">                 codec =&gt; plain&#123;</span><br><span class="line">                        charset =&gt; <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add your filters / logstash plugins configuration here</span></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts =&gt; <span class="string">&quot;elasticsearch:9200&quot;</span></span><br><span class="line">                user =&gt; <span class="string">&quot;elastic&quot;</span></span><br><span class="line">                password =&gt; <span class="string">&quot;changeme&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>告警</strong></li></ul><p>为了实现错误日志告警，可以安装插件<code>elastalert2</code>,同样可以使用Docker来安装<br /><a href="https://github.com/jertel/elastalert2">https://github.com/jertel/elastalert2</a><br /><code>elastalert2</code>的告警规则可以在<code>Rules</code>目录下新建yaml文件来定义，一个通过webhook发送告警的示例如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># From examples/rules/example_frequency.yaml</span></span><br><span class="line"><span class="attr">es_host:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">es_port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Example</span> <span class="string">rule</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">any</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">.ds-logs-generic-default-2022.07.21-000001</span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">timeframe:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line"><span class="comment">#逻辑组合</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">bool:</span></span><br><span class="line">    <span class="comment">#必须存在</span></span><br><span class="line">    <span class="attr">must:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">          <span class="attr">message:</span> <span class="string">&quot;ERROR&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件告警</span></span><br><span class="line"><span class="comment">#smtp_host: smtp.qq.com</span></span><br><span class="line"><span class="comment">#smtp_port: 465</span></span><br><span class="line"><span class="comment">#smtp_ssl: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SMTP auth</span></span><br><span class="line"><span class="comment">#smtp_auth_file: /opt/elastalert/data/smtp_auth_file.yaml</span></span><br><span class="line"><span class="comment">#email_reply_to: 464521059@qq.com</span></span><br><span class="line"><span class="comment">#from_addr: 464521059@qq.com</span></span><br><span class="line"><span class="comment">#alert:</span></span><br><span class="line"><span class="comment">#- &quot;email&quot;</span></span><br><span class="line"><span class="comment">#email:</span></span><br><span class="line"><span class="comment">#- &quot;464521059@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过HTTP POST请求发送告警</span></span><br><span class="line"><span class="attr">alert:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">http_post_url:</span> <span class="string">&quot;http://172.18.100.117:8001/api/cloudhub_robot&quot;</span></span><br><span class="line"><span class="attr">http_post_payload:</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">message</span></span><br><span class="line"><span class="attr">http_post_static_payload:</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">message</span></span><br><span class="line"><span class="attr">http_post_headers:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">Basic</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><p><a name="eH0fr"></a></p><h2 id="3-Django日志发送到sentry"><a href="#3-Django日志发送到sentry" class="headerlink" title="3.Django日志发送到sentry"></a>3.Django日志发送到sentry</h2><p><code>Sentry</code>也是一个错误监控工具，它为多种语言及框架提供了SDK，可以在程序运行时自动收集错误堆栈及上下文，发送到sentry server,然后通过sentry web来查看。<br /><code>Sentry</code>可以通过Docker安装，参考<code>[https://www.cnblogs.com/xiaochina/p/12586360.html](https://www.cnblogs.com/xiaochina/p/12586360.html)</code></p><ul><li><strong>Django配置</strong></li></ul><p>①安装完Sentry,创建一个项目之后，找到它的<code>dsn</code><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/480333/1660817299040-25afc5c9-867d-409f-99bf-2374aa3ae796.png#clientId=uf2858576-4e31-4&errorMessage=unknown%20error&from=ui&id=u8907da24&originHeight=783&originWidth=1453&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89648&status=error&style=stroke&taskId=u48ec2253-0c2d-4ed7-9afa-1f04e6ec638&title=" alt="微信截图_20220818172332.png"><br />②安装sentry的python SDK<br /><code>pip install raven</code><br />③在<code>settings</code>中加入:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">INSTALLED_APPS</span> <span class="string">=</span> <span class="string">(</span></span><br><span class="line">    <span class="string">&#x27;raven.contrib.django.raven_compat&#x27;</span><span class="string">,</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"></span><br><span class="line"><span class="string">RAVEN_CONFIG</span> <span class="string">=</span> &#123;</span><br><span class="line">    <span class="attr">&#x27;dsn&#x27;:</span> <span class="string">&#x27;http://afe50b021a4049558de19d18d40388d4:866b9b6eeb8d423f890f1a42060d2e76@sentry.vxiaocheng.com/5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④在LOGGING配置中添加sentry handler</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;sentry&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;my_filter&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;raven.contrib.django.raven_compat.handlers.SentryHandler&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tags&#x27;</span>: &#123;<span class="string">&#x27;project&#x27;</span>: <span class="string">&#x27;rdip&#x27;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><code>Sentry</code>告警</li></ul><p>打开Sentry web之后，在项目设置–&gt;警报中可以设置日志告警规则以及告警发送渠道<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/480333/1660817659056-7d01e18f-0d12-46b7-86fb-628ecf1f1287.png#clientId=uf2858576-4e31-4&errorMessage=unknown%20error&from=ui&id=u4e958376&originHeight=915&originWidth=1509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91046&status=error&style=stroke&taskId=ud384e13e-6d86-4527-bbfe-b0fe97470e8&title=" alt="微信截图_20220818181317.png"><br><a name="r0inT"></a></p><h2 id="4-uUWSGI日志格式"><a href="#4-uUWSGI日志格式" class="headerlink" title="4.uUWSGI日志格式"></a>4.uUWSGI日志格式</h2><p>uWSGI的日志格式也可以自定义，通过在配置文件<code>uwsgi.ini</code>中添加<code>logformat</code>选项即可,例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logformat = [%(ltime)] [%(addr)] [%(method):%(uri) %(status)] [pid:%(pid) wid:%(wid)] =&gt; response %(rsize)<span class="built_in">bytes</span> <span class="keyword">in</span> %(msecs)ms</span><br></pre></td></tr></table></figure><p>可用的变量见官方文档：<code>[https://uwsgi-docs.readthedocs.io/en/latest/LogFormat.html](https://uwsgi-docs.readthedocs.io/en/latest/LogFormat.html)</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab CI/CD + Docker部署</title>
    <link href="/2022/05/21/Gitlab%20CI_CD%20+%20Docker%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/05/21/Gitlab%20CI_CD%20+%20Docker%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>利用Gitlab的CI/CD功能可以很方便地进行项目的持续集成和部署，我们还可以配合Docker来进一步完善服务器部署。本文介绍了如何使用docker-swarm这个工具来部署一套Django + Mysql + Redis的项目，并且配合Gitlab的CI、CD功能，实现自动部署、滚动更新。</p><span id="more"></span><h2 id="1-Gitlab-CI-CD安装及配置"><a href="#1-Gitlab-CI-CD安装及配置" class="headerlink" title="1.Gitlab CI/CD安装及配置"></a>1.Gitlab CI/CD安装及配置</h2><ul><li>ubuntu下安装：</li></ul><p><a href="https://www.yuque.com/docs/share/cf815454-54d0-49a0-9921-90564bd869e8?#">https://www.yuque.com/docs/share/cf815454-54d0-49a0-9921-90564bd869e8?#</a> </p><p>CentOS安装步骤也类似，不过使用yum安装gitlab-runner可能版本太低，需要更新</p><ul><li><code>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash</code></li><li><code>sudo yum -y update</code></li></ul><p>并且Git的版本也需要更新</p><ul><li><code>yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm</code></li><li><code>yum update -y git</code></li></ul><h2 id="2-Docker-swarm"><a href="#2-Docker-swarm" class="headerlink" title="2.Docker swarm"></a>2.Docker swarm</h2><h4 id="docker-swarm介绍"><a href="#docker-swarm介绍" class="headerlink" title="docker-swarm介绍"></a>docker-swarm介绍</h4><ul><li><p><a href="https://yeasy.gitbook.io/docker_practice/swarm_mode/overview">https://yeasy.gitbook.io/docker_practice/swarm_mode/overview</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>docker swarm init</code> 启用swarm，将当前主机作为管理节点（管理节点自己也是worker）<br>如果要让其他节点加入swarm集群，运行init之后提示的<code>join</code>命令即可：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1603676764667-ed921106-633a-4d96-98d0-6c14ab367e05.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&name=1234.png&originHeight=196&originWidth=1524&size=21322&status=done&style=none&width=1524" alt="1234.png"></p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4></li><li><p><code>docker node ls</code> 查看所有节点</p></li><li><p><code>docker service ls</code> 查看所有服务<code></code></p></li><li><p><code>docker service create -p 9000:9000 --mount type=bind,src=&quot;&lt;project_path&gt;&quot;,dst=&quot;&lt;container_path&gt;&quot; --replicas 3 --name &lt;service_name&gt; &lt;image&gt;:&lt;tag&gt;</code></p></li></ul><p><code>-p</code>指定端口映射，–mount指定目录挂载，<code>--replicas</code>指定任务(task)个数，即容器数量</p><ul><li><p><code>docker service update --image &lt;new_image_name&gt; &lt;service_name&gt;</code> 更新服务</p><h4 id="docker-stack"><a href="#docker-stack" class="headerlink" title="docker stack"></a>docker stack</h4></li><li><p>可以使用docker stack同时启动多个服务(service)，原理同<code>docker-compose</code>类似</p></li><li><p><code>docker stack deploy -c docker-compose.yaml &lt;stack_name&gt;</code></p></li><li><p><code>docker-compose.yaml</code>示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="comment"># 指定镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=go2home</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/conf:/etc/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/logs:/var/log/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/data:/var/lib/mysql</span></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line">    <span class="comment"># 网络和ip</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">extnetwork:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6380</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/redis/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">extnetwork:</span></span><br><span class="line">  <span class="attr">go2home:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">go2home:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/go2home/logs:/go2home/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9000</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">extnetwork:</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">extnetwork:</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></table></figure></li><li><p>注意：使用这种方式部署之后，在项目内就可以通过<code>&lt;服务名&gt;:端口</code> 的方式来访问mysql/redis了。例如使用<code>docker stack deploy -c docker-compose.yaml my_stack</code> 创建了服务之后，在<code>go2home</code>服务内就可以通过<code>my_stack_mysql:3306</code> 来访问mysql容器。这是因为docker swarm在创建服务的时候配置了虚拟ip以及DNS。</p></li></ul><p>关于docker swarm的网络问题，参考：<a href="https://www.jianshu.com/p/cacdd5ff0f14">https://www.jianshu.com/p/cacdd5ff0f14</a></p><h2 id="3-项目配置"><a href="#3-项目配置" class="headerlink" title="3. 项目配置"></a>3. 项目配置</h2><ul><li><p>在项目根目录下新建文件<code>.gitlab-ci.yml</code>,配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DEPLOY_PATH:</span> <span class="string">&quot;/root/go2home/&quot;</span>               <span class="comment"># 项目的部署路径</span></span><br><span class="line"><span class="attr">build-job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">OLD_IMAGE_ID=$(docker</span> <span class="string">images</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">go2home</span> <span class="string">|</span> <span class="string">awk</span> <span class="string">&#x27;NR==1&#123;print$3&#125;&#x27;</span><span class="string">)</span>  <span class="comment"># 获取最近一次构建的镜像ID</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$OLD_IMAGE_ID</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$CI_COMMIT_SHA</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">$CI_PROJECT_DIR/*</span> <span class="string">$DEPLOY_PATH</span>                            <span class="comment"># 将代码拷贝到部署路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$DEPLOY_PATH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NEW_IMAGE_NAME=go2home:$CI_COMMIT_SHA</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$NEW_IMAGE_NAME</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">$NEW_IMAGE_NAME</span> <span class="string">.</span>                                    <span class="comment"># 以commit ID为tag，构建新镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">service</span> <span class="string">update</span> <span class="string">--image</span> <span class="string">$NEW_IMAGE_NAME</span> <span class="string">go2home_go2home</span>        <span class="comment"># 更新服务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">-f</span> <span class="string">$OLD_IMAGE_ID</span>                                             <span class="comment"># 删除旧镜像</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">new_go2home</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下新建<code>Dockerfile</code>文件以及<code>.dockerignore</code>文件(以Django项目为例)</p></li></ul><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于python3.7.3镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统环境变量，用于在项目中区分环境</span></span><br><span class="line"><span class="keyword">ENV</span> DJANGO_ENV DOCKER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该设置确保python的标准输出实时</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go2home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独将requirements.txt作为一层，这样当requirements.txt没有变化时,build镜像会使用之前的缓存</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./requirements.txt /go2home/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加项目文件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /go2home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> python GoToHome/manage.py migrate &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">           uwsgi --ini GoToHome/docker-uwsgi.ini</span></span><br></pre></td></tr></table></figure><p>.dockerignore</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.log</span><br><span class="line">celerybeat-schedule</span><br><span class="line">uwsgi.pid</span><br></pre></td></tr></table></figure><p>此后的部署，只需要push代码到gitlab仓库，就会自动执行.gitlab-ci.yml文件中配置的步骤，更新镜像、服务</p><h2 id="4-Docker-portainer安装"><a href="#4-Docker-portainer安装" class="headerlink" title="4.Docker portainer安装"></a>4.Docker portainer安装</h2><p>portainer是一个docker的图形化管理工具，开箱即用，用来管理docker服务很方便</p><ul><li><code>docker pull portainer/portainer</code></li><li><code>docker run -d -p 8080:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /docker/portainer:/data portainer/portainer</code></li><li>创建容器后，访问<code>http://&lt;服务器ip&gt;:8080</code> 即可，初次登陆设置管理员密码</li></ul>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab CI/CD配置</title>
    <link href="/2021/10/27/Gitlab%20CI_CD%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/27/Gitlab%20CI_CD%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Gitlab有自带的CI/CD功能，只需要在项目根目录新建一个<code>.gitlab-ci.yml</code>文件，推送到仓库中，即可创建一个pipeline，并通过注册好的runner部署、运行项目</p><span id="more"></span><h2 id="1-注册gitlab-runner"><a href="#1-注册gitlab-runner" class="headerlink" title="1.注册gitlab-runner"></a>1.注册gitlab-runner</h2><p>gitlab-runner相当于gitlab代码仓库和服务器之间的中间人，当我们触发了pipelines中的任务，它就可以将代码仓库中的代码拉到服务器，执行我们配置好的脚本，从而实现自动部署</p><p>注意：为保持前后一致，所有命令都要以sudo权限运行</p><ul><li>安装</li></ul><p><code>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</code></p><p><code>sudo apt-get install gitlab-ci-multi-runner</code></p><ul><li>注册</li></ul><p><code>sudo gitlab-runner register</code></p><p>①URL以及token，去gitlab项目中的setting中复制，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1594975213918-21a88996-f654-49f4-98b0-5a0353f6505e.png#align=left&display=inline&height=829&margin=%5Bobject%20Object%5D&name=1.png&originHeight=829&originWidth=1591&size=83750&status=done&style=stroke&width=1591" alt="1.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1594975228369-c31bcdd7-0fcc-4dd8-b184-d9311fcedc50.png#align=left&display=inline&height=852&margin=%5Bobject%20Object%5D&name=2.png&originHeight=852&originWidth=957&size=76152&status=done&style=stroke&width=957" alt="2.png"><br>②tag<br>tag是作为这个gitlab-runner的标识，此后在<code>.gitlab-ci.yml</code>文件中配置的时候需要用到<br>③是否运行在没有tag的build上面<br>选<code>true</code><br>④选择执行器<br>选<code>shell</code></p><h2 id="2-启动gitlab-runner"><a href="#2-启动gitlab-runner" class="headerlink" title="2.启动gitlab-runner"></a>2.启动gitlab-runner</h2><ul><li>install</li></ul><p><code>sudo gitlab-runner install -n &quot;service_name&quot; -d /home/ubuntu -u ubuntu</code><br>-n: 服务名称<br>-u: 以哪个用户的身份执行部署脚本中的shell命令<br>-d: 工作目录（如果不指定，则默认是执行install命令时所在的路径）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1597821172707-704fcac2-f70a-418b-a37d-e81bbef039c6.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&name=1111111.png&originHeight=213&originWidth=1361&size=20018&status=done&style=none&width=1361" alt="1111111.png"></p><ul><li>start</li></ul><p><code>sudo gitlab-runner start -n &quot;service_name&quot;</code><br>这里的service_name即install时指定的名称<br>启动成功之后就可以在gitlab settings –&gt; CI/CD –&gt; Runners 下查看新增的runner,显示绿色则表示启动成功<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/480333/1597822695447-c21ffb03-172a-42e7-860d-260112b29ea6.jpeg#align=left&display=inline&height=810&margin=%5Bobject%20Object%5D&name=1597822667%281%29.jpg&originHeight=810&originWidth=1606&size=94738&status=done&style=stroke&width=1606" alt="1597822667(1).jpg"></p><h2 id="3-配置-gitlab-ci-yml"><a href="#3-配置-gitlab-ci-yml" class="headerlink" title="3.配置.gitlab-ci.yml"></a>3.配置<code>.gitlab-ci.yml</code></h2><p>关于gitlab-ci.yaml中各项配置的含义，详见：<code>https://juejin.im/post/6844904045581172744</code></p><ul><li><p>在项目根目录下新建<code>.gitlab-ci.yml</code>文件，配置构建时需要执行的一些列操作。以下是Django项目部署的一个示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DEPLOY_PATH:</span> <span class="string">&quot;/home/ubuntu/deploy/car_wash/&quot;</span>               <span class="comment"># 项目的部署路径</span></span><br><span class="line">  <span class="attr">PYTHON_PATH:</span> <span class="string">&quot;/home/ubuntu/.pyenv/versions/car_wash/bin&quot;</span>   <span class="comment"># python可执行文件(bin)的路径</span></span><br><span class="line"><span class="attr">build-job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">$CI_PROJECT_DIR/*</span> <span class="string">$DEPLOY_PATH</span>              <span class="comment"># 将gitlab-runner拉下来的代码复制到部署路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$DEPLOY_PATH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">$PYTHON_PATH/pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span>      <span class="comment"># 安装依赖</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PYTHON_PATH/python</span> <span class="string">CarWash/manage.py</span> <span class="string">migrate</span>          <span class="comment"># 执行迁移</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">supervisorctl</span> <span class="string">restart</span> <span class="string">car_wash</span>                    <span class="comment"># 使用supervisor重启服务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">supervisorctl</span> <span class="string">restart</span> <span class="string">celery</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CarWash</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">test-job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$DEPLOY_PATH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PYTHON_PATH/python</span> <span class="string">CarWash/manage.py</span> <span class="string">test</span> <span class="string">Common</span> <span class="string">--keepdb</span>  <span class="comment"># 执行测试</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CarWash</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure></li><li><p>stage</p></li></ul><p>定义一次pipeline需要执行的构建步骤，比如部署代码—&gt;执行测试—&gt;部署到生产环境；<br>每个stage可以包含多个job,同一个stage下面的job并行执行；</p><ul><li>variables</li></ul><p>变量，可以自定义一些下面job中需要用到的变量，如项目路径等；<br>gitlab也有一些系统预设的变量，比如<code>$CI_PROJECT_DIR</code> 是gitlab-runner将代码从仓库中拉下来之后存放的路径；<br>对于一些不方便写到配置文件中的私密变量（如secrect key、SSH key等），可以在gitlab的 settings–&gt;CI/CD–&gt;variables 中配置；</p><ul><li>job</li></ul><p>具体执行的构建动作，每个job必须指定对应的stage</p><ul><li>script</li></ul><p>执行的命令</p><ul><li>tags</li></ul><p>指定以哪个gitlab-runner来执行该job，这里需要和注册gitlab-runner时指定的tag对应</p><ul><li>only</li></ul><p>限定git分支</p><ul><li>environment</li></ul><p>用于定义一个job部署到的环境，定义了之后会自动创建一个环境，在gitlab的Operations –&gt; Environments 中可以看到该环境下执行的job，并进行重新部署、回滚等操作<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1599207997711-4f309391-4c1b-4abf-870e-852ab8839db2.png#align=left&display=inline&height=646&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200904162536.png&originHeight=646&originWidth=1730&size=45518&status=done&style=stroke&width=1730" alt="微信截图_20200904162536.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1599208015050-b25b578c-5f50-43d6-8d44-8d668f7d7856.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200904162612.png&originHeight=651&originWidth=1793&size=43336&status=done&style=stroke&width=1793" alt="微信截图_20200904162612.png"></p><ul><li>将<code>.gitlab-ci.yml</code> 文件推到(push)代码仓库之后，就可以发现pipeline已经创建，点击进入查看详细日志</li><li>状态为passed则表示部署成功</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1597822807524-fa71b867-e5c2-42eb-b49f-6b00edbe4a41.png#align=left&display=inline&height=779&margin=%5Bobject%20Object%5D&name=222222222.png&originHeight=779&originWidth=1782&size=51915&status=done&style=stroke&width=1782" alt="222222222.png"></p><ul><li>Vue项目部署配置示例<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DEPLOY_PATH:</span> <span class="string">&quot;/home/ubuntu/deploy/car_wash_admin/&quot;</span>               <span class="comment"># 项目的部署路径</span></span><br><span class="line"><span class="attr">build-job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$CI_PROJECT_DIR</span>                                           <span class="comment"># 进入代码目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">$CI_PROJECT_DIR/node_modules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span>                                                  <span class="comment"># 安装依赖</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span>                                                <span class="comment"># 打包构建</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">$CI_PROJECT_DIR/dist/*</span> <span class="string">$DEPLOY_PATH</span>                    <span class="comment"># 将打包完成的文件复制到部署路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sudo</span> <span class="string">nginx</span> <span class="string">-s</span> <span class="string">reload</span>                                         <span class="comment"># 重启Nginx</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">car_wash_admin_tag</span>                                           <span class="comment"># gitlab-runner tag</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span>                                                       <span class="comment"># 允许部署的分支</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prod</span>                                                     <span class="comment"># 环境名称</span></span><br></pre></td></tr></table></figure><h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><a href="https://www.jianshu.com/p/306cf4c6789a">https://www.jianshu.com/p/306cf4c6789a</a><br><a href="https://www.jianshu.com/p/2b43151fb92e">https://www.jianshu.com/p/2b43151fb92e</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins + Gitlab + Django实现持续集成</title>
    <link href="/2021/03/26/Jenkins%20+%20Gitlab%20+%20Django%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <url>/2021/03/26/Jenkins%20+%20Gitlab%20+%20Django%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>基于ubuntu18.04搭建一套持续集成、部署的系统，在本地推送(push)代码到Gitlab后，通过Gitlab的webhook触发Jenkins任务，自动拉取代码并部署到生产服务器运行。</p><h3 id="1-Jenkins搭建"><a href="#1-Jenkins搭建" class="headerlink" title="1. Jenkins搭建"></a>1. Jenkins搭建</h3><ul><li><strong>查看是否安装了java</strong></li></ul><p><code>java -version</code></p><ul><li><strong>如果没有安装java,则执行下面的命令安装</strong></li></ul><p><code>sudo apt-get install openjdk-8-jre</code></p><ul><li><p><strong>配置java环境变量，在<code>/etc/profile</code>中添加以下内容：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set jdk environment </span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/Java-8-openjdk-amd64 </span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span> </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使配置文件生效</strong></p></li></ul><p><code>source /etc/profile</code></p><ul><li><strong>安装Jenkins</strong></li><li><code>wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</code></li><li><code>sudo sh -c &#39;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#39;</code></li><li><code>sudo apt-get update</code></li><li><code>sudo apt-get install jenkins</code></li></ul><ul><li><strong>运行jenkins</strong>, 访问 <a href="http://localhost:8080/">http://localhost:8080/</a></li></ul><p><code>java -jar /usr/share/jenkins/jenkins.war</code><br>由于8080端口可能被占用，建议改端口:<br><code>vim /etc/default/jenkins</code> ,找到<code>HTTP_PORT=8080</code> 这一项，将其改为其他端口<br>然后重启<code>sudo systemctl restart jenkins</code></p><p>参考：<a href="https://blog.csdn.net/lsl520hah/article/details/102839940">https://blog.csdn.net/lsl520hah/article/details/102839940</a></p><h3 id="2-生产服务器准备-ubuntu18-04"><a href="#2-生产服务器准备-ubuntu18-04" class="headerlink" title="2. 生产服务器准备(ubuntu18.04)"></a>2. 生产服务器准备(ubuntu18.04)</h3><ul><li><p>将Django项目文件夹<code>mipin</code>拷贝到生产服务器<code>/home/ubuntu</code>路径下</p><h4 id="2-1-python安装"><a href="#2-1-python安装" class="headerlink" title="2.1 python安装"></a>2.1 python安装</h4></li><li><p>python3.7安装参考：<a href="https://zhuanlan.zhihu.com/p/62930419">https://zhuanlan.zhihu.com/p/62930419</a></p></li><li><p>python安装完成后，开始安装虚拟环境<code>virtualenv</code></p></li></ul><p><code>sudo pip3.7 install virtualenv</code><br><code>sudo pip3.7 install virtualenvwrapper</code></p><ul><li><p>配置环境变量<code>vim ~/.bashrc</code> ,加入以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3.7</span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=/home/ubuntu/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></li><li><p><code>source ~/.bashrc</code></p></li><li><p>创建名为<code>mipin</code>的虚拟环境（作为Django项目运行的虚拟环境）</p></li></ul><p><code>mkvirtualenv mipin</code><br><code>pip install -r /home/ubuntu/mipin/requirements.txt</code></p><h4 id="2-2-部署Django项目"><a href="#2-2-部署Django项目" class="headerlink" title="2.2 部署Django项目"></a>2.2 部署Django项目</h4><p>这里使用uwsgi来运行Django项目，并通过supervisor来管理进程<br>详见：<a href="https://www.yuque.com/docs/share/2ccfaa59-827c-4549-9a6e-1c214c02c2b6?#">https://www.yuque.com/docs/share/2ccfaa59-827c-4549-9a6e-1c214c02c2b6?#</a> 《Supervisor使用》</p><h3 id="3-Jenkins及Gitlab配置"><a href="#3-Jenkins及Gitlab配置" class="headerlink" title="3. Jenkins及Gitlab配置"></a>3. Jenkins及Gitlab配置</h3><h4 id="3-1-安装jenkins插件"><a href="#3-1-安装jenkins插件" class="headerlink" title="3.1 安装jenkins插件"></a>3.1 安装jenkins插件</h4><ul><li>需要安装的插件有<code>Gitlab Hook</code>、 <code>Build Authorization Token Root</code> 、<code>Publish Over SSH</code>、 <code>Gitlab Authentication</code>、 <code>Gitlab</code> 、 <code>Git Parameter</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828951202-5ad3ebf3-ca8c-4094-b89d-6d8561804df0.png?x-oss-process=image%2Fresize%2Cw_746" alt="1.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828973801-7484a035-641b-4ae2-9e4e-49073f690bd8.png?x-oss-process=image%2Fresize%2Cw_746" alt="2.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828993629-bdcb0ae6-583c-4f6c-a4f5-1f64ce770d46.png#align=left&display=inline&height=738&margin=%5Bobject%20Object%5D&name=3.png&originHeight=847&originWidth=856&size=62473&status=done&style=stroke&width=746" alt="3.png"></p><ul><li>安装完插件，重启jenkins</li></ul><h4 id="3-2-配置SSH密钥"><a href="#3-2-配置SSH密钥" class="headerlink" title="3.2 配置SSH密钥"></a>3.2 配置SSH密钥</h4><ul><li>首先在jenkins所在的主机上生成一对SSH密钥</li></ul><p><code>ssh-keygen -t rsa -P &#39;&#39;</code><br>执行这条命令，会在<code>~/.ssh</code>目录下创建2个文件: <code>id_rsa</code> (私钥) 、<code>id_rsa.pub</code> (公钥)</p><ul><li>然后将公钥发送到需要部署代码的主机</li></ul><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;IP&gt;</code> <IP>即需要部署代码的目标主机的ip<br>之后在jenkins所在主机上直接使用<code>ssh &lt;IP&gt;</code> 看是否能免密码登录到目标主机<br>若还有问题请参考：<a href="https://www.cnblogs.com/jager/p/5986563.html">https://www.cnblogs.com/jager/p/5986563.html</a></p><ul><li>将私钥以及SSH主机配置到jenkins系统设置中</li></ul><p>打开系统设置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583829985077-c86998ae-ad86-42dc-ac6b-488fe094e3c2.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=4.png&originHeight=735&originWidth=974&size=75785&status=done&style=stroke&width=746" alt="4.png"><br>复制私钥内容填入<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830248101-93403417-4ee7-4cc1-af1a-02f08a915d7e.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=5.png&originHeight=333&originWidth=1559&size=35133&status=done&style=stroke&width=746" alt="5.png"><br>添加目标服务器（点击Add）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830601295-27cab8d0-193b-4193-a3b0-d89c73ff80ed.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&name=6.png&originHeight=343&originWidth=1205&size=23845&status=done&style=stroke&width=746" alt="6.png"><br>（如果需要配置多台服务器，同样按上面方法将jenkins所在主机的公钥发到目标服务器，再到这里点击Add添加即可）<br>点击save保存</p><h4 id="3-3-新建jenkins项目"><a href="#3-3-新建jenkins项目" class="headerlink" title="3.3 新建jenkins项目"></a>3.3 新建jenkins项目</h4><ul><li>新建项目</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830970033-db9c5bae-6a33-415b-9830-ddc5cd164b86.png#align=left&display=inline&height=574&margin=%5Bobject%20Object%5D&name=7.png&originHeight=574&originWidth=381&size=22969&status=done&style=stroke&width=381" alt="7.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583831000929-b495b4b5-d5de-438c-be80-ba99854e8194.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=8.png&originHeight=739&originWidth=1300&size=81736&status=done&style=stroke&width=746" alt="8.png"></p><ul><li>配置项目</li></ul><p>点击Add添加Git认证密钥<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583832896451-4e9bcb15-9972-4ce7-ba92-3703b27c2186.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&name=9.png&originHeight=545&originWidth=1462&size=34995&status=done&style=none&width=1462" alt="9.png"><br>复制自己开发电脑的私钥到这里（前提是已经在Gitlab上添加了自己的公钥）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583833269657-a234b492-5cc2-426f-a48c-9847d533e022.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=10.png&originHeight=690&originWidth=1431&size=48284&status=done&style=stroke&width=746" alt="10.png"></p><ul><li>如何在Gitlab上添加公钥</li></ul><p>点击Gitlab右上角个人中心的Settings进入设置页面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583833629109-956ca706-a023-4b46-a14b-bb2ba49b7806.png#align=left&display=inline&height=378&margin=%5Bobject%20Object%5D&name=11.png&originHeight=796&originWidth=1571&size=59650&status=done&style=stroke&width=746" alt="11.png"></p><ul><li>配置build triggers（记录url以及secret token,用于后面Gitlab中webhook的配置）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834522906-50d40cce-81c3-4253-b007-d656079d956a.png#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&name=12.png&originHeight=627&originWidth=1005&size=40222&status=done&style=stroke&width=746" alt="12.png"><br>点击Advanced<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834550396-889bcc55-30d8-4f7d-8365-46f2ee5a763d.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=13.png&originHeight=392&originWidth=1010&size=25759&status=done&style=stroke&width=746" alt="13.png"></p><ul><li>配置部署参数</li></ul><p>在部署的时候，有时可能需要配置一些可变参数，这些参数能够在后续执行部署脚本（Exec command）的时候获取到<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1608516530013-3035fc36-905b-4148-9c05-8691021dcd8e.png#align=left&display=inline&height=875&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201221100828.png&originHeight=875&originWidth=1064&size=43899&status=done&style=none&width=1064" alt="微信截图_20201221100828.png"></p><ul><li>配置构建步骤</li></ul><p>这里同样可以配置多个服务器，点击Add server添加即可<br>另外，建议将Advanced中Exec timeout(命令执行的超时时间)调整大一点  ， 按照下图配置</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834823283-e0ab6c91-6d17-4a1b-ae02-d90a43f2ba04.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&name=14.png&originHeight=736&originWidth=1441&size=63525&status=done&style=stroke&width=746" alt="14.png"><br>Exec command一栏即代码传输到服务器之后需要执行的构建步骤，上图是一个简单的示例。实际生产中，我们是使用supervisor来管理进程，并且还需要进行代码备份，以方便后续回滚，一个完整的脚本如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $Status  in</span><br><span class="line">  Deploy)</span><br><span class="line">    echo &quot;Status:$Status&quot;</span><br><span class="line">    bak_path=&quot;/home/ubuntu/bak/mipin/$&#123;BUILD_NUMBER&#125;&quot;      #创建每次要备份的目录</span><br><span class="line">    if [ -d $bak_path ];</span><br><span class="line">    then</span><br><span class="line">        echo &quot;The files is already  exists &quot;</span><br><span class="line">    else</span><br><span class="line">        sudo mkdir -p $bak_path</span><br><span class="line">    fi</span><br><span class="line">    \sudo cp -rf /home/ubuntu/mipin/* $bak_path        #将项目备份到相应目录,覆盖已存在的目标</span><br><span class="line">    sudo /home/ubuntu/.virtualenvs/mipin/bin/pip install -r /home/ubuntu/mipin/requirements.txt</span><br><span class="line">    sudo supervisorctl restart mipin</span><br><span class="line">    echo &quot;Completing!&quot;</span><br><span class="line">    ;;</span><br><span class="line">  Rollback)</span><br><span class="line">      echo &quot;Status:$Status&quot;</span><br><span class="line">      echo &quot;Version:$Version&quot;</span><br><span class="line">      cd /home/ubuntu/bak/mipin/$Version            #进入备份目录</span><br><span class="line">      \sudo cp -rf ./* /home/ubuntu/mipin/       #将备份拷贝到程序打包目录中</span><br><span class="line">      sudo supervisorctl restart mipin</span><br><span class="line">      ;;</span><br><span class="line">  *)</span><br><span class="line">  exit</span><br><span class="line">      ;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除旧的代码</span></span><br><span class="line">ReservedNum=5  #保留文件数</span><br><span class="line">FileDir=/home/ubuntu/bak/mipin</span><br><span class="line">date=$(date &quot;+%Y%m%d-%H%M%S&quot;)</span><br><span class="line"></span><br><span class="line">cd $FileDir   #进入备份目录</span><br><span class="line">FileNum=$(ls -l | grep &#x27;^d&#x27; | wc -l)   #当前有几个文件夹，即几个备份</span><br><span class="line"></span><br><span class="line">while(( $FileNum &gt; $ReservedNum))</span><br><span class="line">do</span><br><span class="line">    OldFile=$(ls -rt | head -1)         #获取最旧的那个备份文件夹</span><br><span class="line">    echo  $date &quot;Delete File:&quot;$OldFile</span><br><span class="line">    sudo rm -rf $FileDir/$OldFile</span><br><span class="line">    let &quot;FileNum--&quot;</span><br><span class="line">done </span><br></pre></td></tr></table></figure><h4 id="3-4-Gitlab配置webhook"><a href="#3-4-Gitlab配置webhook" class="headerlink" title="3.4 Gitlab配置webhook"></a>3.4 Gitlab配置webhook</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835155725-e1fd4754-6815-4616-af55-702f4beb2447.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=15.png&originHeight=895&originWidth=1574&size=77341&status=done&style=stroke&width=746" alt="15.png"><br>测试<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835253463-46417bb9-70b7-4870-9b42-c8d5414615e7.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=16.png&originHeight=473&originWidth=832&size=32858&status=done&style=stroke&width=746" alt="16.png"></p><h4 id="3-5-如何查看部署结果"><a href="#3-5-如何查看部署结果" class="headerlink" title="3.5 如何查看部署结果"></a>3.5 如何查看部署结果</h4><p>做完以上步骤，可以尝试在本地push代码到Gitlab，然后登陆Jenkins查看部署结果<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835612136-db25d301-2a62-4cc3-8162-31f48d14d8ec.png#align=left&display=inline&height=721&margin=%5Bobject%20Object%5D&name=17.png&originHeight=778&originWidth=805&size=63084&status=done&style=stroke&width=746" alt="17.png"><br>点击console output查看控制台输出<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835595912-9860a832-5d31-4db3-8d17-87dd04c3ecaa.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&name=18.png&originHeight=875&originWidth=1534&size=94438&status=done&style=stroke&width=746" alt="18.png"></p><h4 id="3-6-回滚"><a href="#3-6-回滚" class="headerlink" title="3.6 回滚"></a>3.6 回滚</h4><p>由于在配置时加入了构建参数，因此我们可以在手动构建的时候根据情况选择<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1608519958808-ebb8f773-de75-4975-96c4-5fb408c71ee4.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&name=jenkins222.png&originHeight=564&originWidth=815&size=46029&status=done&style=stroke&width=815" alt="jenkins222.png"></p><h3 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h3><p>Ubuntu18.04安装Jenkins ： <a href="https://blog.csdn.net/lsl520hah/article/details/102839940">https://blog.csdn.net/lsl520hah/article/details/102839940</a><br>Gitlab + Jenkins实现自动部署：<a href="https://blog.51cto.com/bigboss/2129477">https://blog.51cto.com/bigboss/2129477</a></p>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Supervisor部署Django项目</title>
    <link href="/2020/12/22/Supervisor%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/12/22/Supervisor%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>supervisor是一个python开发的、通用的进程监控、管理工具，可以将一个普通的命令行进程变为后台daemon,并且监控进程状态，异常自动重启。相较于nohup的方式，这种部署方式使用起来更方便简洁，并且运行也更稳定。</p><span id="more"></span><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p><code>sudo apt-get install -y supervisor</code></p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><p><code>cd /etc/supervisor/conf.d/</code><br><code>sudo vim mipin.conf</code></p><ul><li><p>uwsgi启动配置示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:go2home]</span><br><span class="line">directory = /home/ubuntu/go2home/GoToHome ;程序的启动目录</span><br><span class="line"><span class="built_in">command</span>= /home/ubuntu/.pyenv/versions/go2home/bin/uwsgi --ini uwsgi.ini ;启动命令</span><br><span class="line">autostart = <span class="literal">true</span>     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line">startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line">autorestart = <span class="literal">true</span>   ; 程序异常退出后自动重启</span><br><span class="line">startretries = 3     ; 启动失败自动重试次数，默认是 3</span><br><span class="line">user = ubuntu          ; 用哪个用户启动</span><br><span class="line">redirect_stderr = <span class="literal">true</span>  ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line">stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB</span><br><span class="line">stdout_logfile_backups = 20     ; stdout 日志文件备份数</span><br><span class="line">;stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录(supervisord 会自动创建日志文件)</span><br><span class="line">stdout_logfile = /home/ubuntu/go2home/logs/stdout.log</span><br><span class="line">;然后确保杀死主进程后，子进程也可以停止</span><br><span class="line">stopasgroup=<span class="literal">true</span></span><br><span class="line">killasgroup=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>daphne启动配置示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:mipin]</span><br><span class="line">directory=/home/ubuntu/mipin/MiPin</span><br><span class="line"><span class="built_in">command</span>=/home/ubuntu/.virtualenvs/mipin/bin/daphne -b 127.0.0.1 -p 8090 --proxy-headers MiPin.asgi:application</span><br><span class="line">autostart=<span class="literal">false</span></span><br><span class="line">autorestart=<span class="literal">false</span></span><br><span class="line">stdout_logfile=/home/ubuntu/mipin/logs/out.log</span><br><span class="line">loglevel=debug</span><br><span class="line">redirect_stderr=<span class="literal">true</span></span><br><span class="line">[supervisord]</span><br></pre></td></tr></table></figure></li><li><p>启动项目:</p></li></ul><p><code>sudo supervisord -c mipin.conf</code></p><h2 id="3-supervisor基本操作"><a href="#3-supervisor基本操作" class="headerlink" title="3.supervisor基本操作"></a>3.supervisor基本操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停止某一个进程，program_name 为 [program:x] 里的 x</span><br><span class="line">supervisorctl stop program_name</span><br><span class="line"># 启动某个进程</span><br><span class="line">supervisorctl start program_name</span><br><span class="line"># 重启某个进程</span><br><span class="line">supervisorctl restart program_name</span><br><span class="line"># 结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)</span><br><span class="line">supervisorctl stop groupworker:</span><br><span class="line"># 结束 groupworker:name1 这个进程 (start，restart 同理)</span><br><span class="line">supervisorctl stop groupworker:name1</span><br><span class="line"># 停止全部进程，注：start、restart、stop 都不会载入最新的配置文件</span><br><span class="line">supervisorctl stop all</span><br><span class="line"># 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程</span><br><span class="line">supervisorctl reload</span><br><span class="line"># 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4.问题"></a>4.问题</h2><ul><li><code>error: &lt;class &#39;socket.error&#39;&gt;, [Errno 2] No such file or directory: file: /usr/lib/python2.7/socket.py line: 228</code></li></ul><p>使用命令 <code>supervisord -c /etc/supervisor/supervisord.conf</code>启动<br>查看状态   <code>sudo supervisorctl status</code></p><ul><li>权限不足</li></ul><p><code>sudo vim /etc/supervisor/supervisord.conf</code><br>在<code>[unix_http_server]</code> 和 <code>[unix_http_server]</code> 2处配置下，加入：<br>username=name<br>password=password</p><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5.参考链接"></a>5.参考链接</h2><p><a href="https://www.cnblogs.com/xiao987334176/p/11329923.html">https://www.cnblogs.com/xiao987334176/p/11329923.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>supervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose启动Mysql和Redis</title>
    <link href="/2020/12/21/docker-compose%E5%90%AF%E5%8A%A8Mysql%20&amp;%20Redis/"/>
    <url>/2020/12/21/docker-compose%E5%90%AF%E5%8A%A8Mysql%20&amp;%20Redis/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了如何使用Docker快速在本地部署一套Mysql + Redis</p><span id="more"></span><h3 id="1-创建文件夹、下载Redis配置文件"><a href="#1-创建文件夹、下载Redis配置文件" class="headerlink" title="1.创建文件夹、下载Redis配置文件"></a>1.创建文件夹、下载Redis配置文件</h3><p><code>mkdir -p /docker/mysql /docker/redis</code><br><code>cd /docker/redis</code><br><code>wget http://download.redis.io/redis-stable/redis.conf</code></p><h3 id="2-修改Redis配置文件"><a href="#2-修改Redis配置文件" class="headerlink" title="2.修改Redis配置文件"></a>2.修改Redis配置文件</h3><p><code>vim redis.conf</code><br>修改以下配置以允许redis远程连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># bind 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="3-下载docker-compose"><a href="#3-下载docker-compose" class="headerlink" title="3.下载docker-compose"></a>3.下载docker-compose</h3><p><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-</code>uname -s<code>-</code>uname -m<code>&gt; /usr/local/bin/docker-compose</code><br><code>sudo chmod +x /usr/local/bin/docker-compose</code></p><h3 id="4-编写docker-compose-yaml"><a href="#4-编写docker-compose-yaml" class="headerlink" title="4.编写docker-compose.yaml"></a>4.编写docker-compose.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="comment"># 指定镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定容器名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_container</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/conf:/etc/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/logs:/var/log/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/mysql/data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络和ip</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">extnetwork:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis_container</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6380</span><span class="string">:6379</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/redis/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/docker/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">extnetwork:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">extnetwork:</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></table></figure><h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5.启动"></a>5.启动</h3><p><code>docker-compose -f docker-compose.yaml up -d</code></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git简介及常用操作</title>
    <link href="/2020/02/20/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/02/20/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。</p><span id="more"></span><h2 id="1-Git基本概念"><a href="#1-Git基本概念" class="headerlink" title="1.Git基本概念"></a>1.Git基本概念</h2><p>Git是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><ul><li>工作区 (Workspace)</li></ul><p>即我们进行代码/文件的增、删、改等操作的本机目录</p><ul><li>暂存区 (Index/Stage)</li></ul><p>用来暂存被改动文件的空间。在本地修改代码后，可以通过<code>git add</code>命令将变动保存到暂存区<br>暂存区的作用：<code>commit</code>操作是原子性的，我们可以挑选自己想记录提交的内容形成一次<code>commit</code><br>     方便撤销修改<code>git checkout</code><br>     对比工作区和暂存区的文件差异<code>git diff</code></p><ul><li>本地仓库 (Repository)</li></ul><p>即项目目录下的<code>.git</code>文件夹，保存了所有和该项目有关的历史记录，<code>commit</code>的结果被保存在本地仓库中<br><code>git init</code>命令可以初始化一个git本地仓库</p><ul><li>远程仓库 (Remote)</li></ul><p>用于项目协作的远程仓库，存放在远程主机上</p><p><img src="/img/Git/1.jpg" alt="1.jpg"></p><h2 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h2><ul><li><strong>git init</strong></li></ul><p>初始化一个git本地仓库，即生成<code>.git</code>文件夹</p><ul><li><strong>git clone</strong></li></ul><p>从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。<br>克隆时，所使用的远程主机自动被命名为<code>origin</code>,可以通过<code>-o</code>参数自定义命名，例如<code>git clone -o jQuery https://github.com/jquery/jquery.git</code></p><ul><li><strong>git add</strong></li></ul><p>在工作区修改完文件，可以通过<code>git add .</code>将所有改动提交到暂存区，也可以指定个别文件，如<code>git add a.txt</code></p><ul><li><strong>git commit</strong></li></ul><p>暂存区的文件需要经过<code>git commit -m &#39;commit info&#39;</code>才会提交到本地仓库中，<code>commit</code>会生成一条版本记录</p><ul><li><strong>git push</strong></li></ul><p>推送代码到远程仓库，例如<code>git push 远程主机名 本地分支名:远程分支名</code><br>如果当前分支与远程分支存在追踪关系，则可以写成<code>git push origin</code><br>如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写<code>git push</code><br>如果当前分支与多个远程主机存在追踪关系，则可使用<code>-u</code>参数指定默认主机，如<code>git push -u origin master</code>,之后<code>git push</code>便会默认推送到<code>origin</code>主机</p><p>注意，<code>git push</code>有<code>matching</code>模式和<code>simple</code>模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用<code>matching</code>模式，之后默认<code>simple</code>模式。可以通过<code>git config</code>修改：<code>git config --global push.default simple</code></p><ul><li><strong>git pull</strong></li></ul><p>拉取远程主机的某个分支，并与本地分支合并，例如<code>git pull 远程主机名 远程分支名:本地分支名</code><br>如果需要拉取的远程分支是与当前分支合并，则可以写成<code>git pull origin master</code>,这一步相当于先执行<code>git fetch origin</code>,再执行<code>git merge origin/master</code></p><ul><li><strong>git status</strong></li></ul><p>查看文件状态</p><ul><li><strong>git log</strong></li></ul><p>查看<code>commit</code>历史</p><ul><li><strong>git branch</strong></li></ul><p><code>git branch -a</code>查看本地与远程主机的所有分支<br><code>git branch branch_name</code> 新建一个名为branch_name的分支，但仍然停留在当前分支<br><code>git checkout -b branch_name</code> 新建一个名为branch_name的分支，并切换到该分支<br><code>git branch --set-upstream local_branch remote_branch</code> 将本地分支local_branch与远程分支remote_branch建立追踪关系<br><code>git branch -d branch_name</code> 删除本地分支<br><code>git push origin --delete remote_branch</code> 删除远程分支</p><ul><li><strong>git checkout</strong></li></ul><p>拉取远程主机的分支后，可以在它的基础上新建分支，如<code>git checkout -b new_branch</code><br>使用<code>git checout branch_name</code>可以在本地将工作区切换到另一个分支<br>也可用于切换到某次commit : <code>git checkout commit_id</code></p><ul><li><strong>git remote</strong></li></ul><p>为了便于管理，每个远程主机都必须指定一个主机名，<code>git remote -v</code>可以列出所有远程主机名及其地址<br><code>git remote add 主机名 项目地址</code> 用于添加远程主机<br><code>git remote rm 主机名</code> 用于删除远程主机<br><code>git remote rename 原主机名 新主机名</code> 可以重命名远程主机</p><ul><li><strong>git reset</strong></li></ul><p><code>git reset</code>可以重置当前分支到指定<code>commit</code>,有3种模式：<code>mixed</code>、<code>soft</code>、<code>hard</code><br><code>git reset --mixed commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset --soft commit_id</code>：重置当前分支的指针为指定commit，但保持暂存区和工作区不变<br><code>git reset --hard commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)</p><p><img src="/img/Git/2.png" alt="2.png"></p><ul><li><strong>git tag</strong></li></ul><p>在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.<br><code>git tag</code> 查看所有标签<br><code>git tag -a tag_name -m &quot;tag description&quot;</code> 给当前分支打上名称为tag_name的标签，描述为”tag description”<br><code>git push origin tag_name</code> 推送指定tag到远程<br><code>git push origin --tags</code> 推送所有tag到远程<br><code>git tag -d tag_name</code> 删除指定tag</p><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><ul><li><strong>gitignore</strong></li></ul><p>有时项目中有些文件不需要放入远程仓库，可以创建一个<code>.gitignore</code>文件来配置推送时需要忽略的文件，例如：<br>*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件<br>.idea/        忽略.idea文件夹</p><ul><li><strong>配置公钥</strong></li></ul><p>如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例<br>– 生成公钥<br><code>ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</code><br>– 查看公钥并复制<br><code>cat ~/.ssh/id_rsa.pub</code><br>– 将公钥添加到Gitlab<br>Settings &gt;&gt; SSH Keys</p><p><img src="/img/Git/3.png" alt="3.png"></p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><p>Git原理入门： <a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a><br>Git常用命令清单：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>Git reset三种模式：<a href="https://www.jianshu.com/p/c2ec5f06cf1a">https://www.jianshu.com/p/c2ec5f06cf1a</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用总结</title>
    <link href="/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker使用总结"><a href="#Docker使用总结" class="headerlink" title="Docker使用总结"></a>Docker使用总结</h1><p>Docker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>镜像 image</strong></li></ul><p>Docker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行<code>docker search python</code>就可以看到各种python镜像。<br><img src="/img/Docker/1.png" alt="1.png"><br>实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。</p><p>要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行<code>docker pull python</code>就可以直接拉取一个官方python镜像，再执行<code>docker images</code>就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。<br><img src="/img/Docker/2.png" alt="2.png"></p><ul><li><strong>容器 container</strong></li></ul><p>有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行<code>docker ps -a</code>或者<code>docker container ls -a</code>就可以看到所有正在运行或不在运行的容器：<br><img src="/img/Docker/3.png" alt="3.png"></p><p>我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，<code>IMAGE</code>一栏表示当前容器是基于哪个镜像创建的；<code>COMMAND</code>代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；<code>PORTS</code>则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个<code>nginx</code>应用绑定<code>80</code>端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问<code>http://宿主机ip:80</code>将相当于访问<code>nginx</code>应用了。</p><p>关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用<code>docker run -xxx xxx image_name</code>创建容器，常用的一些参数如下：</p><p>–后台运行<br>通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上<code>-d</code>参数</p><p>– 重新启动<br>通过<code>--restart=always</code>的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：<br><code>no</code>:容器退出时不要自动重启（默认值）<br><code>on-failure[:max-retries]</code>:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数<br><code>always</code>:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器<br><code>unless-stopped</code>:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p><p>– root权限<br>正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上<code>--privileged=true</code>来赋予容器真正root权限</p><p>– 文件挂载<br>文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了</p><p>– 指定ip<br>docker容器启动后，宿主机默认ip为<code>172.17.0.1</code>，启动的容器按照时间顺序绑定ip,例如<code>172.17.0.2</code>，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行<code>docker network create --subnet=192.168.0.0/16 staticnet</code>创建一个名为staticnet的私有网络，网段为<code>192.168.0.0/16</code>,之后在创建容器时，就可以通过<code>--net staticnet --ip 192.168.0.2</code>来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。</p><ul><li><strong>仓库 repository</strong></li></ul><p>Docker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：</p><ul><li><strong>docker commit的方式</strong></li></ul><p>–在获取了一个基础镜像后，我们可以基于它启动一个容器，如<code>docker run -itd --name python_container python /bin/bash</code>命令创建并启动一个python容器：<br><img src="/img/Docker/6.png" alt="6.png"></p><p>查看容器<br><img src="/img/Docker/4.png" alt="4.png"></p><p>–随后执行<code>docker exec -it python_container /bin/bash</code>进入容器，我们可以在容器中安装依赖环境，例如将项目中的<code>requirements.txt</code>放入容器后执行<code>pip install -r requirements.txt</code>，执行完毕，退出容器</p><p>–最后，通过<code>docker commit python_container new_python_image</code>命令将安装好依赖的python容器打包成一个名为<code>new_python_image</code>的镜像，此时通过<code>docker images</code>就可以看到新的镜像了.<br>提交镜像:<br><img src="/img/Docker/5.png" alt="5.png"></p><p>查看制作好的镜像:<br><img src="/img/Docker/7.png" alt="7.png"></p><ul><li><strong>Dockerfile的方式</strong></li></ul><p>通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。</p><p>Dockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>下面是一个简单的Dockerfile示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基于python3.6.8镜像</span><br><span class="line">FROM python:3.6.8</span><br><span class="line"></span><br><span class="line"># 复制Django项目所需的依赖文件清单到容器中的/目录下</span><br><span class="line">COPY requirements.txt /</span><br><span class="line"></span><br><span class="line"># 安装项目所需的python依赖</span><br><span class="line">RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</span><br></pre></td></tr></table></figure><p>注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过<code>docker build -t image_name .</code>开始制作镜像，等待完成即可</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>创建容器最常见的方式是通过<code>docker run</code>命令，详细参数可参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><p>当我们有多个容器需要创建并配置时，可以使用<code>docker-compose</code>工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker_compose.yaml 配置实例</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">nginx:</span> </span><br><span class="line">        <span class="comment"># 指定镜像</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 指定容器名称</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">nginx_container</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 端口映射</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 文件挂载路径</span></span><br><span class="line">        <span class="attr">volumes:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">/DJANGO_PROJECT:/DJANGO_PROJECT</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 网络和ip</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="attr">extnetwork:</span> </span><br><span class="line">                <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 启动后指定的命令</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">nginx</span> <span class="string">-g</span> <span class="string">&#x27;daemon off;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">    <span class="attr">extnetwork:</span> </span><br><span class="line">        <span class="attr">ipam:</span> </span><br><span class="line">            <span class="attr">config:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></table></figure><p>（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）</p><p>编写完docker_compose.yaml文件，就可以在该文件路径下执行<code>docker-compose up -d .</code>,一键创建、启动容器。</p><h2 id="参考及链接"><a href="#参考及链接" class="headerlink" title="参考及链接"></a>参考及链接</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/23599229">https://zhuanlan.zhihu.com/p/23599229</a></p><p>Docker入门介绍及常用命令：<a href="https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7">https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&amp;mid=2247488151&amp;idx=1&amp;sn=b65d355055746b8720c0a989b704666a&amp;chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&amp;ascene=1&amp;uin=NjE4ODY0Mzg0&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7</a></p><p>使用Docker部署一套Nginx + uWSGI + Django的范例：<a href="https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/">https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Nginx + uWSGI + Django实践</title>
    <link href="/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.</p><span id="more"></span><p>阅读前需要对一些基本技术有所了解，以下仅供参考：</p><p>Docker:  <a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a><br> <a href="https://zhuanlan.zhihu.com/p/23599229">https://zhuanlan.zhihu.com/p/23599229</a><br>Nginx、uWSGI：<a href="https://blog.csdn.net/weixin_40907382/article/details/80824167">https://blog.csdn.net/weixin_40907382/article/details/80824167</a></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看centos系统版本，内核版本要求不低于3.10</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新yum</span></span><br><span class="line">sudo yum -y update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装需要的软件包</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置yum源</span></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看仓库中所有docker版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择其中一个版本安装</span></span><br><span class="line">yum -y install docker-ce-18.06.3.ce</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Docker服务，并设置为开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker-compose工具（用于容器编排）</span></span><br><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>Nginx：可直接从docker hub中拉取，执行<code>docker pull nginx</code><br>Python：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：<code>docker pull python:3.6.8</code></p><p>接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用<code>docker commit</code>打包为镜像，但这样做有一些坏处：<br>在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用<code>docker commit</code>制作镜像，会导致镜像越来越臃肿；其次，由于使用<code>docker commit</code>制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。<br>因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：<a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a>，一个简单的Dockerfile如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于python3.6.8镜像</span></span><br><span class="line">FROM python:3.6.8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制Django项目所需的依赖文件清单到容器中</span></span><br><span class="line">COPY requirements.txt /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建uwsgi软链接</span></span><br><span class="line">RUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像制作完成，就可以开始创建容器了，可以直接使用<code>docker run</code>命令来创建，也可以使用<code>docker-compose</code>工具，下面首先介绍<code>docker run</code>的方式：</p><p>Nginx: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx</span><br></pre></td></tr></table></figure><p>uWSGI：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</span><br></pre></td></tr></table></figure><p>参数解释：<br><code>-it</code>：让Docker分配一个伪终端,并绑定到容器的标准输入上<br><code>--name</code>：指定容器的名称<br><code>--privileged</code>：让容器内的root用户拥有真正root权限<br><code>-p</code>：指定端口映射，将宿主机的端口映射到容器端口<br><code>-v</code>：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器<br>  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。<br><code>--net</code>：指定容器所在的网段（需要提前创建一个网段）<br><code>--ip</code>：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动<br><code>--restart</code>：在容器退出时总是重启容器，保证容器始终运行<br><code>-d</code>：让容器在后台运行</p><h2 id="使用docker-compose工具"><a href="#使用docker-compose工具" class="headerlink" title="使用docker-compose工具"></a>使用docker-compose工具</h2><p>使用<code>docker run</code>命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个<code>docker_compose.yaml</code>文件，然后通过<code>docker-compose up -d .</code>命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services: </span><br><span class="line">    nginx: </span><br><span class="line">    # 指定镜像</span><br><span class="line">        image: nginx</span><br><span class="line">        </span><br><span class="line">        # 指定容器名称</span><br><span class="line">        container_name: nginx_container</span><br><span class="line">        </span><br><span class="line">        # 端口映射</span><br><span class="line">        ports: </span><br><span class="line">            - 8080:8080</span><br><span class="line">            </span><br><span class="line">        # 文件挂载路径</span><br><span class="line">        volumes: </span><br><span class="line">            - /DJANGO_PROJECT:/DJANGO_PROJECT</span><br><span class="line">            - /nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">            </span><br><span class="line">        # 网络和ip</span><br><span class="line">        networks: </span><br><span class="line">            extnetwork: </span><br><span class="line">                ipv4_address: 192.168.0.2</span><br><span class="line">                </span><br><span class="line">        # 启动后指定的命令</span><br><span class="line">        command: nginx -g &#x27;daemon off;&#x27;</span><br><span class="line">        </span><br><span class="line">        privileged: true</span><br><span class="line">        restart: always</span><br><span class="line">    </span><br><span class="line">    uwsgi:</span><br><span class="line">        container_name: uwsgi_container</span><br><span class="line">        ports: </span><br><span class="line">            - 8090:8090</span><br><span class="line">        volumes:</span><br><span class="line">            - /DJANGO_PROJECT:/DJANGO_PROJECT</span><br><span class="line">            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages</span><br><span class="line">        networks:</span><br><span class="line">            extnetwork: </span><br><span class="line">                ipv4_address: 192.168.0.3</span><br><span class="line">        privileged: true</span><br><span class="line">        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</span><br><span class="line">        restart: always        </span><br><span class="line"></span><br><span class="line">networks: </span><br><span class="line">    extnetwork: </span><br><span class="line">        ipam: </span><br><span class="line">            config: </span><br><span class="line">            - subnet: 192.168.0.0/16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：Nginx容器的启动命令是<code>nginx -g &#39;daemon off;&#39;</code>，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上<code>daemon off</code>参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Docker</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Orthanc + OHIF 搭建DICOM web viewer</title>
    <link href="/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/"/>
    <url>/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/</url>
    
    <content type="html"><![CDATA[<p>常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server <code>Orhtanc</code>以及DICOM web viewer <code>OHIF viewer</code>搭建一套DICOM阅片系统。</p><span id="more"></span><h2 id="Orthanc"><a href="#Orthanc" class="headerlink" title="Orthanc"></a>Orthanc</h2><p>Orthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。</p><p>关于Orthanc的使用可以参考其官方文档：<br><a href="https://book.orthanc-server.com/index.html">https://book.orthanc-server.com/index.html</a></p><p>Orthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：</p><ul><li>查看镜像</li></ul><p><code>docker search orthanc</code></p><p><img src="https://s2.ax1x.com/2020/01/08/lgt2jJ.png" alt="lgt2jJ.png"></p><ul><li>拉取镜像(注意，只有orthanc-plugins才提供REST API)</li></ul><p><code>docker pull jodogne/orthanc-plugins</code></p><ul><li>启动容器</li></ul><p><code>mkdir /tmp/orthanc-db</code> (创建文件夹用于存放orthanc数据,即DICOM数据)<br><code>sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins</code></p><ul><li>网页查看</li></ul><p><code>http://orthanc所在的服务器ip:8042</code><br>默认账号：  orthanc<br>默认密码：  orthanc<br>可以通过Upload按钮进行文件上传页面，上传DICOM影像</p><p>至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：<a href="https://book.orthanc-server.com/users/rest.html">https://book.orthanc-server.com/users/rest.html</a></p><p>在前面创建容器时挂载的目录<code>/var/lib/orthanc/db</code>即orthanc中DICOM文件存放的路径，对应宿主机即<code>/tmp/orthanc-db/</code>.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下<br><img src="https://s2.ax1x.com/2020/01/08/lgafBj.png" alt="lgafBj.png"></p><h2 id="OHIF-Viewer"><a href="#OHIF-Viewer" class="headerlink" title="OHIF Viewer"></a>OHIF Viewer</h2><p>OHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：<a href="https://github.com/OHIF/Viewers">https://github.com/OHIF/Viewers</a></p><p>启动项目非常简单，只需要clone下来然后在项目根目录执行<code>yarn install</code>、<code>yarn run dev</code>即可（官方文档<a href="https://docs.ohif.org/">https://docs.ohif.org/</a>），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。<br>打开<code>platform/viewer/package.json</code>修改proxy的值为之前启动的Orthanc服务地址，例如<code>&quot;proxy&quot;: &quot;http://192.168.0.23:8042&quot;</code>，然后执行<code>yarn run dev:orthanc</code>即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。</p>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Orthanc</tag>
      
      <tag>OHIF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DICOM Tag中文编码问题</title>
    <link href="/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>DICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式<code>SpecificCharacterSet</code>并不支持中文.</p><span id="more"></span><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>常见的DICOM tag编码格式一般是<code>ISO_IR 100</code>，存储于<code>SpecificCharacterSet</code>（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为<code>ISO_IR 192</code>即UTF-8编码。常见的DICOM tag编码对应关系可参考：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ISO_IR 100&#x27;</span>: <span class="string">&#x27;latin_1&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO_IR 101&#x27;</span>: <span class="string">&#x27;iso8859_2&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO_IR 109&#x27;</span>: <span class="string">&#x27;iso8859_3&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO_IR 110&#x27;</span>: <span class="string">&#x27;iso8859_4&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO_IR 126&#x27;</span>: <span class="string">&#x27;iso_ir_126&#x27;</span>,  <span class="comment"># Greek</span></span><br><span class="line">   <span class="string">&#x27;ISO_IR 127&#x27;</span>: <span class="string">&#x27;iso_ir_127&#x27;</span>,  <span class="comment"># Arabic</span></span><br><span class="line">   <span class="string">&#x27;ISO_IR 138&#x27;</span>: <span class="string">&#x27;iso_ir_138&#x27;</span>,  <span class="comment"># Hebrew</span></span><br><span class="line">   <span class="string">&#x27;ISO_IR 144&#x27;</span>: <span class="string">&#x27;iso_ir_144&#x27;</span>,  <span class="comment"># Russian</span></span><br><span class="line">   <span class="string">&#x27;ISO_IR 148&#x27;</span>: <span class="string">&#x27;iso_ir_148&#x27;</span>,  <span class="comment"># Turkish</span></span><br><span class="line">   <span class="string">&#x27;ISO_IR 166&#x27;</span>: <span class="string">&#x27;iso_ir_166&#x27;</span>,  <span class="comment"># Thai</span></span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 6&#x27;</span>: <span class="string">&#x27;iso8859&#x27;</span>,  <span class="comment"># alias for latin_1 too</span></span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 13&#x27;</span>: <span class="string">&#x27;shift_jis&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 87&#x27;</span>: <span class="string">&#x27;iso2022_jp&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 100&#x27;</span>: <span class="string">&#x27;latin_1&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 101&#x27;</span>: <span class="string">&#x27;iso8859_2&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 109&#x27;</span>: <span class="string">&#x27;iso8859_3&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 110&#x27;</span>: <span class="string">&#x27;iso8859_4&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 126&#x27;</span>: <span class="string">&#x27;iso_ir_126&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 127&#x27;</span>: <span class="string">&#x27;iso_ir_127&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 138&#x27;</span>: <span class="string">&#x27;iso_ir_138&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 144&#x27;</span>: <span class="string">&#x27;iso_ir_144&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 148&#x27;</span>: <span class="string">&#x27;iso_ir_148&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 149&#x27;</span>: <span class="string">&#x27;euc_kr&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 159&#x27;</span>: <span class="string">&#x27;iso2022_jp_2&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 166&#x27;</span>: <span class="string">&#x27;iso_ir_166&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 IR 58&#x27;</span>: <span class="string">&#x27;iso_ir_58&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO_IR 192&#x27;</span>: <span class="string">&#x27;UTF8&#x27;</span>,  <span class="comment"># from Chinese example, 2008 PS3.5 Annex J p1-4</span></span><br><span class="line">   <span class="string">&#x27;GB18030&#x27;</span>: <span class="string">&#x27;GB18030&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;ISO 2022 GBK&#x27;</span>: <span class="string">&#x27;GBK&#x27;</span>,  <span class="comment"># from DICOM correction CP1234</span></span><br><span class="line">   <span class="string">&#x27;ISO 2022 58&#x27;</span>: <span class="string">&#x27;GB2312&#x27;</span>,  <span class="comment"># from DICOM correction CP1234</span></span><br><span class="line">   <span class="string">&#x27;GBK&#x27;</span>: <span class="string">&#x27;GBK&#x27;</span>,  <span class="comment"># from DICOM correction CP1234</span></span><br></pre></td></tr></table></figure><h2 id="使用SimpleITK读取DICOM-tag"><a href="#使用SimpleITK读取DICOM-tag" class="headerlink" title="使用SimpleITK读取DICOM tag"></a>使用SimpleITK读取DICOM tag</h2><p>DICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变<code>SpecificCharacterSet</code>的值为<code>ISO_IR 192</code>(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中<code>PatientName</code>并改变编码的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"></span><br><span class="line">dcm_path = <span class="string">&#x27;/path_to_dcm&#x27;</span></span><br><span class="line">dcm = sitk.ReadImage(dcm_path)</span><br><span class="line">patient_name = dcm.GetMetaData(<span class="string">&#x27;0010|0010&#x27;</span>).strip().encode(<span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;surrogateescape&quot;</span>).decode(<span class="string">&#x27;gbk&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ds = pydicom.dcmread(dcm_path)</span><br><span class="line">ds.SpecificCharacterSet = <span class="string">&#x27;ISO_IR 192&#x27;</span></span><br><span class="line">ds.PatientName = patient_name</span><br><span class="line">ds.save_as(dcm_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>DICOM</tag>
      
      <tag>pydicom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python将PDF转换为DICOM格式</title>
    <link href="/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/"/>
    <url>/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>DICOM影像通常分为三个层级：<code>Study</code>、<code>Series</code>、<code>Instance</code>，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。</p><p>DICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分<code>Pixel Data</code>字段中。</p><p>为了将PDF报告转换成DICOM格式，可以先利用<code>pdf2image</code>将PDF转换为常见的图片格式，再将图片转换为<code>bytes</code>类型数据，写入DICOM tag中的<code>Pixel Data</code>字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pydicom</span><br><span class="line"><span class="keyword">from</span> pydicom.dataset <span class="keyword">import</span> Dataset, FileDataset</span><br><span class="line"><span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_dcm</span>(<span class="params">dicom_dir</span>):</span><br><span class="line">    dicom_list = os.listdir(dicom_dir)</span><br><span class="line">    info_list = []</span><br><span class="line">    <span class="keyword">for</span> dicom <span class="keyword">in</span> dicom_list:</span><br><span class="line">        <span class="comment"># 使用pydicom读取DICOM影像信息</span></span><br><span class="line">        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))</span><br><span class="line"></span><br><span class="line">        info_dict = &#123;</span><br><span class="line">            <span class="string">&#x27;MediaStorageSOPInstanceUID&#x27;</span>: ds.file_meta.MediaStorageSOPInstanceUID,</span><br><span class="line">            <span class="string">&#x27;MediaStorageSOPClassUID&#x27;</span>: ds.file_meta.MediaStorageSOPClassUID,</span><br><span class="line">            <span class="string">&#x27;ImplementationClassUID&#x27;</span>: ds.file_meta.ImplementationClassUID,</span><br><span class="line">            <span class="string">&#x27;PatientName&#x27;</span>: ds.PatientName,</span><br><span class="line">            <span class="string">&#x27;PatientID&#x27;</span>: ds.PatientID,</span><br><span class="line">            <span class="string">&#x27;PatientSex&#x27;</span>: ds.PatientSex,</span><br><span class="line">            <span class="string">&#x27;PatientBirthDate&#x27;</span>: ds.PatientBirthDate,</span><br><span class="line">            <span class="string">&#x27;PatientAge&#x27;</span>: ds.PatientAge,</span><br><span class="line">            <span class="string">&#x27;ContentDate&#x27;</span>: ds.ContentDate,</span><br><span class="line">            <span class="string">&#x27;ContentTime&#x27;</span>: ds.ContentTime,</span><br><span class="line">            <span class="string">&#x27;SOPClassUID&#x27;</span>: ds.SOPClassUID,</span><br><span class="line">            <span class="string">&#x27;SOPInstanceUID&#x27;</span>: ds.SOPInstanceUID,</span><br><span class="line">            <span class="string">&#x27;StudyInstanceUID&#x27;</span>: ds.StudyInstanceUID,</span><br><span class="line">            <span class="string">&#x27;SeriesInstanceUID&#x27;</span>: ds.SeriesInstanceUID,</span><br><span class="line">            <span class="string">&#x27;InstanceNumber&#x27;</span>: ds.InstanceNumber,</span><br><span class="line">            <span class="string">&#x27;SeriesNumber&#x27;</span>: ds.SeriesNumber,</span><br><span class="line">        &#125;</span><br><span class="line">        info_list.append(info_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据InstanceUID排序</span></span><br><span class="line">    sort_list = <span class="built_in">sorted</span>(info_list, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;MediaStorageSOPInstanceUID&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sort_list[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_dcm</span>(<span class="params">index, img, dicom, dicom_dir</span>):</span><br><span class="line">    <span class="comment"># 用于将InstanceUID尾数加1</span></span><br><span class="line">    chguid = <span class="keyword">lambda</span> x: x.replace(x[-<span class="number">1</span>], <span class="built_in">str</span>(<span class="built_in">int</span>(x[-<span class="number">1</span>]) + index + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建临时文件名</span></span><br><span class="line">    suffix = <span class="string">&#x27;.dcm&#x27;</span></span><br><span class="line">    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name</span><br><span class="line">    <span class="comment"># filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充DICOM文件头必要信息</span></span><br><span class="line">    file_meta = Dataset()</span><br><span class="line">    file_meta.MediaStorageSOPClassUID = dicom[<span class="string">&#x27;MediaStorageSOPClassUID&#x27;</span>]</span><br><span class="line">    file_meta.MediaStorageSOPInstanceUID = chguid(dicom[<span class="string">&#x27;MediaStorageSOPInstanceUID&#x27;</span>])</span><br><span class="line">    file_meta.ImplementationClassUID = dicom[<span class="string">&#x27;ImplementationClassUID&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)</span></span><br><span class="line">    ds = FileDataset(filename_little_endian, &#123;&#125;, file_meta=file_meta, preamble=<span class="string">b&quot;\0&quot;</span> * <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入DICOM tag信息（不包含所有）</span></span><br><span class="line">    ds.PatientName = dicom[<span class="string">&#x27;PatientName&#x27;</span>]</span><br><span class="line">    ds.PatientID = dicom[<span class="string">&#x27;PatientID&#x27;</span>]</span><br><span class="line">    ds.PatientSex = dicom[<span class="string">&#x27;PatientSex&#x27;</span>]</span><br><span class="line">    ds.PatientBirthDate = dicom[<span class="string">&#x27;PatientBirthDate&#x27;</span>]</span><br><span class="line">    ds.PatientAge = dicom[<span class="string">&#x27;PatientAge&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the transfer syntax</span></span><br><span class="line">    <span class="comment"># ds.is_little_endian = True</span></span><br><span class="line">    <span class="comment"># ds.is_implicit_VR = True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入DICOM tag信息（不包含所有）</span></span><br><span class="line">    dt = datetime.datetime.now()</span><br><span class="line">    ds.ContentDate = dt</span><br><span class="line">    time_str = dt.strftime(<span class="string">&#x27;%H%M%S.%f&#x27;</span>)</span><br><span class="line">    ds.ContentTime = time_str</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成StudyUID, SeriesUID, InstanceUID</span></span><br><span class="line">    ds.SOPClassUID = dicom[<span class="string">&#x27;SOPClassUID&#x27;</span>]</span><br><span class="line">    ds.SOPInstanceUID = chguid(dicom[<span class="string">&#x27;SOPInstanceUID&#x27;</span>])</span><br><span class="line">    ds.StudyInstanceUID = dicom[<span class="string">&#x27;StudyInstanceUID&#x27;</span>]</span><br><span class="line">    ds.SeriesInstanceUID = dicom[<span class="string">&#x27;SeriesInstanceUID&#x27;</span>] + <span class="string">&#x27;.1&#x27;</span></span><br><span class="line">    ds.InstanceNumber = index + <span class="number">1</span></span><br><span class="line">    ds.SeriesNumber = <span class="built_in">str</span>(<span class="built_in">int</span>(dicom[<span class="string">&#x27;SeriesNumber&#x27;</span>]) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定影像参数</span></span><br><span class="line">    ds.Rows = img.size[<span class="number">1</span>]</span><br><span class="line">    ds.Columns = img.size[<span class="number">0</span>]</span><br><span class="line">    ds.SamplesPerPixel = <span class="number">3</span></span><br><span class="line">    ds.PhotometricInterpretation = <span class="string">&quot;RGB&quot;</span></span><br><span class="line">    ds.HighBit = <span class="number">7</span></span><br><span class="line">    ds.BitsStored = <span class="number">8</span></span><br><span class="line">    ds.BitsAllocated = <span class="number">8</span></span><br><span class="line">    ds.PixelRepresentation = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将img对象转换为bytes类型，写入PixelData字段</span></span><br><span class="line">    ds.PixelData = img.tobytes()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定TransferSyntax等信息</span></span><br><span class="line">    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian</span><br><span class="line">    ds.is_little_endian = <span class="literal">False</span></span><br><span class="line">    ds.is_implicit_VR = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存影像文件</span></span><br><span class="line">    file_name = <span class="string">&#x27;report_&#123;&#125;.dcm&#x27;</span>.<span class="built_in">format</span>(index)</span><br><span class="line">    file_path = os.path.join(dicom_dir, file_name)</span><br><span class="line">    ds.save_as(file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">pdf_path, dicom_dir</span>):</span><br><span class="line">    <span class="comment"># 将pdf转换为图片</span></span><br><span class="line">    images_list = convert_from_path(pdf_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从DICOM文件夹中读取最后一张影像的信息</span></span><br><span class="line">    dicom_info = read_dcm(dicom_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建DICOM影像并写入图片数据</span></span><br><span class="line">    <span class="keyword">for</span> index, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(images_list):</span><br><span class="line">        write_dcm(index, img, dicom_info, dicom_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pdf_path = <span class="string">&#x27;/home/ray/dcm_report/report.pdf&#x27;</span></span><br><span class="line">    dicom_dir = <span class="string">&#x27;/home/ray/dcm_report/dcm_data&#x27;</span></span><br><span class="line"></span><br><span class="line">    main(pdf_path, dicom_dir)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>DICOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SimpleITK读取DICOM</title>
    <link href="/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/"/>
    <url>/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/</url>
    
    <content type="html"><![CDATA[<p>SimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install SimpleITK</code></p><h2 id="读取DICOM影像"><a href="#读取DICOM影像" class="headerlink" title="读取DICOM影像"></a>读取DICOM影像</h2><ul><li>读取单张DICOM影像</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"></span><br><span class="line">file = sitk.ReadImage(filepath)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 图像大小</span></span><br><span class="line">file.GetSize()</span><br><span class="line"><span class="comment"># 坐标原点</span></span><br><span class="line">file.GetOrigin()</span><br><span class="line"><span class="comment"># 像素间距</span></span><br><span class="line">file.GetSpacing()</span><br><span class="line"><span class="comment"># 方向</span></span><br><span class="line">file.GetDirection()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取影像元数据(返回DICOM tags元组)</span></span><br><span class="line">file.GetMetaDataKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 像素矩阵</span></span><br><span class="line">pixel_array = sitk.GetArrayFromImage(file)</span><br></pre></td></tr></table></figure><ul><li>读取DICOM序列</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;/dicom_study_dir&quot;</span></span><br><span class="line"></span><br><span class="line">reader = sitk.ImageSeriesReader()</span><br><span class="line">seriesIDs = reader.GetGDCMSeriesIDs(path)</span><br><span class="line">dicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[<span class="number">0</span>])</span><br><span class="line">reader.SetFileNames(dicom_names)</span><br><span class="line">image = reader.Execute()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读取特定序列并保存为NIfTI格式"><a href="#读取特定序列并保存为NIfTI格式" class="headerlink" title="读取特定序列并保存为NIfTI格式"></a>读取特定序列并保存为NIfTI格式</h2><p>医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从DICOM影像中读取Tag信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tag</span>(<span class="params">dcm, key, default_value=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = dcm.GetMetaData(key).strip()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        value = default_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从DICOM study文件夹中提取需要的序列并转换</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_series</span>(<span class="params">study_dir, series_desc</span>):</span><br><span class="line">    <span class="comment"># 获取所有series id,返回一个元组</span></span><br><span class="line">    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)</span><br><span class="line">    <span class="keyword">for</span> series_id <span class="keyword">in</span> series_ids:</span><br><span class="line">        <span class="comment"># 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组</span></span><br><span class="line">        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=<span class="literal">False</span>, useSeriesDetails=<span class="literal">False</span>)</span><br><span class="line">        reader = sitk.ImageSeriesReader()</span><br><span class="line">        reader.SetFileNames(files)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            img = reader.Execute()</span><br><span class="line">        <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;The file in the series have unsupported 3 dimensions&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e):</span><br><span class="line">                img = sitk.ReadImage(files[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.error(<span class="string">&#x27;Error in reading image, dir %s, series id %s, detail message: %s&#x27;</span> % (study_dir, series_id, e))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 从当前序列取一张影像，便于读取其Tag信息                </span></span><br><span class="line">        dcm = sitk.ReadImage(files[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 获取当前序列的序列描述</span></span><br><span class="line">        series_description = get_tag(dcm, <span class="string">&#x27;0008|103e&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断是否是需要的序列</span></span><br><span class="line">        <span class="keyword">if</span> series_description == series_desc:</span><br><span class="line">            nii_name = <span class="built_in">str</span>(series_id) + <span class="string">&quot;nii.gz&quot;</span></span><br><span class="line">            <span class="comment"># 写入nii.gz文件</span></span><br><span class="line">            sitk.WriteImage(img, os.path.join(study_dir, nii_name))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>DICOM</tag>
      
      <tag>SimpleITK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django实现语言切换</title>
    <link href="/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/"/>
    <url>/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Django提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：<a href="https://djangobook-cn.readthedocs.io/en/latest/chapter19.html">https://djangobook-cn.readthedocs.io/en/latest/chapter19.html</a></p><span id="more"></span><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>首先在Django settings文件中加入中间件<code>django.middleware.locale.LocaleMiddleware</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># django语言国际化中间件</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.locale.LocaleMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>然后增加<code>LANGUAGES</code>和<code>LOCALE_PATHS</code>配置，<code>locale</code>文件夹需要手动创建：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LANGUAGES = (</span><br><span class="line">    (<span class="string">&#x27;zh-hans&#x27;</span>, <span class="string">&#x27;中文简体&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;English&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LOCALE_PATHS = (</span><br><span class="line">    os.path.join(os.path.dirname(BASE_DIR), <span class="string">&#x27;locale&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改html模板文件"><a href="#修改html模板文件" class="headerlink" title="修改html模板文件"></a>修改html模板文件</h2><ul><li><p>首先需要在每个html第一行加入以下代码，可以将它放在公共页面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% load i18n %&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要翻译的字符串上加上trans标签,例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=<span class="string">&quot;/management/language_set&quot;</span>&gt;&lt;i <span class="keyword">class</span>=<span class="string">&quot;ti-settings&quot;</span>&gt;&lt;/i&gt; &#123;% trans <span class="string">&#x27;语言设置&#x27;</span> %&#125;&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li><li><p>多次重复翻译的内容可以设置成常量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% trans <span class="string">&quot;This is the title&quot;</span> <span class="keyword">as</span> the_title %&#125;</span><br><span class="line">&lt;title&gt;&#123;&#123; the_title &#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;meta name=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;&#123;&#123; the_title &#125;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% blocktrans %&#125;This string will have &#123;&#123; value &#125;&#125; inside.&#123;% endblocktrans %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="后端视图"><a href="#后端视图" class="headerlink" title="后端视图"></a>后端视图</h2><ul><li><p>如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的<code>gettext</code>模块，代码示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext <span class="keyword">as</span> _</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_views</span>(<span class="params">request</span>):</span><br><span class="line">    response_str = _(<span class="string">&quot;中文字符串&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(response_str)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>需要注意，Django渲染模板时需要使用<code>render</code>而不是<code>render_to_response</code></p></li></ul><h2 id="JavaScript中的语言转换"><a href="#JavaScript中的语言转换" class="headerlink" title="JavaScript中的语言转换"></a>JavaScript中的语言转换</h2><ul><li><p>首先在根<code>urls.py</code>文件中的<code>urlpatterns</code>列表中添加如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^jsi18n/$&#x27;</span>, JavaScriptCatalog.as_view(packages=[<span class="string">&#x27;ProjectName&#x27;</span>]), name=<span class="string">&#x27;javascript-catalog&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>然后在模板中引入js(可放在公共页面)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;&#123;% url &#x27;javascript-catalog&#x27; %&#125;&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>gettext</code>在js中标记字符串，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">editpwd</span>(<span class="params"></span>)&#123;</span><br><span class="line">        layer.<span class="title function_">open</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="title function_">gettext</span>(<span class="string">&#x27;修改密码&#x27;</span>),</span><br><span class="line">          <span class="attr">maxmin</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">shadeClose</span>: <span class="literal">true</span>, <span class="comment">//点击遮罩关闭层</span></span><br><span class="line">          area : [<span class="string">&#x27;550px&#x27;</span> , <span class="string">&#x27;&#x27;</span>],</span><br><span class="line">          <span class="attr">content</span>:$(<span class="string">&#x27;#addsort_style&#x27;</span>),</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到</p></li></ul><h2 id="翻译文件生成与编译"><a href="#翻译文件生成与编译" class="headerlink" title="翻译文件生成与编译"></a>翻译文件生成与编译</h2><ul><li>添加完翻译的标记后，执行以下命令即可在<code>locale</code>文件夹下生成翻译文件：</li></ul><p><code>python manage.py makemessages -l en</code><br><code>python manage.py makemessages -d djangojs -l en</code></p><ul><li><p>执行成功后可以发现生成了<code>django.po</code>以及<code>djangojs.po</code>文件，然后就可以填充翻译后的字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#: DrBrain3/templates/Management/series_list.html:46</span></span><br><span class="line"><span class="comment">#: DrBrain3/templates/Users/new_psw.html:89</span></span><br><span class="line">msgid <span class="string">&quot;确认修改&quot;</span></span><br><span class="line">msgstr <span class="string">&quot;Confirm the changes&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意，有时由于识别的错乱，执行<code>python manage.py makemessages -l en</code>后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示</p></li><li><p>填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件</p></li></ul><p><code>python manage.py compilemessages</code></p><h2 id="如何切换语言"><a href="#如何切换语言" class="headerlink" title="如何切换语言"></a>如何切换语言</h2><p>Django本身提供了语言切换的功能，可参考如下方法实现：</p><ul><li><p>在项目根路由文件<code>urls.py</code>中添加切换语言的url</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^i18n/&#x27;</span>,include(<span class="string">&#x27;django.conf.urls.i18n&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>html页面中添加如下form表单</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;&#123;% url &#x27;set_language&#x27; %&#125;&quot;</span> method=<span class="string">&quot;post&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;change_language_form&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;next&quot;</span> value=<span class="string">&quot;&quot;</span>/&gt;</span><br><span class="line">&lt;select <span class="keyword">class</span>=<span class="string">&quot;change_language&quot;</span> name=<span class="string">&quot;language&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;language&quot;</span> onclick=<span class="string">&quot;changeLan()&quot;</span>&gt;</span><br><span class="line">&#123;% <span class="keyword">for</span> lang <span class="keyword">in</span> LANGUAGES %&#125;</span><br><span class="line">        &lt;option value=<span class="string">&quot;&#123;&#123; lang.0 &#125;&#125;&quot;</span>&#123;% ifequal lang<span class="number">.0</span> LANGUAGE_CODE %&#125; selected &#123;% endifequal %&#125;&gt;&#123;&#123; lang<span class="number">.1</span> &#125;&#125;&lt;/option&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>JavaScript代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.change_language&#x27;</span>).<span class="title function_">change</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    $(<span class="string">&#x27;#change_language_form&#x27;</span>).<span class="title function_">submit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>登录时记录用户选择的语言</p></li></ul><p>在用户登录的后端视图中加入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request.session[<span class="string">&#x27;_language&#x27;</span>]=<span class="string">&#x27;zh-hans&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
