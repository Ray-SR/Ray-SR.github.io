<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker使用总结</title>
    <link href="/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker使用总结"><a href="#Docker使用总结" class="headerlink" title="Docker使用总结"></a>Docker使用总结</h1><p>Docker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>镜像 image</strong></li></ul><p>Docker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行<code>docker search python</code>就可以看到各种python镜像。<br><img src="/img/Docker/1.png" srcset="/img/loading.gif" alt="1.png"><br>实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。</p><p>要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行<code>docker pull python</code>就可以直接拉取一个官方python镜像，再执行<code>docker images</code>就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。<br><img src="/img/Docker/2.png" srcset="/img/loading.gif" alt="2.png"></p><ul><li><strong>容器 container</strong></li></ul><p>有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行<code>docker ps -a</code>或者<code>docker container ls -a</code>就可以看到所有正在运行或不在运行的容器：<br><img src="/img/Docker/3.png" srcset="/img/loading.gif" alt="3.png"></p><p>我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，<code>IMAGE</code>一栏表示当前容器是基于哪个镜像创建的；<code>COMMAND</code>代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；<code>PORTS</code>则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个<code>nginx</code>应用绑定<code>80</code>端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问<code>http://宿主机ip:80</code>将相当于访问<code>nginx</code>应用了。</p><p>关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用<code>docker run -xxx xxx image_name</code>创建容器，常用的一些参数如下：</p><p>–后台运行<br>通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上<code>-d</code>参数</p><p>– 重新启动<br>通过<code>--restart=always</code>的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：<br><code>no</code>:容器退出时不要自动重启（默认值）<br><code>on-failure[:max-retries]</code>:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数<br><code>always</code>:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器<br><code>unless-stopped</code>:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p><p>– root权限<br>正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上<code>--privileged=true</code>来赋予容器真正root权限</p><p>– 文件挂载<br>文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了</p><p>– 指定ip<br>docker容器启动后，宿主机默认ip为<code>172.17.0.1</code>，启动的容器按照时间顺序绑定ip,例如<code>172.17.0.2</code>，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行<code>docker network create --subnet=192.168.0.0/16 staticnet</code>创建一个名为staticnet的私有网络，网段为<code>192.168.0.0/16</code>,之后在创建容器时，就可以通过<code>--net staticnet --ip 192.168.0.2</code>来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。</p><ul><li><strong>仓库 repository</strong></li></ul><p>Docker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：</p><ul><li><strong>docker commit的方式</strong></li></ul><p>–在获取了一个基础镜像后，我们可以基于它启动一个容器，如<code>docker run -itd --name python_container python /bin/bash</code>命令创建并启动一个python容器：<br><img src="/img/Docker/6.png" srcset="/img/loading.gif" alt="6.png"></p><p>查看容器<br><img src="/img/Docker/4.png" srcset="/img/loading.gif" alt="4.png"></p><p>–随后执行<code>docker exec -it python_container /bin/bash</code>进入容器，我们可以在容器中安装依赖环境，例如将项目中的<code>requirements.txt</code>放入容器后执行<code>pip install -r requirements.txt</code>，执行完毕，退出容器</p><p>–最后，通过<code>docker commit python_container new_python_image</code>命令将安装好依赖的python容器打包成一个名为<code>new_python_image</code>的镜像，此时通过<code>docker images</code>就可以看到新的镜像了.<br>提交镜像:<br><img src="/img/Docker/5.png" srcset="/img/loading.gif" alt="5.png"></p><p>查看制作好的镜像:<br><img src="/img/Docker/7.png" srcset="/img/loading.gif" alt="7.png"></p><ul><li><strong>Dockerfile的方式</strong></li></ul><p>通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。</p><p>Dockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><p>下面是一个简单的Dockerfile示例：</p><pre><code># 基于python3.6.8镜像FROM python:3.6.8# 复制Django项目所需的依赖文件清单到容器中的/目录下COPY requirements.txt /# 安装项目所需的python依赖RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</code></pre><p>注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过<code>docker build -t image_name .</code>开始制作镜像，等待完成即可</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>创建容器最常见的方式是通过<code>docker run</code>命令，详细参数可参考：<a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/</a></p><p>当我们有多个容器需要创建并配置时，可以使用<code>docker-compose</code>工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：</p><pre><code class="yaml"># docker_compose.yaml 配置实例version: &quot;3&quot;services:     nginx:         # 指定镜像        image: nginx        # 指定容器名称        container_name: nginx_container        # 端口映射        ports:             - 8080:8080        # 文件挂载路径        volumes:             - /DJANGO_PROJECT:/DJANGO_PROJECT            - /nginx.conf:/etc/nginx/nginx.conf        # 网络和ip        networks:             extnetwork:                 ipv4_address: 192.168.0.2        # 启动后指定的命令        command: nginx -g &#39;daemon off;&#39;        privileged: true        restart: alwaysnetworks:     extnetwork:         ipam:             config:             - subnet: 192.168.0.0/16</code></pre><p>（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）</p><p>编写完docker_compose.yaml文件，就可以在该文件路径下执行<code>docker-compose up -d .</code>,一键创建、启动容器。</p><h2 id="参考及链接"><a href="#参考及链接" class="headerlink" title="参考及链接"></a>参考及链接</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/23599229" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23599229</a></p><p>Docker入门介绍及常用命令：<a href="https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&amp;mid=2247488151&amp;idx=1&amp;sn=b65d355055746b8720c0a989b704666a&amp;chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&amp;ascene=1&amp;uin=NjE4ODY0Mzg0&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7</a></p><p>使用Docker部署一套Nginx + uWSGI + Django的范例：<a href="https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/">https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Nginx + uWSGI + Django实践</title>
    <link href="/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.</p><a id="more"></a><p>阅读前需要对一些基本技术有所了解，以下仅供参考：</p><p>Docker:  <a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a><br> <a href="https://zhuanlan.zhihu.com/p/23599229" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23599229</a><br>Nginx、uWSGI：<a href="https://blog.csdn.net/weixin_40907382/article/details/80824167" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40907382/article/details/80824167</a></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><pre><code class="shell"># 查看centos系统版本，内核版本要求不低于3.10uname -r# 更新yumsudo yum -y update# 安装需要的软件包sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置yum源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 查看仓库中所有docker版本yum list docker-ce --showduplicates | sort -r# 选择其中一个版本安装yum -y install docker-ce-18.06.3.ce# 启动Docker服务，并设置为开机启动systemctl start dockersystemctl enable docker# 测试是否安装成功docker version# 安装docker-compose工具（用于容器编排）sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></pre><h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>Nginx：可直接从docker hub中拉取，执行<code>docker pull nginx</code><br>Python：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：<code>docker pull python:3.6.8</code></p><p>接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用<code>docker commit</code>打包为镜像，但这样做有一些坏处：<br>在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用<code>docker commit</code>制作镜像，会导致镜像越来越臃肿；其次，由于使用<code>docker commit</code>制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。<br>因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：<a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a>，一个简单的Dockerfile如下：</p><pre><code class="shell"># 基于python3.6.8镜像FROM python:3.6.8# 复制Django项目所需的依赖文件清单到容器中COPY requirements.txt /# 安装依赖RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt# 创建uwsgi软链接RUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像制作完成，就可以开始创建容器了，可以直接使用<code>docker run</code>命令来创建，也可以使用<code>docker-compose</code>工具，下面首先介绍<code>docker run</code>的方式：</p><p>Nginx: </p><pre><code class="shell">docker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx</code></pre><p>uWSGI：</p><pre><code class="shell">docker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</code></pre><p>参数解释：<br><code>-it</code>：让Docker分配一个伪终端,并绑定到容器的标准输入上<br><code>--name</code>：指定容器的名称<br><code>--privileged</code>：让容器内的root用户拥有真正root权限<br><code>-p</code>：指定端口映射，将宿主机的端口映射到容器端口<br><code>-v</code>：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器<br>  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。<br><code>--net</code>：指定容器所在的网段（需要提前创建一个网段）<br><code>--ip</code>：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动<br><code>--restart</code>：在容器退出时总是重启容器，保证容器始终运行<br><code>-d</code>：让容器在后台运行</p><h2 id="使用docker-compose工具"><a href="#使用docker-compose工具" class="headerlink" title="使用docker-compose工具"></a>使用docker-compose工具</h2><p>使用<code>docker run</code>命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个<code>docker_compose.yaml</code>文件，然后通过<code>docker-compose up -d .</code>命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：</p><pre><code class="shell">version: &quot;3&quot;services:     nginx:             # 指定镜像        image: nginx        # 指定容器名称        container_name: nginx_container        # 端口映射        ports:             - 8080:8080        # 文件挂载路径        volumes:             - /DJANGO_PROJECT:/DJANGO_PROJECT            - /nginx.conf:/etc/nginx/nginx.conf        # 网络和ip        networks:             extnetwork:                 ipv4_address: 192.168.0.2        # 启动后指定的命令        command: nginx -g &#39;daemon off;&#39;        privileged: true        restart: always    uwsgi:        container_name: uwsgi_container        ports:             - 8090:8090        volumes:            - /DJANGO_PROJECT:/DJANGO_PROJECT            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages        networks:            extnetwork:                 ipv4_address: 192.168.0.3        privileged: true        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini        restart: always        networks:     extnetwork:         ipam:             config:             - subnet: 192.168.0.0/16</code></pre><p>注意：Nginx容器的启动命令是<code>nginx -g &#39;daemon off;&#39;</code>，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上<code>daemon off</code>参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Docker</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Orthanc + OHIF 搭建DICOM web viewer</title>
    <link href="/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/"/>
    <url>/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/</url>
    
    <content type="html"><![CDATA[<p>常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server <code>Orhtanc</code>以及DICOM web viewer <code>OHIF viewer</code>搭建一套DICOM阅片系统。</p><a id="more"></a><h2 id="Orthanc"><a href="#Orthanc" class="headerlink" title="Orthanc"></a>Orthanc</h2><p>Orthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。</p><p>关于Orthanc的使用可以参考其官方文档：<br><a href="https://book.orthanc-server.com/index.html" target="_blank" rel="noopener">https://book.orthanc-server.com/index.html</a></p><p>Orthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：</p><ul><li>查看镜像</li></ul><p><code>docker search orthanc</code></p><p><img src="https://s2.ax1x.com/2020/01/08/lgt2jJ.png" srcset="/img/loading.gif" alt="lgt2jJ.png"></p><ul><li>拉取镜像(注意，只有orthanc-plugins才提供REST API)</li></ul><p><code>docker pull jodogne/orthanc-plugins</code></p><ul><li>启动容器</li></ul><p><code>mkdir /tmp/orthanc-db</code> (创建文件夹用于存放orthanc数据,即DICOM数据)<br><code>sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins</code></p><ul><li>网页查看</li></ul><p><code>http://orthanc所在的服务器ip:8042</code><br>默认账号：  orthanc<br>默认密码：  orthanc<br>可以通过Upload按钮进行文件上传页面，上传DICOM影像</p><p>至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：<a href="https://book.orthanc-server.com/users/rest.html" target="_blank" rel="noopener">https://book.orthanc-server.com/users/rest.html</a></p><p>在前面创建容器时挂载的目录<code>/var/lib/orthanc/db</code>即orthanc中DICOM文件存放的路径，对应宿主机即<code>/tmp/orthanc-db/</code>.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下<br><img src="https://s2.ax1x.com/2020/01/08/lgafBj.png" srcset="/img/loading.gif" alt="lgafBj.png"></p><h2 id="OHIF-Viewer"><a href="#OHIF-Viewer" class="headerlink" title="OHIF Viewer"></a>OHIF Viewer</h2><p>OHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：<a href="https://github.com/OHIF/Viewers" target="_blank" rel="noopener">https://github.com/OHIF/Viewers</a></p><p>启动项目非常简单，只需要clone下来然后在项目根目录执行<code>yarn install</code>、<code>yarn run dev</code>即可（官方文档<a href="https://docs.ohif.org/" target="_blank" rel="noopener">https://docs.ohif.org/</a>），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。<br>打开<code>platform/viewer/package.json</code>修改proxy的值为之前启动的Orthanc服务地址，例如<code>&quot;proxy&quot;: &quot;http://192.168.0.23:8042&quot;</code>，然后执行<code>yarn run dev:orthanc</code>即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。</p>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Orthanc</tag>
      
      <tag>OHIF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DICOM Tag中文编码问题</title>
    <link href="/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>DICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式<code>SpecificCharacterSet</code>并不支持中文.</p><a id="more"></a><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>常见的DICOM tag编码格式一般是<code>ISO_IR 100</code>，存储于<code>SpecificCharacterSet</code>（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为<code>ISO_IR 192</code>即UTF-8编码。常见的DICOM tag编码对应关系可参考：</p><pre><code class="python">    &#39;ISO_IR 100&#39;: &#39;latin_1&#39;,    &#39;ISO_IR 101&#39;: &#39;iso8859_2&#39;,    &#39;ISO_IR 109&#39;: &#39;iso8859_3&#39;,    &#39;ISO_IR 110&#39;: &#39;iso8859_4&#39;,    &#39;ISO_IR 126&#39;: &#39;iso_ir_126&#39;,  # Greek    &#39;ISO_IR 127&#39;: &#39;iso_ir_127&#39;,  # Arabic    &#39;ISO_IR 138&#39;: &#39;iso_ir_138&#39;,  # Hebrew    &#39;ISO_IR 144&#39;: &#39;iso_ir_144&#39;,  # Russian    &#39;ISO_IR 148&#39;: &#39;iso_ir_148&#39;,  # Turkish    &#39;ISO_IR 166&#39;: &#39;iso_ir_166&#39;,  # Thai    &#39;ISO 2022 IR 6&#39;: &#39;iso8859&#39;,  # alias for latin_1 too    &#39;ISO 2022 IR 13&#39;: &#39;shift_jis&#39;,    &#39;ISO 2022 IR 87&#39;: &#39;iso2022_jp&#39;,    &#39;ISO 2022 IR 100&#39;: &#39;latin_1&#39;,    &#39;ISO 2022 IR 101&#39;: &#39;iso8859_2&#39;,    &#39;ISO 2022 IR 109&#39;: &#39;iso8859_3&#39;,    &#39;ISO 2022 IR 110&#39;: &#39;iso8859_4&#39;,    &#39;ISO 2022 IR 126&#39;: &#39;iso_ir_126&#39;,    &#39;ISO 2022 IR 127&#39;: &#39;iso_ir_127&#39;,    &#39;ISO 2022 IR 138&#39;: &#39;iso_ir_138&#39;,    &#39;ISO 2022 IR 144&#39;: &#39;iso_ir_144&#39;,    &#39;ISO 2022 IR 148&#39;: &#39;iso_ir_148&#39;,    &#39;ISO 2022 IR 149&#39;: &#39;euc_kr&#39;,    &#39;ISO 2022 IR 159&#39;: &#39;iso2022_jp_2&#39;,    &#39;ISO 2022 IR 166&#39;: &#39;iso_ir_166&#39;,    &#39;ISO 2022 IR 58&#39;: &#39;iso_ir_58&#39;,    &#39;ISO_IR 192&#39;: &#39;UTF8&#39;,  # from Chinese example, 2008 PS3.5 Annex J p1-4    &#39;GB18030&#39;: &#39;GB18030&#39;,    &#39;ISO 2022 GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234    &#39;ISO 2022 58&#39;: &#39;GB2312&#39;,  # from DICOM correction CP1234    &#39;GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234</code></pre><h2 id="使用SimpleITK读取DICOM-tag"><a href="#使用SimpleITK读取DICOM-tag" class="headerlink" title="使用SimpleITK读取DICOM tag"></a>使用SimpleITK读取DICOM tag</h2><p>DICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变<code>SpecificCharacterSet</code>的值为<code>ISO_IR 192</code>(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中<code>PatientName</code>并改变编码的示例：</p><pre><code class="python">import SimpleITK as sitkdcm_path = &#39;/path_to_dcm&#39;dcm = sitk.ReadImage(dcm_path)patient_name = dcm.GetMetaData(&#39;0010|0010&#39;).strip().encode(&quot;utf-8&quot;, &quot;surrogateescape&quot;).decode(&#39;gbk&#39;, &#39;replace&#39;)ds = pydicom.dcmread(dcm_path)ds.SpecificCharacterSet = &#39;ISO_IR 192&#39;ds.PatientName = patient_nameds.save_as(dcm_path)</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>DICOM</tag>
      
      <tag>pydicom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python将PDF转换为DICOM格式</title>
    <link href="/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/"/>
    <url>/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>DICOM影像通常分为三个层级：<code>Study</code>、<code>Series</code>、<code>Instance</code>，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。</p><p>DICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分<code>Pixel Data</code>字段中。</p><p>为了将PDF报告转换成DICOM格式，可以先利用<code>pdf2image</code>将PDF转换为常见的图片格式，再将图片转换为<code>bytes</code>类型数据，写入DICOM tag中的<code>Pixel Data</code>字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件</p><pre><code class="python">import osimport tempfileimport datetimeimport pydicomfrom pydicom.dataset import Dataset, FileDatasetfrom pdf2image import convert_from_path# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典def read_dcm(dicom_dir):    dicom_list = os.listdir(dicom_dir)    info_list = []    for dicom in dicom_list:        # 使用pydicom读取DICOM影像信息        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))        info_dict = {            &#39;MediaStorageSOPInstanceUID&#39;: ds.file_meta.MediaStorageSOPInstanceUID,            &#39;MediaStorageSOPClassUID&#39;: ds.file_meta.MediaStorageSOPClassUID,            &#39;ImplementationClassUID&#39;: ds.file_meta.ImplementationClassUID,            &#39;PatientName&#39;: ds.PatientName,            &#39;PatientID&#39;: ds.PatientID,            &#39;PatientSex&#39;: ds.PatientSex,            &#39;PatientBirthDate&#39;: ds.PatientBirthDate,            &#39;PatientAge&#39;: ds.PatientAge,            &#39;ContentDate&#39;: ds.ContentDate,            &#39;ContentTime&#39;: ds.ContentTime,            &#39;SOPClassUID&#39;: ds.SOPClassUID,            &#39;SOPInstanceUID&#39;: ds.SOPInstanceUID,            &#39;StudyInstanceUID&#39;: ds.StudyInstanceUID,            &#39;SeriesInstanceUID&#39;: ds.SeriesInstanceUID,            &#39;InstanceNumber&#39;: ds.InstanceNumber,            &#39;SeriesNumber&#39;: ds.SeriesNumber,        }        info_list.append(info_dict)    # 根据InstanceUID排序    sort_list = sorted(info_list, key=lambda x: x[&#39;MediaStorageSOPInstanceUID&#39;])    return sort_list[-1]# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中def write_dcm(index, img, dicom, dicom_dir):    # 用于将InstanceUID尾数加1    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))    # 创建临时文件名    suffix = &#39;.dcm&#39;    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name    # 填充DICOM文件头必要信息    file_meta = Dataset()    file_meta.MediaStorageSOPClassUID = dicom[&#39;MediaStorageSOPClassUID&#39;]    file_meta.MediaStorageSOPInstanceUID = chguid(dicom[&#39;MediaStorageSOPInstanceUID&#39;])    file_meta.ImplementationClassUID = dicom[&#39;ImplementationClassUID&#39;]    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b&quot;\0&quot; * 128)    # 加入DICOM tag信息（不包含所有）    ds.PatientName = dicom[&#39;PatientName&#39;]    ds.PatientID = dicom[&#39;PatientID&#39;]    ds.PatientSex = dicom[&#39;PatientSex&#39;]    ds.PatientBirthDate = dicom[&#39;PatientBirthDate&#39;]    ds.PatientAge = dicom[&#39;PatientAge&#39;]    # Set the transfer syntax    # ds.is_little_endian = True    # ds.is_implicit_VR = True    # 加入DICOM tag信息（不包含所有）    dt = datetime.datetime.now()    ds.ContentDate = dt    time_str = dt.strftime(&#39;%H%M%S.%f&#39;)    ds.ContentTime = time_str    # 生成StudyUID, SeriesUID, InstanceUID    ds.SOPClassUID = dicom[&#39;SOPClassUID&#39;]    ds.SOPInstanceUID = chguid(dicom[&#39;SOPInstanceUID&#39;])    ds.StudyInstanceUID = dicom[&#39;StudyInstanceUID&#39;]    ds.SeriesInstanceUID = dicom[&#39;SeriesInstanceUID&#39;] + &#39;.1&#39;    ds.InstanceNumber = index + 1    ds.SeriesNumber = str(int(dicom[&#39;SeriesNumber&#39;]) + 1)    # 指定影像参数    ds.Rows = img.size[1]    ds.Columns = img.size[0]    ds.SamplesPerPixel = 3    ds.PhotometricInterpretation = &quot;RGB&quot;    ds.HighBit = 7    ds.BitsStored = 8    ds.BitsAllocated = 8    ds.PixelRepresentation = 0    # 将img对象转换为bytes类型，写入PixelData字段    ds.PixelData = img.tobytes()    # 指定TransferSyntax等信息    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian    ds.is_little_endian = False    ds.is_implicit_VR = False    # 保存影像文件    file_name = &#39;report_{}.dcm&#39;.format(index)    file_path = os.path.join(dicom_dir, file_name)    ds.save_as(file_path)def main(pdf_path, dicom_dir):    # 将pdf转换为图片    images_list = convert_from_path(pdf_path)    # 从DICOM文件夹中读取最后一张影像的信息    dicom_info = read_dcm(dicom_dir)    # 创建DICOM影像并写入图片数据    for index, img in enumerate(images_list):        write_dcm(index, img, dicom_info, dicom_dir)if __name__ == &#39;__main__&#39;:    pdf_path = &#39;/home/ray/dcm_report/report.pdf&#39;    dicom_dir = &#39;/home/ray/dcm_report/dcm_data&#39;    main(pdf_path, dicom_dir)</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>DICOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SimpleITK读取DICOM</title>
    <link href="/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/"/>
    <url>/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/</url>
    
    <content type="html"><![CDATA[<p>SimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install SimpleITK</code></p><h2 id="读取DICOM影像"><a href="#读取DICOM影像" class="headerlink" title="读取DICOM影像"></a>读取DICOM影像</h2><ul><li>读取单张DICOM影像</li></ul><pre><code class="python">import SimpleITK as sitkfile = sitk.ReadImage(filepath) # 图像大小file.GetSize()# 坐标原点file.GetOrigin()# 像素间距file.GetSpacing()# 方向file.GetDirection()# 获取影像元数据(返回DICOM tags元组)file.GetMetaDataKeys()# 像素矩阵pixel_array = sitk.GetArrayFromImage(file)</code></pre><ul><li>读取DICOM序列</li></ul><pre><code class="python">import osimport SimpleITK as sitkpath = &quot;/dicom_study_dir&quot;reader = sitk.ImageSeriesReader()seriesIDs = reader.GetGDCMSeriesIDs(path)dicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])reader.SetFileNames(dicom_names)image = reader.Execute()</code></pre><h2 id="读取特定序列并保存为NIfTI格式"><a href="#读取特定序列并保存为NIfTI格式" class="headerlink" title="读取特定序列并保存为NIfTI格式"></a>读取特定序列并保存为NIfTI格式</h2><p>医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：</p><pre><code class="python">import loggingimport osimport SimpleITK as sitk# 从DICOM影像中读取Tag信息def get_tag(dcm, key, default_value=&#39;&#39;):    try:        value = dcm.GetMetaData(key).strip()    except Exception as e:        logging.error(e)        value = default_value    return value# 从DICOM study文件夹中提取需要的序列并转换def extract_series(study_dir, series_desc):    # 获取所有series id,返回一个元组    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)    for series_id in series_ids:        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)        reader = sitk.ImageSeriesReader()        reader.SetFileNames(files)        try:            img = reader.Execute()        except RuntimeError as e:            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常            if &#39;The file in the series have unsupported 3 dimensions&#39; in str(e):                img = sitk.ReadImage(files[0])            else:                logging.error(&#39;Error in reading image, dir %s, series id %s, detail message: %s&#39; % (study_dir, series_id, e))                continue        # 从当前序列取一张影像，便于读取其Tag信息                        dcm = sitk.ReadImage(files[0])        # 获取当前序列的序列描述        series_description = get_tag(dcm, &#39;0008|103e&#39;)        # 判断是否是需要的序列        if series_description == series_desc:            nii_name = str(series_id) + &quot;nii.gz&quot;            # 写入nii.gz文件            sitk.WriteImage(img, os.path.join(study_dir, nii_name))        else:            continue</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>SimpleITK</tag>
      
      <tag>DICOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django实现语言切换</title>
    <link href="/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/"/>
    <url>/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Django提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：<a href="https://djangobook-cn.readthedocs.io/en/latest/chapter19.html" target="_blank" rel="noopener">https://djangobook-cn.readthedocs.io/en/latest/chapter19.html</a></p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>首先在Django settings文件中加入中间件<code>django.middleware.locale.LocaleMiddleware</code></p><pre><code class="python">MIDDLEWARE = [  &#39;django.middleware.security.SecurityMiddleware&#39;,  &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,  # django语言国际化中间件  &#39;django.middleware.locale.LocaleMiddleware&#39;,  &#39;django.middleware.common.CommonMiddleware&#39;,  &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,  &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,  &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,  &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre></li><li><p>然后增加<code>LANGUAGES</code>和<code>LOCALE_PATHS</code>配置，<code>locale</code>文件夹需要手动创建：</p><pre><code class="python">LANGUAGES = (  (&#39;zh-hans&#39;, &#39;中文简体&#39;),  (&#39;en&#39;, &#39;English&#39;),)</code></pre></li></ul><p>LOCALE_PATHS = (<br>    os.path.join(os.path.dirname(BASE_DIR), ‘locale’),<br>)</p><pre><code>## 修改html模板文件- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面```python{% load i18n %}</code></pre><ul><li><p>在需要翻译的字符串上加上trans标签,例如：</p><pre><code class="python">&lt;li&gt;&lt;a href=&quot;/management/language_set&quot;&gt;&lt;i class=&quot;ti-settings&quot;&gt;&lt;/i&gt; {% trans '语言设置' %}&lt;/a&gt;&lt;/li&gt;</code></pre></li><li><p>多次重复翻译的内容可以设置成常量：</p><pre><code class="python">{% trans "This is the title" as the_title %}&lt;title&gt;{{ the_title }}&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;{{ the_title }}&quot;&gt;</code></pre></li><li><p>如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：</p><pre><code class="html">{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}</code></pre></li></ul><h2 id="后端视图"><a href="#后端视图" class="headerlink" title="后端视图"></a>后端视图</h2><ul><li>如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的<code>gettext</code>模块，代码示例如下：<pre><code class="python">from django.utils.translation import gettext as _</code></pre></li></ul><p>def test_views(request):<br>    response_str = _(“中文字符串”)<br>    return HttpResponse(response_str)</p><pre><code>- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`## JavaScript中的语言转换- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：```pythonurl(r&#39;^jsi18n/$&#39;, JavaScriptCatalog.as_view(packages=[&#39;ProjectName&#39;]), name=&#39;javascript-catalog&#39;)</code></pre><ul><li><p>然后在模板中引入js(可放在公共页面)</p><pre><code class="python">&lt;script type=&quot;text/javascript&quot; src=&quot;{% url 'javascript-catalog' %}&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>使用<code>gettext</code>在js中标记字符串，例如：</p><pre><code class="javascript">function editpwd(){      layer.open({        type: 1,        title: gettext(&#39;修改密码&#39;),        maxmin: true,        shadeClose: true, //点击遮罩关闭层        area : [&#39;550px&#39; , &#39;&#39;],        content:$(&#39;#addsort_style&#39;),     })  }</code></pre></li><li><p>需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到</p></li></ul><h2 id="翻译文件生成与编译"><a href="#翻译文件生成与编译" class="headerlink" title="翻译文件生成与编译"></a>翻译文件生成与编译</h2><ul><li>添加完翻译的标记后，执行以下命令即可在<code>locale</code>文件夹下生成翻译文件：</li></ul><p><code>python manage.py makemessages -l en</code><br><code>python manage.py makemessages -d djangojs -l en</code></p><ul><li><p>执行成功后可以发现生成了<code>django.po</code>以及<code>djangojs.po</code>文件，然后就可以填充翻译后的字符串：</p><pre><code class="python">#: DrBrain3/templates/Management/series_list.html:46#: DrBrain3/templates/Users/new_psw.html:89msgid &quot;确认修改&quot;msgstr &quot;Confirm the changes&quot;</code></pre><p>需要注意，有时由于识别的错乱，执行<code>python manage.py makemessages -l en</code>后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示</p></li><li><p>填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件</p></li></ul><p><code>python manage.py compilemessages</code></p><h2 id="如何切换语言"><a href="#如何切换语言" class="headerlink" title="如何切换语言"></a>如何切换语言</h2><p>Django本身提供了语言切换的功能，可参考如下方法实现：</p><ul><li><p>在项目根路由文件<code>urls.py</code>中添加切换语言的url</p><pre><code class="python">url(r&#39;^i18n/&#39;,include(&#39;django.conf.urls.i18n&#39;))</code></pre></li><li><p>html页面中添加如下form表单</p><pre><code class="python">&lt;form action=&quot;{% url 'set_language' %}&quot; method=&quot;post&quot; id=&quot;change_language_form&quot; enctype=&quot;multipart/form-data&quot;&gt;  {% csrf_token %}  &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot;/&gt;  &lt;select class=&quot;change_language&quot; name=&quot;language&quot; id=&quot;language&quot; onclick=&quot;changeLan()&quot;&gt;      {% for lang in LANGUAGES %}        <option value="{{ lang.0 }}"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>{% endfor %}  &lt;/select&gt;&lt;/form&gt;</code></pre></li><li><p>JavaScript代码</p><pre><code class="javascript">$(&#39;.change_language&#39;).change(function (e) {  e.preventDefault();  $(&#39;#change_language_form&#39;).submit();  return false</code></pre></li></ul><p>});</p><pre><code>- 登录时记录用户选择的语言在用户登录的后端视图中加入：```pythonrequest.session[&#39;_language&#39;]=&#39;zh-hans&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django实现单设备登录限制</title>
    <link href="/2017/09/05/Django%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/"/>
    <url>/2017/09/05/Django%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。</p><a id="more"></a><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。</p><h2 id="使用Mysql数据表"><a href="#使用Mysql数据表" class="headerlink" title="使用Mysql数据表"></a>使用Mysql数据表</h2><p>为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。<br>实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。</p><h2 id="使用Redis缓存session"><a href="#使用Redis缓存session" class="headerlink" title="使用Redis缓存session"></a>使用Redis缓存session</h2><p>Django项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：</p><pre><code class="python"># 获取当前session的session_keysession_key = request.session.session_key# 获取Redis中所有keykey_list = cache.keys(&quot;*&quot;)# 遍历获取到的所有key，通过正则筛选django的session记录for key in key_list:    s_key = re.match(r&#39;django\.contrib\.sessions\.cache(.*)&#39;, key)    # 如果session_key和当前session不同，则进行判断    if s_key and s_key.group(1) != session_key:        cache_session_dict = cache.get(key)        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录        if cache_session_dict.get(&#39;user_id&#39;) == user.id:            cache.delete(key)            logger.info(&#39;Account [{}] has logged in elsewhere, delete old session [{}]&#39;.format(username, key))            else:                continue</code></pre><h2 id="视图装饰器"><a href="#视图装饰器" class="headerlink" title="视图装饰器"></a>视图装饰器</h2><p>为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。</p><pre><code class="python">def auth_required(perm):    def decorator(view_func):        def _wrapped_view(request, *args, **kwargs):            try:                session_key = request.session.session_key                # session_flag = Session.objects.filter(session_key=session_key)                if not session_key:                    return JsonResponse({&quot;respCode&quot;: 4001})                else:                    role = request.session.get(&quot;role_id&quot;)                    if not role:                        return JsonResponse({&quot;respCode&quot;: 4002})                    else:                        if int(role) &gt; int(perm):                            return JsonResponse({&quot;respCode&quot;: 4003})            except Exception as e:                logger.error(e)                return JsonResponse({&quot;respCode&quot;: 4004})            return view_func(request, *args, **kwargs)        return _wrapped_view    return decorator</code></pre>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
