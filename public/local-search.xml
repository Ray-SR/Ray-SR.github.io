<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes基础</title>
    <link href="/2020/12/27/Kubernetes%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/12/27/Kubernetes%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>k8s 把数量众多的服务器重新抽象为一个统一的资源池</strong>，对于运维人员来说，他们面前没有服务器1、服务器2的概念，而是一个统一的资源池，增加新的服务器对运维人员来说，只是增加自资源池的可用量。不仅如此，k8s 把所有能用的东西都抽象成了资源的概念，从而提供了一套更统一，更简洁的管理方式。</p><a id="more"></a><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-Pod"><a href="#1-1-Pod" class="headerlink" title="1.1 Pod"></a>1.1 Pod</h3><p>Pod是K8S中的最小工作单位， 和Docker中的容器类似， 不过pod是将一个或多个docker容器封装成一个统一的整体进行管理，并对外提供服务，同一个Pod内的容器可以共享网络栈、存储卷等。</p><p>例如查看本机有哪些pod:  <code>kubectl get pods</code><br>查看命名空间为kube-system下的所有pod: <code>kubectl get pods -n kube-system</code></p><ul><li><strong>创建资源</strong></li></ul><p>k8s中所有资源都可以通过<code>kube create</code>命令创建，使用create创建资源有2种方式，一种是直接使用命令指定参数，另一种是通过<code>yaml</code>文件创建。例如新建一个名为<code>kubia-pod.yaml</code>的文件如下：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: kubia-manualspec:  containers:  - image: luksa/kubia    name: kubia    ports:    - containerPort: 8080      protocol: TCP</code></pre><p>然后使用<code>kubectl create -f kubia-pod.yaml</code> 就可以创建一个pod<br>之后如果修改了配置，可以使用<code>kubectl apply -f kubia-pod.yaml</code>来重新应用配置</p><h3 id="1-2-namespace"><a href="#1-2-namespace" class="headerlink" title="1.2 namespace"></a>1.2 namespace</h3><p>命名空间namespace是k8s中组的概念，提供同一服务的pod应该被放置在同一命名空间下， 如果不指定，pod默认被放在命名空间<code>default</code> 下</p><h3 id="1-3-ReplicationController（副本控制器）"><a href="#1-3-ReplicationController（副本控制器）" class="headerlink" title="1.3 ReplicationController（副本控制器）"></a>1.3 ReplicationController（副本控制器）</h3><p>ReplicationController(RC)是pod的复制抽象，用于解决pod的扩容缩容问题, 它会确保任何时间Kubernetes中都有指定数量的Pod在运行。在此基础上，RC还提供了一些更高级的特性，比如滚动升级、升级回滚等。<br>RC通过label来关联pod， 对于pod，需要设置其自身的label进行表示，label是一些列的key/value对。在创建RC的时候，需要指定<strong>标签选择器</strong>(Label Selector)，生成之后，它就会通过选择器查找pod并将其纳入自己的管辖</p><ul><li><strong>标签：标签是k8s中用于分类资源而提供的一个属性，一个标签包含<code>标签名</code>和<code>标签值</code>， 例如<code>app=kubia</code>, k8s中绝大多数资源都是通过标签来筛选和控制pod的</strong></li></ul><p>一个简单的RC配置文件<code>kubia-rc.yaml</code>如下：</p><pre><code class="yaml">apiVersion: v1# 说明类型为 rckind: ReplicationControllermetadata:  name: kubia-controllerspec:  # 这里指定了期望的副本数量  replicas: 3  # 这里指定了目标 pod 的选择器  selector:    # 目标 pod: app 标签的值为 kubia    app: kubia  # pod 模板  template:    metadata:      # 指定 pod 的标签      labels:        app: kubia    spec:      # 指定 pod 容器的内容      containers:      - name: kubia        image: luksa/kubia        ports:        - containerPort: 8080</code></pre><p>使用<code>kubectl create -f kubia-rc.yaml</code>即可创建该副本控制器<br>此后，即使我们使用<code>kubectl delete</code>删除了该副本控制器管辖的3个pod，它仍然会自动创建新的。需要注意，RC是通过<strong>标签</strong>来管理pod的，如果修改了某个pod的标签，那么它就自动脱离了RC的控制</p><ul><li><strong>存活探针</strong></li></ul><p>副本控制器RC是通过存活探针来讲pod的数量控制在期望数量， 存活探针的检测方式包括3种：<code>HTTP GET请求</code> 、<code>TCP套接字</code> 、<code>Exec执行命令</code><br>一个带有存活探针的pod配置文件如下：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: kubia-livenessspec:  containers:  - image: luksa/kubia-unhealthy    name: kubia    # 这下面就是探针！    livenessProbe:      httpGet:        path: /        port: 8080</code></pre><h3 id="1-4-ReplicationSet"><a href="#1-4-ReplicationSet" class="headerlink" title="1.4 ReplicationSet"></a>1.4 ReplicationSet</h3><p>ReplicationSet(RS)是升级版的RC，区别在于RS引入了对基于子集的selector查询条件，而RC仅支持基于值相等的selector条件查询<br>一个RS的配置文件<code>kubia-rs.yaml</code>如下：</p><pre><code class="yaml"># 需要指定对应的 apiVersionapiVersion: apps/v1beta2kind: ReplicaSetmetadata:  name: kubiaspec:  replicas: 3  selector:    # 只有这里和 rc 的写法不同    matchLabels:      app: kubia  template:    metadata:      labels:        app: kubia    spec:      containers:      - name: kubia        image: luksa/kubia        ports:        - containerPort: 8080</code></pre><h3 id="1-5-Deployment"><a href="#1-5-Deployment" class="headerlink" title="1.5 Deployment"></a>1.5 Deployment</h3><p>Deployment为pod和RS提供声明式的更新能力, 通过在Deployment中描述期望的集群状态， Deployment Controller会将现在的集群状态逐步更新为期望的集群状态，其职责同样是为了保证pod的数量和健康，并且提供了RS之外的新特性：<br>事件和状态查看：可以查看Deployment的升级详细进度和状态。<br>　　　　<strong>回滚</strong>：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。<br>　　　　<strong>版本记录</strong>: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。<br>　　　　<strong>暂停和启动</strong>：对于每一次升级，都能够随时暂停和启动。<br>　　　　<strong>多种升级方案</strong>：Recreate—-删除所有已存在的pod,重新创建新的; RollingUpdate—-滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。</p><h3 id="1-6-Service"><a href="#1-6-Service" class="headerlink" title="1.6 Service"></a>1.6 Service</h3><p>由于pod在受到RC调控时，其副本和虚拟ip的变化的，比如发生迁移或伸缩的时候。因此需要一个统一固定的ip或域名来访问，Service是pod的路由代理抽象，用于解决pod之间的路由发现问题，访问端只需要知道service的地址，由service来提供代理，Service和Pod之间同样是通过label来进行关联<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607671122045-2e14c059-845e-4090-a9ba-35935b1dd1f9.png#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&name=service.png&originHeight=421&originWidth=864&size=28962&status=done&style=stroke&width=864" srcset="/img/loading.gif" alt="service.png"><br>接下来演示如何创建一个service:</p><ul><li><p>首先使用1.4小节中的<code>kubia-rs.yaml</code>来创建3个pod：<code>kubectl create -f kubia-rs.yaml</code></p><p>创建成功之后就可以看到3个pod<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673418280-1df7615c-7200-4101-9f33-5a7268923a6d.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&name=rs.png&originHeight=160&originWidth=1268&size=39467&status=done&style=none&width=1268" srcset="/img/loading.gif" alt="rs.png"></p></li><li><p>接下来新建service来提供对这3个pod的访问，新建<code>kubia-svc.yaml</code></p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:name: kubiaspec:ports:- name: port80 # 为所有端口指定名称  port: 80 # 对外开放的服务端口  targetPort: 8080 # 后方 pod 的服务端口selector:  app: kubia</code></pre><p>执行<code>kubectl create -f kubia-svc.yaml</code>来创建该服务，之后就可以看到它的信息：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673617273-2a231480-7e30-49c8-bda5-94b31baeb8b4.png#align=left&display=inline&height=141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=1360&size=44737&status=done&style=none&width=1360" srcset="/img/loading.gif" alt="image.png"><br>CLUSTER-IP一栏就是该服务的ip，节点内其他pod就可以通过这个ip来访问服务，例如通过pod<code>kubia-4p45t</code>来访问服务：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607673956066-7132bfd9-1b31-4e11-8399-fb9f45bb3330.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=service3.png&originHeight=136&originWidth=1058&size=32024&status=done&style=none&width=1058" srcset="/img/loading.gif" alt="service3.png"><br>可以看到请求被转向了<code>kubia-k66bq</code>和<code>kubia-5dlks</code>这2个pod，并且实现了负载均衡</p></li></ul><h3 id="1-7-Endpoints"><a href="#1-7-Endpoints" class="headerlink" title="1.7 Endpoints"></a>1.7 Endpoints</h3><p>因为<code>svc</code>是通过我们事先定义好的标签选择器来查找 pod 的，所以 pod 的 ip 地址变动对于<code>svc</code>毫无影响，其实在<code>svc</code>和<code>pod</code>之间还包含了一个资源叫做<code>endpoint</code>，<code>endpoint</code>(简称<code>ep</code>)是一组地址及其端口的合集，如下图，只要一个<code>svc</code>有标签选择器的话，他就会自动创建一个同名的<code>ep</code>来标记出自己的要管理的 pod</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607671225632-e4497afa-1552-49cc-99d0-03fc94e1ea0e.png#align=left&display=inline&height=513&margin=%5Bobject%20Object%5D&name=endpoint.png&originHeight=513&originWidth=408&size=23720&status=done&style=stroke&width=408" srcset="/img/loading.gif" alt="endpoint.png"></p><ul><li>通过域名访问服务</li></ul><p>在1.6小节中我们通过ip的方式访问了服务，实际上k8s也提供了<code>FQDN</code>（全限定域名）的方式访问服务：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607674417105-d629ed47-b1ff-4666-83bf-537d92ace1b3.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=name.png&originHeight=68&originWidth=1142&size=16547&status=done&style=none&width=1142" srcset="/img/loading.gif" alt="name.png"><br>上图中的kubia就是我们在创建<code>service</code>时指定的<code>name</code> 属性<br>(这种方式可以访问同一命名空间中的服务，k8s还支持访问不同命名空间中的服务)</p><ul><li>访问集群外部服务</li></ul><p>如果一个集群内部的pod要访问外部服务器，如云数据库、公共API等，就可以利用<code>Endpoint</code>来指定外部 服务的ip和端口，并将其绑定到一个服务<code>serivce</code>上<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607674767028-ba0918b6-aca8-4fae-9fba-e4105948242b.png#align=left&display=inline&height=503&margin=%5Bobject%20Object%5D&name=13523736-e4c4aa978679fee1.png&originHeight=503&originWidth=177&size=15742&status=done&style=stroke&width=177" srcset="/img/loading.gif" alt="13523736-e4c4aa978679fee1.png"><br>新建<code>external-service.yaml</code>如下，它只是提供了一个80端口供其他pod访问：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: external-servicespec:  ports:  - port: 80</code></pre><p>然后新建<code>external-endpoints.yaml</code>如下：</p><pre><code class="yaml">apiVersion: v1kind: Endpointsmetadata:  # 和 svc 相同的名称  name: external-servicesubsets:  - addresses:    # 这里指定了外部服务的 ip    - ip: 13.125.137.129    # 可以指定多个    # - ip: 22.22.22.22    # 还要指定端口号    ports:    - port: 8000</code></pre><p>执行创建命令： <code>kubectl create -f external-service.yaml</code><br><code>kubectl create -f external-endpoints.yaml</code><br>然后查看服务详情，可以看到他已经和endpoint完成绑定<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675210199-c22fbed8-b99c-4337-94b5-decd1ee35364.png#align=left&display=inline&height=497&margin=%5Bobject%20Object%5D&name=endpoint2.png&originHeight=497&originWidth=1381&size=90330&status=done&style=none&width=1381" srcset="/img/loading.gif" alt="endpoint2.png"></p><p>另外，也可以指定svc的类型type为<code>ExternalName</code>,再通过<code>ExternalName</code>字段来指定外部服务的域名，如下：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: external-servicespec:  # 要先指定 svc 的类型  type: ExternalName  # 再在这里指定外部服务的完全限定域名  externalName: someapi.some.company.com  ports:  - port: 80</code></pre><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><table><thead><tr><th align="center"><code>get</code></th><th align="center">查</th><th align="center">列出某个类型的下属资源</th></tr></thead></table><table><thead><tr><th align="center"><code>describe</code></th><th align="center">查</th><th align="center">查看某个资源的详细信息</th></tr></thead></table><table><thead><tr><th align="center"><code>logs</code></th><th align="center">查</th><th align="center">查看某个 pod 的日志</th></tr></thead></table><table><thead><tr><th align="center"><code>create</code></th><th align="center">增</th><th align="center">新建资源</th></tr></thead></table><table><thead><tr><th align="center"><code>explain</code></th><th align="center">查</th><th align="center">查看某个资源的配置项</th></tr></thead></table><table><thead><tr><th align="center"><code>delete</code></th><th align="center">删</th><th align="center">删除某个资源</th></tr></thead></table><table><thead><tr><th align="center"><code>edit</code></th><th align="center">改</th><th align="center">修改某个资源的配置项</th></tr></thead></table><table><thead><tr><th align="center"><code>apply</code></th><th align="center">改</th><th align="center">应用某个资源的配置项</th></tr></thead></table><h2 id="3-对外提供服务"><a href="#3-对外提供服务" class="headerlink" title="3.对外提供服务"></a>3.对外提供服务</h2><p>k8s对外提供服务通常有<code>post-forward</code> 、<code>NodePort</code> 、<code>Ingress</code>几种方式</p><h3 id="3-1-port-forward"><a href="#3-1-port-forward" class="headerlink" title="3.1 port-forward"></a>3.1 port-forward</h3><p>port-forward适用于测试某个资源是否可用<br><code>kubectl port-forward &lt;资源类型&gt;/&lt;资源名&gt; &lt;本机端口&gt;:&lt;资源端口&gt;</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675899436-0495205f-ceb4-4497-931a-ffdc034bc6a0.png#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&name=port-forward1.png&originHeight=367&originWidth=1193&size=81825&status=done&style=none&width=1193" srcset="/img/loading.gif" alt="port-forward1.png"><br>访问：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607675911713-f948514d-cc07-4469-863e-ffe09ec45833.png#align=left&display=inline&height=58&margin=%5Bobject%20Object%5D&name=port-forward2.png&originHeight=58&originWidth=790&size=13271&status=done&style=none&width=790" srcset="/img/loading.gif" alt="port-forward2.png"></p><h3 id="3-2-NodePort"><a href="#3-2-NodePort" class="headerlink" title="3.2 NodePort"></a>3.2 NodePort</h3><p>NodePort可以将服务转发到所有k8s节点的指定端口上，其本质上也是一个<code>Service</code> 资源，通过指定<code>nodePort</code>来将服务映射到节点的端口上，配置如下：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: kubia-nodeportspec:  type: NodePort  ports:  - port: 80    targetPort: 8080    nodePort: 30123  selector:    app: kubia</code></pre><p>创建后，就可以通过<code>curl 节点ip:端口号</code> 来访问了，节点ip可以通过<code>kubectl describe node &lt;节点名&gt;</code>来查看</p><h3 id="3-3-Ingress"><a href="#3-3-Ingress" class="headerlink" title="3.3 Ingress"></a>3.3 Ingress</h3><p>使用NodePort已经可以满足暴露服务的需求，但是如果有多个服务，虽然可以通过nginx服务器来实现转发，但是如果服务有变更，就需要再次手动配置nginx，而k8s提供了另一种方式：Ingress</p><p>Ingress由2部分构成，服务转发服务的<code>ingress-controller</code>和<code>Ingress</code>资源，Ingress-controller根据Ingress资源提供的配置来转发流量， k8s本身没有自带Ingress-controller，这里我们使用官方推荐的<code>nginx-ingress-controller</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607676497846-8e24895e-6dd8-4337-b79c-15685f658724.png#align=left&display=inline&height=605&margin=%5Bobject%20Object%5D&name=ingress1.png&originHeight=605&originWidth=515&size=29492&status=done&style=stroke&width=515" srcset="/img/loading.gif" alt="ingress1.png"></p><ul><li>安装nginx-ingress-controller</li></ul><p>官方配置文件： <a href="https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml</a><br>注意，官方的配置文件中，指定的<code>image</code>镜像源无法用国内网络访问，需要替换为国内镜像源。另外，<strong><code>Ingress-controller</code>本身只是一个pod,它并不直接对外暴露端口</strong>，因此还需要新建一个NodePort将其暴露出去，完整配置文件如下：<br><a href="/ingress-nginx-controller.yml">ingress-nginx.yaml</a></p><p>使用<code>kubectl create -f ingress-nginx.yaml</code>之后，就可以查看创建成功的Controller<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607677258423-54901efa-ebb0-4140-a13f-e80586a03b28.png#align=left&display=inline&height=84&margin=%5Bobject%20Object%5D&name=controller1.png&originHeight=84&originWidth=1069&size=23181&status=done&style=none&width=1069" srcset="/img/loading.gif" alt="controller1.png"></p><ul><li>创建ingress资源</li></ul><p>（注意，在这一步之前需要创建一个<code>service</code>及其<code>pod</code>，具体可参考1.6小节中的步骤）<br>新建<code>kubia-ingress.yaml</code>如下：</p><pre><code class="yaml">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: kubiaspec:  rules:    # 将服务映射到该域名  - host: kubia.example.com    http:      paths:        # 通过 /kubia 路径就可以访问该服务      - path: /kubia        # 该服务后端 svc 的名称及端口号        backend:          serviceName: kubia          servicePort: 80</code></pre><ul><li>配置域名映射</li></ul><p>在<code>ingress-nginx.yaml</code>中，我们已经将<code>nginx-ingress-controller</code>这个pod以30010端口暴露到主机上，接下来需要配置域名映射<br><code>sudo vim /etc/hosts</code><br>加入<code>172.17.0.3(节点ip) kubia.example.com</code></p><p>接下来就可以在主机上通过<code>curl http://kubia.example.com:30010/kubia</code> 来访问服务了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1607678407869-d644cd7a-dafb-4f40-a51d-52d2b15059b6.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&name=kubia.png&originHeight=212&originWidth=976&size=59226&status=done&style=none&width=976" srcset="/img/loading.gif" alt="kubia.png"></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://www.jianshu.com/p/8d60ce1587e1" target="_blank" rel="noopener">https://www.jianshu.com/p/8d60ce1587e1</a><br><a href="https://www.jianshu.com/p/116ce601a60f" target="_blank" rel="noopener">https://www.jianshu.com/p/116ce601a60f</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab CI/CD + Docker部署</title>
    <link href="/2020/12/27/Gitlab%20CI_CD%20+%20Docker%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/12/27/Gitlab%20CI_CD%20+%20Docker%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>利用Gitlab的CI/CD功能可以很方便地进行项目的持续集成和部署，我们还可以配合Docker来进一步完善服务器部署。本文介绍了如何使用docker-swarm这个工具来部署一套Django + Mysql + Redis的项目，并且配合Gitlab的CI、CD功能，实现自动部署、滚动更新。</p><a id="more"></a><h2 id="1-Gitlab-CI-CD安装及配置"><a href="#1-Gitlab-CI-CD安装及配置" class="headerlink" title="1.Gitlab CI/CD安装及配置"></a>1.Gitlab CI/CD安装及配置</h2><ul><li>ubuntu下安装：</li></ul><p><a href="https://www.yuque.com/docs/share/cf815454-54d0-49a0-9921-90564bd869e8?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/cf815454-54d0-49a0-9921-90564bd869e8?#</a> </p><p>CentOS安装步骤也类似，不过使用yum安装gitlab-runner可能版本太低，需要更新</p><ul><li><code>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash</code></li><li><code>sudo yum -y update</code></li></ul><p>并且Git的版本也需要更新</p><ul><li><code>yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm</code></li><li><code>yum update -y git</code></li></ul><h2 id="2-Docker-swarm"><a href="#2-Docker-swarm" class="headerlink" title="2.Docker swarm"></a>2.Docker swarm</h2><h4 id="docker-swarm介绍"><a href="#docker-swarm介绍" class="headerlink" title="docker-swarm介绍"></a>docker-swarm介绍</h4><ul><li><p><a href="https://yeasy.gitbook.io/docker_practice/swarm_mode/overview" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/swarm_mode/overview</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>docker swarm init</code> 启用swarm，将当前主机作为管理节点（管理节点自己也是worker）<br>如果要让其他节点加入swarm集群，运行init之后提示的<code>join</code>命令即可：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1603676764667-ed921106-633a-4d96-98d0-6c14ab367e05.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&name=1234.png&originHeight=196&originWidth=1524&size=21322&status=done&style=none&width=1524" srcset="/img/loading.gif" alt="1234.png"></p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4></li><li><p><code>docker node ls</code> 查看所有节点</p></li><li><p><code>docker service ls</code> 查看所有服务<code></code></p></li><li><p><code>docker service create -p 9000:9000 --mount type=bind,src=&quot;&lt;project_path&gt;&quot;,dst=&quot;&lt;container_path&gt;&quot; --replicas 3 --name &lt;service_name&gt; &lt;image&gt;:&lt;tag&gt;</code></p></li></ul><p><code>-p</code>指定端口映射，–mount指定目录挂载，<code>--replicas</code>指定任务(task)个数，即容器数量</p><ul><li><p><code>docker service update --image &lt;new_image_name&gt; &lt;service_name&gt;</code> 更新服务</p><h4 id="docker-stack"><a href="#docker-stack" class="headerlink" title="docker stack"></a>docker stack</h4></li><li><p>可以使用docker stack同时启动多个服务(service)，原理同<code>docker-compose</code>类似</p></li><li><p><code>docker stack deploy -c docker-compose.yaml &lt;stack_name&gt;</code></p></li><li><p><code>docker-compose.yaml</code>示例：</p><pre><code class="yaml">version: &quot;3&quot;services:mysql:  # 指定镜像  image: mysql:5.7  environment:    - MYSQL_ROOT_PASSWORD=123456    - MYSQL_DATABASE=go2home  volumes:    - /docker/mysql/conf:/etc/mysql    - /docker/mysql/logs:/var/log/mysql    - /docker/mysql/data:/var/lib/mysql  # 端口映射  ports:    - 3307:3306  # 网络和ip  networks:    extnetwork:redis:  image: redis  ports:    - 6380:6379  volumes:    - /docker/redis/data:/data    - /docker/redis/redis.conf:/etc/redis/redis.conf  command: redis-server /etc/redis/redis.conf  networks:    extnetwork:go2home:  image: go2home:latest  volumes:    - /docker/go2home/logs:/go2home/logs  ports:    - 9000:9000  networks:    extnetwork:  deploy:    mode: replicated    replicas: 3networks:extnetwork:  ipam:    config:      - subnet: 192.168.0.0/16</code></pre></li><li><p>注意：使用这种方式部署之后，在项目内就可以通过<code>&lt;服务名&gt;:端口</code> 的方式来访问mysql/redis了。例如使用<code>docker stack deploy -c docker-compose.yaml my_stack</code> 创建了服务之后，在<code>go2home</code>服务内就可以通过<code>my_stack_mysql:3306</code> 来访问mysql容器。这是因为docker swarm在创建服务的时候配置了虚拟ip以及DNS。</p></li></ul><p>关于docker swarm的网络问题，参考：<a href="https://www.jianshu.com/p/cacdd5ff0f14" target="_blank" rel="noopener">https://www.jianshu.com/p/cacdd5ff0f14</a></p><h2 id="3-项目配置"><a href="#3-项目配置" class="headerlink" title="3. 项目配置"></a>3. 项目配置</h2><ul><li><p>在项目根目录下新建文件<code>.gitlab-ci.yml</code>,配置如下：</p><pre><code class="yaml">stages:- buildvariables:DEPLOY_PATH: &quot;/root/go2home/&quot;               # 项目的部署路径build-job:stage: buildscript:  - OLD_IMAGE_ID=$(docker images | grep go2home | awk &#39;NR==1{print$3}&#39;)  # 获取最近一次构建的镜像ID  - echo $OLD_IMAGE_ID  - echo $CI_COMMIT_SHA  - sudo cp -r $CI_PROJECT_DIR/* $DEPLOY_PATH                            # 将代码拷贝到部署路径  - cd $DEPLOY_PATH  - NEW_IMAGE_NAME=go2home:$CI_COMMIT_SHA  - echo $NEW_IMAGE_NAME  - docker build -t $NEW_IMAGE_NAME .                                    # 以commit ID为tag，构建新镜像  - docker service update --image $NEW_IMAGE_NAME go2home_go2home        # 更新服务  - docker rmi -f $OLD_IMAGE_ID                                             # 删除旧镜像tags:  - new_go2homeonly:  - masterenvironment:  name: prod</code></pre></li><li><p>在项目根目录下新建<code>Dockerfile</code>文件以及<code>.dockerignore</code>文件(以Django项目为例)</p></li></ul><p>Dockerfile</p><pre><code class="dockerfile"># 基于python3.7.3镜像FROM python:3.7.3# 设置系统环境变量，用于在项目中区分环境ENV DJANGO_ENV DOCKER# 该设置确保python的标准输出实时ENV PYTHONUNBUFFERED 1# 设置工作目录WORKDIR /go2home# 单独将requirements.txt作为一层，这样当requirements.txt没有变化时,build镜像会使用之前的缓存ADD ./requirements.txt /go2home/requirements.txtRUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple# 添加项目文件ADD . /go2home# 暴露端口EXPOSE 9000# 设置启动命令ENTRYPOINT python GoToHome/manage.py migrate &amp;&amp; \           uwsgi --ini GoToHome/docker-uwsgi.ini</code></pre><p>.dockerignore</p><pre><code>*.logcelerybeat-scheduleuwsgi.pid</code></pre><p>此后的部署，只需要push代码到gitlab仓库，就会自动执行.gitlab-ci.yml文件中配置的步骤，更新镜像、服务</p><h2 id="4-Docker-portainer安装"><a href="#4-Docker-portainer安装" class="headerlink" title="4.Docker portainer安装"></a>4.Docker portainer安装</h2><p>portainer是一个docker的图形化管理工具，开箱即用，用来管理docker服务很方便</p><ul><li><code>docker pull portainer/portainer</code></li><li><code>docker run -d -p 8080:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /docker/portainer:/data portainer/portainer</code></li><li>创建容器后，访问<code>http://&lt;服务器ip&gt;:8080</code> 即可，初次登陆设置管理员密码</li></ul>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab CI/CD配置</title>
    <link href="/2020/12/27/Gitlab%20CI_CD%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/12/27/Gitlab%20CI_CD%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Gitlab有自带的CI/CD功能，只需要在项目根目录新建一个<code>.gitlab-ci.yml</code>文件，推送到仓库中，即可创建一个pipeline，并通过注册好的runner部署、运行项目</p><a id="more"></a><h2 id="1-注册gitlab-runner"><a href="#1-注册gitlab-runner" class="headerlink" title="1.注册gitlab-runner"></a>1.注册gitlab-runner</h2><p>gitlab-runner相当于gitlab代码仓库和服务器之间的中间人，当我们触发了pipelines中的任务，它就可以将代码仓库中的代码拉到服务器，执行我们配置好的脚本，从而实现自动部署</p><p>注意：为保持前后一致，所有命令都要以sudo权限运行</p><ul><li>安装</li></ul><p><code>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</code></p><p><code>sudo apt-get install gitlab-ci-multi-runner</code></p><ul><li>注册</li></ul><p><code>sudo gitlab-runner register</code></p><p>①URL以及token，去gitlab项目中的setting中复制，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1594975213918-21a88996-f654-49f4-98b0-5a0353f6505e.png#align=left&display=inline&height=829&margin=%5Bobject%20Object%5D&name=1.png&originHeight=829&originWidth=1591&size=83750&status=done&style=stroke&width=1591" srcset="/img/loading.gif" alt="1.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1594975228369-c31bcdd7-0fcc-4dd8-b184-d9311fcedc50.png#align=left&display=inline&height=852&margin=%5Bobject%20Object%5D&name=2.png&originHeight=852&originWidth=957&size=76152&status=done&style=stroke&width=957" srcset="/img/loading.gif" alt="2.png"><br>②tag<br>tag是作为这个gitlab-runner的标识，此后在<code>.gitlab-ci.yml</code>文件中配置的时候需要用到<br>③是否运行在没有tag的build上面<br>选<code>true</code><br>④选择执行器<br>选<code>shell</code></p><h2 id="2-启动gitlab-runner"><a href="#2-启动gitlab-runner" class="headerlink" title="2.启动gitlab-runner"></a>2.启动gitlab-runner</h2><ul><li>install</li></ul><p><code>sudo gitlab-runner install -n &quot;service_name&quot; -d /home/ubuntu -u ubuntu</code><br>-n: 服务名称<br>-u: 以哪个用户的身份执行部署脚本中的shell命令<br>-d: 工作目录（如果不指定，则默认是执行install命令时所在的路径）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1597821172707-704fcac2-f70a-418b-a37d-e81bbef039c6.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&name=1111111.png&originHeight=213&originWidth=1361&size=20018&status=done&style=none&width=1361" srcset="/img/loading.gif" alt="1111111.png"></p><ul><li>start</li></ul><p><code>sudo gitlab-runner start -n &quot;service_name&quot;</code><br>这里的service_name即install时指定的名称<br>启动成功之后就可以在gitlab settings –&gt; CI/CD –&gt; Runners 下查看新增的runner,显示绿色则表示启动成功<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/480333/1597822695447-c21ffb03-172a-42e7-860d-260112b29ea6.jpeg#align=left&display=inline&height=810&margin=%5Bobject%20Object%5D&name=1597822667%281%29.jpg&originHeight=810&originWidth=1606&size=94738&status=done&style=stroke&width=1606" srcset="/img/loading.gif" alt="1597822667(1).jpg"></p><h2 id="3-配置-gitlab-ci-yml"><a href="#3-配置-gitlab-ci-yml" class="headerlink" title="3.配置.gitlab-ci.yml"></a>3.配置<code>.gitlab-ci.yml</code></h2><p>关于gitlab-ci.yaml中各项配置的含义，详见：<code>https://juejin.im/post/6844904045581172744</code></p><ul><li><p>在项目根目录下新建<code>.gitlab-ci.yml</code>文件，配置构建时需要执行的一些列操作。以下是Django项目部署的一个示例：</p><pre><code class="yaml">stages:- build- testvariables:DEPLOY_PATH: &quot;/home/ubuntu/deploy/car_wash/&quot;               # 项目的部署路径PYTHON_PATH: &quot;/home/ubuntu/.pyenv/versions/car_wash/bin&quot;   # python可执行文件(bin)的路径build-job:stage: buildscript:  - sudo cp -r $CI_PROJECT_DIR/* $DEPLOY_PATH              # 将gitlab-runner拉下来的代码复制到部署路径  - cd $DEPLOY_PATH  - sudo $PYTHON_PATH/pip install -r requirements.txt      # 安装依赖  - $PYTHON_PATH/python CarWash/manage.py migrate          # 执行迁移  - sudo supervisorctl restart car_wash                    # 使用supervisor重启服务  - sudo supervisorctl restart celerytags:  - CarWashonly:  - masterenvironment:  name: prodtest-job:stage: testscript:  - cd $DEPLOY_PATH  - $PYTHON_PATH/python CarWash/manage.py test Common --keepdb  # 执行测试tags:  - CarWashonly:  - masterenvironment:  name: prod</code></pre></li><li><p>stage</p></li></ul><p>定义一次pipeline需要执行的构建步骤，比如部署代码—&gt;执行测试—&gt;部署到生产环境；<br>每个stage可以包含多个job,同一个stage下面的job并行执行；</p><ul><li>variables</li></ul><p>变量，可以自定义一些下面job中需要用到的变量，如项目路径等；<br>gitlab也有一些系统预设的变量，比如<code>$CI_PROJECT_DIR</code> 是gitlab-runner将代码从仓库中拉下来之后存放的路径；<br>对于一些不方便写到配置文件中的私密变量（如secrect key、SSH key等），可以在gitlab的 settings–&gt;CI/CD–&gt;variables 中配置；</p><ul><li>job</li></ul><p>具体执行的构建动作，每个job必须指定对应的stage</p><ul><li>script</li></ul><p>执行的命令</p><ul><li>tags</li></ul><p>指定以哪个gitlab-runner来执行该job，这里需要和注册gitlab-runner时指定的tag对应</p><ul><li>only</li></ul><p>限定git分支</p><ul><li>environment</li></ul><p>用于定义一个job部署到的环境，定义了之后会自动创建一个环境，在gitlab的Operations –&gt; Environments 中可以看到该环境下执行的job，并进行重新部署、回滚等操作<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1599207997711-4f309391-4c1b-4abf-870e-852ab8839db2.png#align=left&display=inline&height=646&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200904162536.png&originHeight=646&originWidth=1730&size=45518&status=done&style=stroke&width=1730" srcset="/img/loading.gif" alt="微信截图_20200904162536.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1599208015050-b25b578c-5f50-43d6-8d44-8d668f7d7856.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200904162612.png&originHeight=651&originWidth=1793&size=43336&status=done&style=stroke&width=1793" srcset="/img/loading.gif" alt="微信截图_20200904162612.png"></p><ul><li>将<code>.gitlab-ci.yml</code> 文件推到(push)代码仓库之后，就可以发现pipeline已经创建，点击进入查看详细日志</li><li>状态为passed则表示部署成功</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1597822807524-fa71b867-e5c2-42eb-b49f-6b00edbe4a41.png#align=left&display=inline&height=779&margin=%5Bobject%20Object%5D&name=222222222.png&originHeight=779&originWidth=1782&size=51915&status=done&style=stroke&width=1782" srcset="/img/loading.gif" alt="222222222.png"></p><ul><li>Vue项目部署配置示例<pre><code class="yaml">stages:- buildvariables:DEPLOY_PATH: &quot;/home/ubuntu/deploy/car_wash_admin/&quot;               # 项目的部署路径build-job:stage: buildscript:  - cd $CI_PROJECT_DIR                                           # 进入代码目录  - rm -rf $CI_PROJECT_DIR/node_modules  - npm install                                                  # 安装依赖  - npm run build                                                # 打包构建  - cp -r $CI_PROJECT_DIR/dist/* $DEPLOY_PATH                    # 将打包完成的文件复制到部署路径  - sudo nginx -s reload                                         # 重启Nginxtags:  - car_wash_admin_tag                                           # gitlab-runner tagonly:  - master                                                       # 允许部署的分支environment:  name: prod                                                     # 环境名称</code></pre><h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><a href="https://www.jianshu.com/p/306cf4c6789a" target="_blank" rel="noopener">https://www.jianshu.com/p/306cf4c6789a</a><br><a href="https://www.jianshu.com/p/2b43151fb92e" target="_blank" rel="noopener">https://www.jianshu.com/p/2b43151fb92e</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins + Gitlab + Django实现持续集成</title>
    <link href="/2020/12/26/Jenkins%20+%20Gitlab%20+%20Django%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <url>/2020/12/26/Jenkins%20+%20Gitlab%20+%20Django%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>基于ubuntu18.04搭建一套持续集成、部署的系统，在本地推送(push)代码到Gitlab后，通过Gitlab的webhook触发Jenkins任务，自动拉取代码并部署到生产服务器运行。</p><h3 id="1-Jenkins搭建"><a href="#1-Jenkins搭建" class="headerlink" title="1. Jenkins搭建"></a>1. Jenkins搭建</h3><ul><li><strong>查看是否安装了java</strong></li></ul><p><code>java -version</code></p><ul><li><strong>如果没有安装java,则执行下面的命令安装</strong></li></ul><p><code>sudo apt-get install openjdk-8-jre</code></p><ul><li><p><strong>配置java环境变量，在<code>/etc/profile</code>中添加以下内容：</strong></p><pre><code class="bash">#set jdk environment export JAVA_HOME=/usr/lib/jvm/Java-8-openjdk-amd64 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</code></pre></li><li><p><strong>使配置文件生效</strong></p></li></ul><p><code>source /etc/profile</code></p><ul><li><strong>安装Jenkins</strong></li><li><code>wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</code></li><li><code>sudo sh -c &#39;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#39;</code></li><li><code>sudo apt-get update</code></li><li><code>sudo apt-get install jenkins</code></li></ul><ul><li><strong>运行jenkins</strong>, 访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li></ul><p><code>java -jar /usr/share/jenkins/jenkins.war</code><br>由于8080端口可能被占用，建议改端口:<br><code>vim /etc/default/jenkins</code> ,找到<code>HTTP_PORT=8080</code> 这一项，将其改为其他端口<br>然后重启<code>sudo systemctl restart jenkins</code></p><p>参考：<a href="https://blog.csdn.net/lsl520hah/article/details/102839940" target="_blank" rel="noopener">https://blog.csdn.net/lsl520hah/article/details/102839940</a></p><h3 id="2-生产服务器准备-ubuntu18-04"><a href="#2-生产服务器准备-ubuntu18-04" class="headerlink" title="2. 生产服务器准备(ubuntu18.04)"></a>2. 生产服务器准备(ubuntu18.04)</h3><ul><li><p>将Django项目文件夹<code>mipin</code>拷贝到生产服务器<code>/home/ubuntu</code>路径下</p><h4 id="2-1-python安装"><a href="#2-1-python安装" class="headerlink" title="2.1 python安装"></a>2.1 python安装</h4></li><li><p>python3.7安装参考：<a href="https://zhuanlan.zhihu.com/p/62930419" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62930419</a></p></li><li><p>python安装完成后，开始安装虚拟环境<code>virtualenv</code></p></li></ul><p><code>sudo pip3.7 install virtualenv</code><br><code>sudo pip3.7 install virtualenvwrapper</code></p><ul><li><p>配置环境变量<code>vim ~/.bashrc</code> ,加入以下内容</p><pre><code class="bash">export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3.7export WORKON_HOME=/home/ubuntu/.virtualenvsexport VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenvsource /usr/local/bin/virtualenvwrapper.sh</code></pre></li><li><p><code>source ~/.bashrc</code></p></li><li><p>创建名为<code>mipin</code>的虚拟环境（作为Django项目运行的虚拟环境）</p></li></ul><p><code>mkvirtualenv mipin</code><br><code>pip install -r /home/ubuntu/mipin/requirements.txt</code></p><h4 id="2-2-部署Django项目"><a href="#2-2-部署Django项目" class="headerlink" title="2.2 部署Django项目"></a>2.2 部署Django项目</h4><p>这里使用uwsgi来运行Django项目，并通过supervisor来管理进程<br>详见：<a href="https://www.yuque.com/docs/share/2ccfaa59-827c-4549-9a6e-1c214c02c2b6?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/2ccfaa59-827c-4549-9a6e-1c214c02c2b6?#</a> 《Supervisor使用》</p><h3 id="3-Jenkins及Gitlab配置"><a href="#3-Jenkins及Gitlab配置" class="headerlink" title="3. Jenkins及Gitlab配置"></a>3. Jenkins及Gitlab配置</h3><h4 id="3-1-安装jenkins插件"><a href="#3-1-安装jenkins插件" class="headerlink" title="3.1 安装jenkins插件"></a>3.1 安装jenkins插件</h4><ul><li>需要安装的插件有<code>Gitlab Hook</code>、 <code>Build Authorization Token Root</code> 、<code>Publish Over SSH</code>、 <code>Gitlab Authentication</code>、 <code>Gitlab</code> 、 <code>Git Parameter</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828951202-5ad3ebf3-ca8c-4094-b89d-6d8561804df0.png?x-oss-process=image%2Fresize%2Cw_746" srcset="/img/loading.gif" alt="1.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828973801-7484a035-641b-4ae2-9e4e-49073f690bd8.png?x-oss-process=image%2Fresize%2Cw_746" srcset="/img/loading.gif" alt="2.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583828993629-bdcb0ae6-583c-4f6c-a4f5-1f64ce770d46.png#align=left&display=inline&height=738&margin=%5Bobject%20Object%5D&name=3.png&originHeight=847&originWidth=856&size=62473&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="3.png"></p><ul><li>安装完插件，重启jenkins</li></ul><h4 id="3-2-配置SSH密钥"><a href="#3-2-配置SSH密钥" class="headerlink" title="3.2 配置SSH密钥"></a>3.2 配置SSH密钥</h4><ul><li>首先在jenkins所在的主机上生成一对SSH密钥</li></ul><p><code>ssh-keygen -t rsa -P &#39;&#39;</code><br>执行这条命令，会在<code>~/.ssh</code>目录下创建2个文件: <code>id_rsa</code> (私钥) 、<code>id_rsa.pub</code> (公钥)</p><ul><li>然后将公钥发送到需要部署代码的主机</li></ul><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;IP&gt;</code> <IP>即需要部署代码的目标主机的ip<br>之后在jenkins所在主机上直接使用<code>ssh &lt;IP&gt;</code> 看是否能免密码登录到目标主机<br>若还有问题请参考：<a href="https://www.cnblogs.com/jager/p/5986563.html" target="_blank" rel="noopener">https://www.cnblogs.com/jager/p/5986563.html</a></p><ul><li>将私钥以及SSH主机配置到jenkins系统设置中</li></ul><p>打开系统设置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583829985077-c86998ae-ad86-42dc-ac6b-488fe094e3c2.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=4.png&originHeight=735&originWidth=974&size=75785&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="4.png"><br>复制私钥内容填入<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830248101-93403417-4ee7-4cc1-af1a-02f08a915d7e.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=5.png&originHeight=333&originWidth=1559&size=35133&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="5.png"><br>添加目标服务器（点击Add）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830601295-27cab8d0-193b-4193-a3b0-d89c73ff80ed.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&name=6.png&originHeight=343&originWidth=1205&size=23845&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="6.png"><br>（如果需要配置多台服务器，同样按上面方法将jenkins所在主机的公钥发到目标服务器，再到这里点击Add添加即可）<br>点击save保存</p><h4 id="3-3-新建jenkins项目"><a href="#3-3-新建jenkins项目" class="headerlink" title="3.3 新建jenkins项目"></a>3.3 新建jenkins项目</h4><ul><li>新建项目</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583830970033-db9c5bae-6a33-415b-9830-ddc5cd164b86.png#align=left&display=inline&height=574&margin=%5Bobject%20Object%5D&name=7.png&originHeight=574&originWidth=381&size=22969&status=done&style=stroke&width=381" srcset="/img/loading.gif" alt="7.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583831000929-b495b4b5-d5de-438c-be80-ba99854e8194.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=8.png&originHeight=739&originWidth=1300&size=81736&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="8.png"></p><ul><li>配置项目</li></ul><p>点击Add添加Git认证密钥<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583832896451-4e9bcb15-9972-4ce7-ba92-3703b27c2186.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&name=9.png&originHeight=545&originWidth=1462&size=34995&status=done&style=none&width=1462" srcset="/img/loading.gif" alt="9.png"><br>复制自己开发电脑的私钥到这里（前提是已经在Gitlab上添加了自己的公钥）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583833269657-a234b492-5cc2-426f-a48c-9847d533e022.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=10.png&originHeight=690&originWidth=1431&size=48284&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="10.png"></p><ul><li>如何在Gitlab上添加公钥</li></ul><p>点击Gitlab右上角个人中心的Settings进入设置页面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583833629109-956ca706-a023-4b46-a14b-bb2ba49b7806.png#align=left&display=inline&height=378&margin=%5Bobject%20Object%5D&name=11.png&originHeight=796&originWidth=1571&size=59650&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="11.png"></p><ul><li>配置build triggers（记录url以及secret token,用于后面Gitlab中webhook的配置）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834522906-50d40cce-81c3-4253-b007-d656079d956a.png#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&name=12.png&originHeight=627&originWidth=1005&size=40222&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="12.png"><br>点击Advanced<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834550396-889bcc55-30d8-4f7d-8365-46f2ee5a763d.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=13.png&originHeight=392&originWidth=1010&size=25759&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="13.png"></p><ul><li>配置部署参数</li></ul><p>在部署的时候，有时可能需要配置一些可变参数，这些参数能够在后续执行部署脚本（Exec command）的时候获取到<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1608516530013-3035fc36-905b-4148-9c05-8691021dcd8e.png#align=left&display=inline&height=875&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201221100828.png&originHeight=875&originWidth=1064&size=43899&status=done&style=none&width=1064" srcset="/img/loading.gif" alt="微信截图_20201221100828.png"></p><ul><li>配置构建步骤</li></ul><p>这里同样可以配置多个服务器，点击Add server添加即可<br>另外，建议将Advanced中Exec timeout(命令执行的超时时间)调整大一点  ， 按照下图配置</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583834823283-e0ab6c91-6d17-4a1b-ae02-d90a43f2ba04.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&name=14.png&originHeight=736&originWidth=1441&size=63525&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="14.png"><br>Exec command一栏即代码传输到服务器之后需要执行的构建步骤，上图是一个简单的示例。实际生产中，我们是使用supervisor来管理进程，并且还需要进行代码备份，以方便后续回滚，一个完整的脚本如下：</p><pre><code class="shell">case $Status  in  Deploy)    echo &quot;Status:$Status&quot;    bak_path=&quot;/home/ubuntu/bak/mipin/${BUILD_NUMBER}&quot;      #创建每次要备份的目录    if [ -d $bak_path ];    then        echo &quot;The files is already  exists &quot;    else        sudo mkdir -p $bak_path    fi    \sudo cp -rf /home/ubuntu/mipin/* $bak_path        #将项目备份到相应目录,覆盖已存在的目标    sudo /home/ubuntu/.virtualenvs/mipin/bin/pip install -r /home/ubuntu/mipin/requirements.txt    sudo supervisorctl restart mipin    echo &quot;Completing!&quot;    ;;  Rollback)      echo &quot;Status:$Status&quot;      echo &quot;Version:$Version&quot;      cd /home/ubuntu/bak/mipin/$Version            #进入备份目录      \sudo cp -rf ./* /home/ubuntu/mipin/       #将备份拷贝到程序打包目录中      sudo supervisorctl restart mipin      ;;  *)  exit      ;;esac# 删除旧的代码ReservedNum=5  #保留文件数FileDir=/home/ubuntu/bak/mipindate=$(date &quot;+%Y%m%d-%H%M%S&quot;)cd $FileDir   #进入备份目录FileNum=$(ls -l | grep &#39;^d&#39; | wc -l)   #当前有几个文件夹，即几个备份while(( $FileNum &gt; $ReservedNum))do    OldFile=$(ls -rt | head -1)         #获取最旧的那个备份文件夹    echo  $date &quot;Delete File:&quot;$OldFile    sudo rm -rf $FileDir/$OldFile    let &quot;FileNum--&quot;done </code></pre><h4 id="3-4-Gitlab配置webhook"><a href="#3-4-Gitlab配置webhook" class="headerlink" title="3.4 Gitlab配置webhook"></a>3.4 Gitlab配置webhook</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835155725-e1fd4754-6815-4616-af55-702f4beb2447.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=15.png&originHeight=895&originWidth=1574&size=77341&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="15.png"><br>测试<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835253463-46417bb9-70b7-4870-9b42-c8d5414615e7.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=16.png&originHeight=473&originWidth=832&size=32858&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="16.png"></p><h4 id="3-5-如何查看部署结果"><a href="#3-5-如何查看部署结果" class="headerlink" title="3.5 如何查看部署结果"></a>3.5 如何查看部署结果</h4><p>做完以上步骤，可以尝试在本地push代码到Gitlab，然后登陆Jenkins查看部署结果<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835612136-db25d301-2a62-4cc3-8162-31f48d14d8ec.png#align=left&display=inline&height=721&margin=%5Bobject%20Object%5D&name=17.png&originHeight=778&originWidth=805&size=63084&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="17.png"><br>点击console output查看控制台输出<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1583835595912-9860a832-5d31-4db3-8d17-87dd04c3ecaa.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&name=18.png&originHeight=875&originWidth=1534&size=94438&status=done&style=stroke&width=746" srcset="/img/loading.gif" alt="18.png"></p><h4 id="3-6-回滚"><a href="#3-6-回滚" class="headerlink" title="3.6 回滚"></a>3.6 回滚</h4><p>由于在配置时加入了构建参数，因此我们可以在手动构建的时候根据情况选择<br><img src="https://cdn.nlark.com/yuque/0/2020/png/480333/1608519958808-ebb8f773-de75-4975-96c4-5fb408c71ee4.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&name=jenkins222.png&originHeight=564&originWidth=815&size=46029&status=done&style=stroke&width=815" srcset="/img/loading.gif" alt="jenkins222.png"></p><h3 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h3><p>Ubuntu18.04安装Jenkins ： <a href="https://blog.csdn.net/lsl520hah/article/details/102839940" target="_blank" rel="noopener">https://blog.csdn.net/lsl520hah/article/details/102839940</a><br>Gitlab + Jenkins实现自动部署：<a href="https://blog.51cto.com/bigboss/2129477" target="_blank" rel="noopener">https://blog.51cto.com/bigboss/2129477</a></p>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Supervisor部署Django项目</title>
    <link href="/2020/12/22/Supervisor%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/12/22/Supervisor%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>supervisor是一个python开发的、通用的进程监控、管理工具，可以将一个普通的命令行进程变为后台daemon,并且监控进程状态，异常自动重启。相较于nohup的方式，这种部署方式使用起来更方便简洁，并且运行也更稳定。</p><a id="more"></a><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p><code>sudo apt-get install -y supervisor</code></p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><p><code>cd /etc/supervisor/conf.d/</code><br><code>sudo vim mipin.conf</code></p><ul><li><p>uwsgi启动配置示例：</p><pre><code class="bash">[program:go2home]directory = /home/ubuntu/go2home/GoToHome ;程序的启动目录command= /home/ubuntu/.pyenv/versions/go2home/bin/uwsgi --ini uwsgi.ini ;启动命令autostart = true     ; 在 supervisord 启动的时候也自动启动startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true   ; 程序异常退出后自动重启startretries = 3     ; 启动失败自动重试次数，默认是 3user = ubuntu          ; 用哪个用户启动redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20     ; stdout 日志文件备份数;stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录(supervisord 会自动创建日志文件)stdout_logfile = /home/ubuntu/go2home/logs/stdout.log;然后确保杀死主进程后，子进程也可以停止stopasgroup=truekillasgroup=true</code></pre></li><li><p>daphne启动配置示例：</p><pre><code class="bash">[program:mipin]directory=/home/ubuntu/mipin/MiPincommand=/home/ubuntu/.virtualenvs/mipin/bin/daphne -b 127.0.0.1 -p 8090 --proxy-headers MiPin.asgi:applicationautostart=falseautorestart=falsestdout_logfile=/home/ubuntu/mipin/logs/out.logloglevel=debugredirect_stderr=true[supervisord]</code></pre></li><li><p>启动项目:</p></li></ul><p><code>sudo supervisord -c mipin.conf</code></p><h2 id="3-supervisor基本操作"><a href="#3-supervisor基本操作" class="headerlink" title="3.supervisor基本操作"></a>3.supervisor基本操作</h2><pre><code># 停止某一个进程，program_name 为 [program:x] 里的 xsupervisorctl stop program_name# 启动某个进程supervisorctl start program_name# 重启某个进程supervisorctl restart program_name# 结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)supervisorctl stop groupworker:# 结束 groupworker:name1 这个进程 (start，restart 同理)supervisorctl stop groupworker:name1# 停止全部进程，注：start、restart、stop 都不会载入最新的配置文件supervisorctl stop all# 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程supervisorctl reload# 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启supervisorctl update</code></pre><h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4.问题"></a>4.问题</h2><ul><li><code>error: &lt;class &#39;socket.error&#39;&gt;, [Errno 2] No such file or directory: file: /usr/lib/python2.7/socket.py line: 228</code></li></ul><p>使用命令 <code>supervisord -c /etc/supervisor/supervisord.conf</code>启动<br>查看状态   <code>sudo supervisorctl status</code></p><ul><li>权限不足</li></ul><p><code>sudo vim /etc/supervisor/supervisord.conf</code><br>在<code>[unix_http_server]</code> 和 <code>[unix_http_server]</code> 2处配置下，加入：<br>username=name<br>password=password</p><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5.参考链接"></a>5.参考链接</h2><p><a href="https://www.cnblogs.com/xiao987334176/p/11329923.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiao987334176/p/11329923.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>supervisor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose启动Mysql和Redis</title>
    <link href="/2020/12/21/docker-compose%E5%90%AF%E5%8A%A8Mysql%20&amp;%20Redis/"/>
    <url>/2020/12/21/docker-compose%E5%90%AF%E5%8A%A8Mysql%20&amp;%20Redis/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了如何使用Docker快速在本地部署一套Mysql + Redis</p><a id="more"></a><h3 id="1-创建文件夹、下载Redis配置文件"><a href="#1-创建文件夹、下载Redis配置文件" class="headerlink" title="1.创建文件夹、下载Redis配置文件"></a>1.创建文件夹、下载Redis配置文件</h3><p><code>mkdir -p /docker/mysql /docker/redis</code><br><code>cd /docker/redis</code><br><code>wget http://download.redis.io/redis-stable/redis.conf</code></p><h3 id="2-修改Redis配置文件"><a href="#2-修改Redis配置文件" class="headerlink" title="2.修改Redis配置文件"></a>2.修改Redis配置文件</h3><p><code>vim redis.conf</code><br>修改以下配置以允许redis远程连接：</p><pre><code>protected-mode no# bind 127.0.0.1</code></pre><h3 id="3-下载docker-compose"><a href="#3-下载docker-compose" class="headerlink" title="3.下载docker-compose"></a>3.下载docker-compose</h3><p><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-</code>uname -s<code>-</code>uname -m<code>&gt; /usr/local/bin/docker-compose</code><br><code>sudo chmod +x /usr/local/bin/docker-compose</code></p><h3 id="4-编写docker-compose-yaml"><a href="#4-编写docker-compose-yaml" class="headerlink" title="4.编写docker-compose.yaml"></a>4.编写docker-compose.yaml</h3><pre><code class="yaml">version: &quot;3&quot;services:  mysql:    # 指定镜像    image: mysql:5.7    # 指定容器名称    container_name: mysql_container    environment:      - MYSQL_ROOT_PASSWORD=123456    volumes:      - /docker/mysql/conf:/etc/mysql      - /docker/mysql/logs:/var/log/mysql      - /docker/mysql/data:/var/lib/mysql    # 端口映射    ports:      - 3307:3306    # 网络和ip    networks:      extnetwork:        ipv4_address: 192.168.0.2    privileged: true    restart: always  redis:    image: redis    container_name: redis_container    ports:      - 6380:6379    volumes:      - /docker/redis/data:/data      - /docker/redis/redis.conf:/etc/redis/redis.conf    command: redis-server /etc/redis/redis.conf    networks:      extnetwork:        ipv4_address: 192.168.0.3    privileged: true    restart: alwaysnetworks:  extnetwork:    ipam:      config:        - subnet: 192.168.0.0/16</code></pre><h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5.启动"></a>5.启动</h3><p><code>docker-compose -f docker-compose.yaml up -d</code></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git简介及常用操作</title>
    <link href="/2020/02/20/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/02/20/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，本文介绍了Ｇｉｔ的一些基本概念及常用操作。</p><a id="more"></a><h2 id="1-Git基本概念"><a href="#1-Git基本概念" class="headerlink" title="1.Git基本概念"></a>1.Git基本概念</h2><p>Git是一个分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><ul><li>工作区 (Workspace)</li></ul><p>即我们进行代码/文件的增、删、改等操作的本机目录</p><ul><li>暂存区 (Index/Stage)</li></ul><p>用来暂存被改动文件的空间。在本地修改代码后，可以通过<code>git add</code>命令将变动保存到暂存区<br>暂存区的作用：<code>commit</code>操作是原子性的，我们可以挑选自己想记录提交的内容形成一次<code>commit</code><br>     方便撤销修改<code>git checkout</code><br>     对比工作区和暂存区的文件差异<code>git diff</code></p><ul><li>本地仓库 (Repository)</li></ul><p>即项目目录下的<code>.git</code>文件夹，保存了所有和该项目有关的历史记录，<code>commit</code>的结果被保存在本地仓库中<br><code>git init</code>命令可以初始化一个git本地仓库</p><ul><li>远程仓库 (Remote)</li></ul><p>用于项目协作的远程仓库，存放在远程主机上</p><p><img src="/img/Git/1.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><h2 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h2><ul><li><strong>git init</strong></li></ul><p>初始化一个git本地仓库，即生成<code>.git</code>文件夹</p><ul><li><strong>git clone</strong></li></ul><p>从远程主机克隆版本库到本地，一般使用HTTP(s)协议，还支持SSH、Git、ftp等协议。<br>克隆时，所使用的远程主机自动被命名为<code>origin</code>,可以通过<code>-o</code>参数自定义命名，例如<code>git clone -o jQuery https://github.com/jquery/jquery.git</code></p><ul><li><strong>git add</strong></li></ul><p>在工作区修改完文件，可以通过<code>git add .</code>将所有改动提交到暂存区，也可以指定个别文件，如<code>git add a.txt</code></p><ul><li><strong>git commit</strong></li></ul><p>暂存区的文件需要经过<code>git commit -m &#39;commit info&#39;</code>才会提交到本地仓库中，<code>commit</code>会生成一条版本记录</p><ul><li><strong>git push</strong></li></ul><p>推送代码到远程仓库，例如<code>git push 远程主机名 本地分支名:远程分支名</code><br>如果当前分支与远程分支存在追踪关系，则可以写成<code>git push origin</code><br>如果当前分支只有一个追踪分支（只关联了一个远程主机），则可直接写<code>git push</code><br>如果当前分支与多个远程主机存在追踪关系，则可使用<code>-u</code>参数指定默认主机，如<code>git push -u origin master</code>,之后<code>git push</code>便会默认推送到<code>origin</code>主机</p><p>注意，<code>git push</code>有<code>matching</code>模式和<code>simple</code>模式，matching模式会推送所有有对应的远程分支的本地分支，而simple模式只会推送当前分支。Git2.0版本前，默认采用<code>matching</code>模式，之后默认<code>simple</code>模式。可以通过<code>git config</code>修改：<code>git config --global push.default simple</code></p><ul><li><strong>git pull</strong></li></ul><p>拉取远程主机的某个分支，并与本地分支合并，例如<code>git pull 远程主机名 远程分支名:本地分支名</code><br>如果需要拉取的远程分支是与当前分支合并，则可以写成<code>git pull origin master</code>,这一步相当于先执行<code>git fetch origin</code>,再执行<code>git merge origin/master</code></p><ul><li><strong>git status</strong></li></ul><p>查看文件状态</p><ul><li><strong>git log</strong></li></ul><p>查看<code>commit</code>历史</p><ul><li><strong>git branch</strong></li></ul><p><code>git branch -a</code>查看本地与远程主机的所有分支<br><code>git branch branch_name</code> 新建一个名为branch_name的分支，但仍然停留在当前分支<br><code>git checkout -b branch_name</code> 新建一个名为branch_name的分支，并切换到该分支<br><code>git branch --set-upstream local_branch remote_branch</code> 将本地分支local_branch与远程分支remote_branch建立追踪关系<br><code>git branch -d branch_name</code> 删除本地分支<br><code>git push origin --delete remote_branch</code> 删除远程分支</p><ul><li><strong>git checkout</strong></li></ul><p>拉取远程主机的分支后，可以在它的基础上新建分支，如<code>git checkout -b new_branch</code><br>使用<code>git checout branch_name</code>可以在本地将工作区切换到另一个分支<br>也可用于切换到某次commit : <code>git checkout commit_id</code></p><ul><li><strong>git remote</strong></li></ul><p>为了便于管理，每个远程主机都必须指定一个主机名，<code>git remote -v</code>可以列出所有远程主机名及其地址<br><code>git remote add 主机名 项目地址</code> 用于添加远程主机<br><code>git remote rm 主机名</code> 用于删除远程主机<br><code>git remote rename 原主机名 新主机名</code> 可以重命名远程主机</p><ul><li><strong>git reset</strong></li></ul><p><code>git reset</code>可以重置当前分支到指定<code>commit</code>,有3种模式：<code>mixed</code>、<code>soft</code>、<code>hard</code><br><code>git reset --mixed commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset --soft commit_id</code>：重置当前分支的指针为指定commit，但保持暂存区和工作区不变<br><code>git reset --hard commit_id</code>：重置当前分支的指针为指定commit，同时重置暂存区和工作区，与指定commit一致(这种方式会丢失本地文件的修改)</p><p><img src="/img/Git/2.png" srcset="/img/loading.gif" alt="2.png"></p><ul><li><strong>git tag</strong></li></ul><p>在一个版本完成之后，可以利用git tag打上标签,方便管理与回溯，其作用与commit_id(commit-sha1)类似.<br><code>git tag</code> 查看所有标签<br><code>git tag -a tag_name -m &quot;tag description&quot;</code> 给当前分支打上名称为tag_name的标签，描述为”tag description”<br><code>git push origin tag_name</code> 推送指定tag到远程<br><code>git push origin --tags</code> 推送所有tag到远程<br><code>git tag -d tag_name</code> 删除指定tag</p><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><ul><li><strong>gitignore</strong></li></ul><p>有时项目中有些文件不需要放入远程仓库，可以创建一个<code>.gitignore</code>文件来配置推送时需要忽略的文件，例如：<br>*.py[cod]   忽略所有以.pyc、.pyo、.pyd结尾的文件<br>.idea/        忽略.idea文件夹</p><ul><li><strong>配置公钥</strong></li></ul><p>如果不想每次推送代码都要使用用户名、密码进行认证，可以通过ssh公钥的方式认证，以下是Gitlab配置公钥的示例<br>– 生成公钥<br><code>ssh-keygen -t rsa -C &quot;YOUR EMAIL&quot;</code><br>– 查看公钥并复制<br><code>cat ~/.ssh/id_rsa.pub</code><br>– 将公钥添加到Gitlab<br>Settings &gt;&gt; SSH Keys</p><p><img src="/img/Git/3.png" srcset="/img/loading.gif" alt="3.png"></p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><p>Git原理入门： <a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/git-internals.html</a><br>Git常用命令清单：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>Git reset三种模式：<a href="https://www.jianshu.com/p/c2ec5f06cf1a" target="_blank" rel="noopener">https://www.jianshu.com/p/c2ec5f06cf1a</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用总结</title>
    <link href="/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/08/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker使用总结"><a href="#Docker使用总结" class="headerlink" title="Docker使用总结"></a>Docker使用总结</h1><p>Docker是一个开源容器引擎，它可以将我们的开发环境、代码、配置文件等打包到一个容器中，并发布到任意平台。Docker实现的是操作系统级别的虚拟化，区别于传统的虚拟机，它占用资源少，灵活方便，非常适合web应用的自动化打包和发布以及自动化测试和持续集成、发布。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>镜像 image</strong></li></ul><p>Docker中镜像的概念类似于虚拟机的镜像，它是一个包含有文件系统的面向Docker引擎的只读模板，简单的理解它就是构建一个容器的基础。我们可以基于镜像去创建一个容器，也可以将容器打包成镜像。Docker的官方镜像仓库(Docker hub)中提供了许多软件的镜像，例如我们执行<code>docker search python</code>就可以看到各种python镜像。<br><img src="/img/Docker/1.png" srcset="/img/loading.gif" alt="1.png"><br>实际应用中，我们通常会将自己的开发环境、代码、配置等打包成一个镜像，然后将它发布到生产环境中，这样，就不必为环境是否兼容而担心，因为代码运行所需的一切资源都已经包含的镜像当中了，我们只需要基于它创建容器并启动运行即可。</p><p>要下载某个镜像，可以直接从Docker官方镜像仓库中拉取，例如执行<code>docker pull python</code>就可以直接拉取一个官方python镜像，再执行<code>docker images</code>就可以看到电脑中所有镜像了。以后对镜像指定的操作，可以基于镜像的名字，或者镜像ID（IMAGE ID）。<br><img src="/img/Docker/2.png" srcset="/img/loading.gif" alt="2.png"></p><ul><li><strong>容器 container</strong></li></ul><p>有了镜像我们就可以创建一个容器，容器类似于一个轻量级的沙盒，Docker利用容器来运行、隔离不同的应用，它是镜像创建的应用实例，各个容器之间互不影响。需要注意，镜像本身是只读的，我们基于一个镜像启动了容器，Docker只是在镜像的上层创建了一个可写层，镜像本身不变。执行<code>docker ps -a</code>或者<code>docker container ls -a</code>就可以看到所有正在运行或不在运行的容器：<br><img src="/img/Docker/3.png" srcset="/img/loading.gif" alt="3.png"></p><p>我们可以将一个web应用所有环境都放在同一个容器中，但为了解耦，也可以将不同的应用隔离开来，放在不同容器当中。同样的，每个容器都有自己的名字和ID，如上图所示，<code>IMAGE</code>一栏表示当前容器是基于哪个镜像创建的；<code>COMMAND</code>代表容器启动时执行的命令，通常是某个服务启动的命令，这样容器启动后服务就可以同时启动；<code>PORTS</code>则展示了从宿主机到容器的ip、端口映射关系，例如我们想给某个<code>nginx</code>应用绑定<code>80</code>端口，就可以将宿主机的80端口映射到nginx容器的80端口，这样，访问<code>http://宿主机ip:80</code>将相当于访问<code>nginx</code>应用了。</p><p>关于容器还有一些其他重要概念,主要是在启动容器时可能会使用的一些配置，通常我们使用<code>docker run -xxx xxx image_name</code>创建容器，常用的一些参数如下：</p><p>–后台运行<br>通常启动容器后不加特别参数会直接进入容器，如果想让它在后台运行，可以加上<code>-d</code>参数</p><p>– 重新启动<br>通过<code>--restart=always</code>的形式指定，增加这项配置可以让容器在出现一些情况时自动重启，保证服务正常运行。restart支持4种参数：<br><code>no</code>:容器退出时不要自动重启（默认值）<br><code>on-failure[:max-retries]</code>:只在容器以非0状态码(正常退出)退出时重启，可以指定尝试重启容器的次数<br><code>always</code>:不管退出状态码是什么始终重启容器，docker daemon将无限次数地重启容器<br><code>unless-stopped</code>:不管退出状态码是什么始终重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p><p>– root权限<br>正常启动容器后，进入容器是以root用户执行操作，但它并不完全具有root权限，可以在创建容器时加上<code>--privileged=true</code>来赋予容器真正root权限</p><p>– 文件挂载<br>文件挂载是Docker一个非常重要的特性，我们可以将代码、配置文件等放在宿主机，然后在创建容器时挂载这些目录到容器中，这样，代码更新或者配置更新时，我们只需要更新宿主机路径下的文件，容器内就自动变更了</p><p>– 指定ip<br>docker容器启动后，宿主机默认ip为<code>172.17.0.1</code>，启动的容器按照时间顺序绑定ip,例如<code>172.17.0.2</code>，如果想给容器绑定一个固定的ip,可以创建一个docker 网络，然后在创建容器时绑定一个固定ip。例如执行<code>docker network create --subnet=192.168.0.0/16 staticnet</code>创建一个名为staticnet的私有网络，网段为<code>192.168.0.0/16</code>,之后在创建容器时，就可以通过<code>--net staticnet --ip 192.168.0.2</code>来指定容器ip（注意，在这个子网段中，192.168.0.1是宿主机ip）。</p><ul><li><strong>仓库 repository</strong></li></ul><p>Docker中的仓库用于存放Docker镜像，注意仓库Repository和注册服务器Registry的区别，注册服务器是存放仓库的地方，而仓库是存放镜像的地方。Docker官方镜像仓库是Docker Hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>我们可以从Docker Hub中拉取一些需要镜像，然后在这些镜像的基础上，安装配置代码运行所需的环境，从而制作成一个新的镜像，而制作镜像主要有2种方式，以下以制作python镜像为例：</p><ul><li><strong>docker commit的方式</strong></li></ul><p>–在获取了一个基础镜像后，我们可以基于它启动一个容器，如<code>docker run -itd --name python_container python /bin/bash</code>命令创建并启动一个python容器：<br><img src="/img/Docker/6.png" srcset="/img/loading.gif" alt="6.png"></p><p>查看容器<br><img src="/img/Docker/4.png" srcset="/img/loading.gif" alt="4.png"></p><p>–随后执行<code>docker exec -it python_container /bin/bash</code>进入容器，我们可以在容器中安装依赖环境，例如将项目中的<code>requirements.txt</code>放入容器后执行<code>pip install -r requirements.txt</code>，执行完毕，退出容器</p><p>–最后，通过<code>docker commit python_container new_python_image</code>命令将安装好依赖的python容器打包成一个名为<code>new_python_image</code>的镜像，此时通过<code>docker images</code>就可以看到新的镜像了.<br>提交镜像:<br><img src="/img/Docker/5.png" srcset="/img/loading.gif" alt="5.png"></p><p>查看制作好的镜像:<br><img src="/img/Docker/7.png" srcset="/img/loading.gif" alt="7.png"></p><ul><li><strong>Dockerfile的方式</strong></li></ul><p>通过docker commit将一个容器打包成镜像操作简便、容易理解，但是在安装依赖、环境过程中，大量缓存、无关内容被添加，并且由于Docker镜像是分层存储的，修改容器只是在当前层进行标记、添加、修改，并不会实际改变上一层，因此使用docker commit 的方式制作镜像，会导致镜像越来越臃肿，同时也让后续维护的人无法得知镜像构建的具体步骤。因此，最好使用Dockerfile来构建镜像。</p><p>Dockerfile是一个用来构建镜像的文本文件，其中包含了构建镜像所需的指令和说明，详细文档可参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><p>下面是一个简单的Dockerfile示例：</p><pre><code># 基于python3.6.8镜像FROM python:3.6.8# 复制Django项目所需的依赖文件清单到容器中的/目录下COPY requirements.txt /# 安装项目所需的python依赖RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt</code></pre><p>注意，Dockerfile最好和容器所需的其他文件一起单独放在一个文件夹中。编写完Dockerfile，就可以在Dockerfile所在路径通过<code>docker build -t image_name .</code>开始制作镜像，等待完成即可</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>创建容器最常见的方式是通过<code>docker run</code>命令，详细参数可参考：<a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/</a></p><p>当我们有多个容器需要创建并配置时，可以使用<code>docker-compose</code>工具来编排容器并启动，只需要编写一个yaml文件，再通过一个命令就可以创建并启动所有容器，一个简单示例如下：</p><pre><code class="yaml"># docker_compose.yaml 配置实例version: &quot;3&quot;services:     nginx:         # 指定镜像        image: nginx        # 指定容器名称        container_name: nginx_container        # 端口映射        ports:             - 8080:8080        # 文件挂载路径        volumes:             - /DJANGO_PROJECT:/DJANGO_PROJECT            - /nginx.conf:/etc/nginx/nginx.conf        # 网络和ip        networks:             extnetwork:                 ipv4_address: 192.168.0.2        # 启动后指定的命令        command: nginx -g &#39;daemon off;&#39;        privileged: true        restart: alwaysnetworks:     extnetwork:         ipam:             config:             - subnet: 192.168.0.0/16</code></pre><p>（需要注意，编写yaml时不能使用tag缩进，冒号后必须有空格）</p><p>编写完docker_compose.yaml文件，就可以在该文件路径下执行<code>docker-compose up -d .</code>,一键创建、启动容器。</p><h2 id="参考及链接"><a href="#参考及链接" class="headerlink" title="参考及链接"></a>参考及链接</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/23599229" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23599229</a></p><p>Docker入门介绍及常用命令：<a href="https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&mid=2247488151&idx=1&sn=b65d355055746b8720c0a989b704666a&chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&mpshare=1&scene=1&srcid=&key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&ascene=1&uin=NjE4ODY0Mzg0&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwOTQ4MzY1Nw==&amp;mid=2247488151&amp;idx=1&amp;sn=b65d355055746b8720c0a989b704666a&amp;chksm=9b5fb671ac283f6715f7abc4b2f5b8711ef1b332b8a697a3142531c7691774ed7b7d08936807&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=e85982dd5b83123872824b0bdfaf85bf9311bd5553fa62110ac5171516755e9ded814f7adcdd789a6754a7ebfbd51fbd4926aad92bb4ffdd5cb2ea24f9651c799a4039658b35b500fcd1aee6a10384a8&amp;ascene=1&amp;uin=NjE4ODY0Mzg0&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L9QR67EoPhd2C5D7R1VdlOjgtM6umNlAXPO7aCcqFh8IFpzRjjKzNQc3ITX03%2Fm7</a></p><p>使用Docker部署一套Nginx + uWSGI + Django的范例：<a href="https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/">https://ray-sr.github.io/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Nginx + uWSGI + Django实践</title>
    <link href="/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/12/10/Docker%E9%83%A8%E7%BD%B2Nginx%20+%20uWSGI%20+%20Django%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker容器技术是目前热门的代码部署手段，通过将代码、配置文件、开发环境等打包到一个容器中，就能将其快速部署到生产环境，十分方便快捷。本文将介绍如何使用Docker来部署一套Nginx + uWSGI + Django的生产环境web服务器（Centos7系统）.</p><a id="more"></a><p>阅读前需要对一些基本技术有所了解，以下仅供参考：</p><p>Docker:  <a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html</a><br> <a href="https://zhuanlan.zhihu.com/p/23599229" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23599229</a><br>Nginx、uWSGI：<a href="https://blog.csdn.net/weixin_40907382/article/details/80824167" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40907382/article/details/80824167</a></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><pre><code class="shell"># 查看centos系统版本，内核版本要求不低于3.10uname -r# 更新yumsudo yum -y update# 安装需要的软件包sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置yum源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 查看仓库中所有docker版本yum list docker-ce --showduplicates | sort -r# 选择其中一个版本安装yum -y install docker-ce-18.06.3.ce# 启动Docker服务，并设置为开机启动systemctl start dockersystemctl enable docker# 测试是否安装成功docker version# 安装docker-compose工具（用于容器编排）sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></pre><h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>Nginx：可直接从docker hub中拉取，执行<code>docker pull nginx</code><br>Python：构建uWSGI容器可以基于centos、ubuntu等进行，但为了更轻量化，也可以使用python镜像，同样从docker hub中拉取所需python版本的镜像，例如：<code>docker pull python:3.6.8</code></p><p>接下来，需要基于python镜像制作一个uWSGI服务器镜像。简单的方法是基于python镜像启动一个容器，然后进行python依赖包以及其他环境的安装，随后使用<code>docker commit</code>打包为镜像，但这样做有一些坏处：<br>在容器内安装一些依赖、环境时，会有大量无关内容被添加，并且由于镜像的分层存储，修改容器仅仅是在当前层进行标记、添加、修改，并不会改变上一层，因此使用<code>docker commit</code>制作镜像，会导致镜像越来越臃肿；其次，由于使用<code>docker commit</code>制作的镜像对于其他人来说是黑箱操作，后续进行维护的人无法得知镜像是如何构建的，增加了维护风险和难度。<br>因此，我们使用Dockerfile来构建uWSGI容器，关于Dockerfile的编写本文不再赘述，请参考：<a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a>，一个简单的Dockerfile如下：</p><pre><code class="shell"># 基于python3.6.8镜像FROM python:3.6.8# 复制Django项目所需的依赖文件清单到容器中COPY requirements.txt /# 安装依赖RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r /requirements.txt# 创建uwsgi软链接RUN ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>镜像制作完成，就可以开始创建容器了，可以直接使用<code>docker run</code>命令来创建，也可以使用<code>docker-compose</code>工具，下面首先介绍<code>docker run</code>的方式：</p><p>Nginx: </p><pre><code class="shell">docker run -it --name nginx_container --privileged=true -p 443:443 -p 8080:8080 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /nginx.conf:/etc/nginx/nginx.conf --net staticnet --ip 192.168.0.2 --restart=always -d nginx</code></pre><p>uWSGI：</p><pre><code class="shell">docker run -it --name uwsgi_container --privileged=true -p 8090:8090 -v /DJANGO_PROJECT:/DJANGO_PROJECT -v /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages --net staticnet --ip 192.168.0.3 --restart=always -d uwsgi_image uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini</code></pre><p>参数解释：<br><code>-it</code>：让Docker分配一个伪终端,并绑定到容器的标准输入上<br><code>--name</code>：指定容器的名称<br><code>--privileged</code>：让容器内的root用户拥有真正root权限<br><code>-p</code>：指定端口映射，将宿主机的端口映射到容器端口<br><code>-v</code>：指定文件挂载路径，将Django项目、nginx配置文件放在宿主机，然后挂载到容器<br>  说明：uWSGI容器启动时，将宿主机中一个虚拟环境（安装有Django项目所需的python依赖）的依赖包存放路径挂载到容器中python3依赖包存放路径，这样做的初衷是方便后续有新的依赖包需要安装时，可以直接在宿主机下安装，而不需要进入容器。但在实际应用中发现，某些依赖包使用这样方式安装后不会产生软链接，容器内无法使用，因此实际在制作uWSGI镜像时已经进行了依赖安装。后续将会尝试同时挂载python的site-packages目录和bin目录，也许可以解决这个问题。<br><code>--net</code>：指定容器所在的网段（需要提前创建一个网段）<br><code>--ip</code>：指定容器的ip。如果不特别指定，容器默认使用172.17.0.x的ip，并且会根据启动顺序变动<br><code>--restart</code>：在容器退出时总是重启容器，保证容器始终运行<br><code>-d</code>：让容器在后台运行</p><h2 id="使用docker-compose工具"><a href="#使用docker-compose工具" class="headerlink" title="使用docker-compose工具"></a>使用docker-compose工具</h2><p>使用<code>docker run</code>命令可以创建并启动容器，但需要一个个容器地启动，这里推荐使用docker-compose工具来进行容器编排和启动。只需要编写一个<code>docker_compose.yaml</code>文件，然后通过<code>docker-compose up -d .</code>命令就可以一次性编排、启动多个容器。以下是docker_compose.yaml文件示例：</p><pre><code class="shell">version: &quot;3&quot;services:     nginx:             # 指定镜像        image: nginx        # 指定容器名称        container_name: nginx_container        # 端口映射        ports:             - 8080:8080        # 文件挂载路径        volumes:             - /DJANGO_PROJECT:/DJANGO_PROJECT            - /nginx.conf:/etc/nginx/nginx.conf        # 网络和ip        networks:             extnetwork:                 ipv4_address: 192.168.0.2        # 启动后指定的命令        command: nginx -g &#39;daemon off;&#39;        privileged: true        restart: always    uwsgi:        container_name: uwsgi_container        ports:             - 8090:8090        volumes:            - /DJANGO_PROJECT:/DJANGO_PROJECT            - /.virtualenvs/django_project/lib/python3.6/site-packages:/usr/local/lib/python3.6/site-packages        networks:            extnetwork:                 ipv4_address: 192.168.0.3        privileged: true        command: uwsgi --ini /DJANGO_PROJECT/project/project/uwsgi.ini        restart: always        networks:     extnetwork:         ipam:             config:             - subnet: 192.168.0.0/16</code></pre><p>注意：Nginx容器的启动命令是<code>nginx -g &#39;daemon off;&#39;</code>，这是因为容器启动后执行nginx启动命令开启的nginx进程是第一个进程(pid=1)，而Docker容器将pid=1的进程是否存在作为容器是否正在运行的依据，nginx默认以daemon方式运行，执行完启动命令就在后台运行，此时Docker判断pid=1的进程终止，容器就会退出（如果设置了restart=always参数，则容器会一直重启），因此需要加上<code>daemon off</code>参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上使用Docker技术部署一套Nginx + uWSGI + Django的web服务器，是使用Docker技术的一次尝试，主要是利用了Docker文件挂载的这一方式来实现，在实际使用过程中，也发现一些小问题需要优化，欢迎大家有更好的想法和我交流。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Docker</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Orthanc + OHIF 搭建DICOM web viewer</title>
    <link href="/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/"/>
    <url>/2019/12/08/Orthanc%20+%20OHIF%20%E6%90%AD%E5%BB%BADICOM%20web%20viewer/</url>
    
    <content type="html"><![CDATA[<p>常规的DICOM viewer一般是桌面软件，如果需要通过浏览器查看DICOM影像，可以借助一些开源软件。本文将介绍如何利用开源DICOM server <code>Orhtanc</code>以及DICOM web viewer <code>OHIF viewer</code>搭建一套DICOM阅片系统。</p><a id="more"></a><h2 id="Orthanc"><a href="#Orthanc" class="headerlink" title="Orthanc"></a>Orthanc</h2><p>Orthanc是一个轻量级的、模块化的DICOM服务器，除了实现DICOM协议、WADO协议，它还提供了REST API以及丰富的插件。由于它提供了便捷的REST API，orthanc可以使用任何语言开发，它存储的DICOM图像标签可以通过JSON格式下载，并且orthanc对于存储的DICOM实例可以动态生成对应的PNG图像。</p><p>关于Orthanc的使用可以参考其官方文档：<br><a href="https://book.orthanc-server.com/index.html" target="_blank" rel="noopener">https://book.orthanc-server.com/index.html</a></p><p>Orthanc可以运行在windows以及Linux平台下，可以使用其二进制包安装或者编译源码，同时它也提供了Docker镜像，以下介绍通过Docker的方式运行一个Orthanc服务：</p><ul><li>查看镜像</li></ul><p><code>docker search orthanc</code></p><p><img src="https://s2.ax1x.com/2020/01/08/lgt2jJ.png" srcset="/img/loading.gif" alt="lgt2jJ.png"></p><ul><li>拉取镜像(注意，只有orthanc-plugins才提供REST API)</li></ul><p><code>docker pull jodogne/orthanc-plugins</code></p><ul><li>启动容器</li></ul><p><code>mkdir /tmp/orthanc-db</code> (创建文件夹用于存放orthanc数据,即DICOM数据)<br><code>sudo docker run --name orthanc -p 4242:4242 -p 8042:8042 --restart=always -v /tmp/orthanc-db/:/var/lib/orthanc/db/ jodogne/orthanc-plugins</code></p><ul><li>网页查看</li></ul><p><code>http://orthanc所在的服务器ip:8042</code><br>默认账号：  orthanc<br>默认密码：  orthanc<br>可以通过Upload按钮进行文件上传页面，上传DICOM影像</p><p>至此orthanc就安装完毕，DICOM viewer（例如OHIF）就可以通过REST API调用，具体API参考：<a href="https://book.orthanc-server.com/users/rest.html" target="_blank" rel="noopener">https://book.orthanc-server.com/users/rest.html</a></p><p>在前面创建容器时挂载的目录<code>/var/lib/orthanc/db</code>即orthanc中DICOM文件存放的路径，对应宿主机即<code>/tmp/orthanc-db/</code>.Orthanc会将DICOM原始文件、DICOM tag分别作为2个文件存放在这个路径下<br><img src="https://s2.ax1x.com/2020/01/08/lgafBj.png" srcset="/img/loading.gif" alt="lgafBj.png"></p><h2 id="OHIF-Viewer"><a href="#OHIF-Viewer" class="headerlink" title="OHIF Viewer"></a>OHIF Viewer</h2><p>OHIF Viewer是一套基于Cornerstone（一套JavaScript底层组件，用于支持医学影像的显示与交互）开发的纯网页版医学影像浏览前端。其github地址为：<a href="https://github.com/OHIF/Viewers" target="_blank" rel="noopener">https://github.com/OHIF/Viewers</a></p><p>启动项目非常简单，只需要clone下来然后在项目根目录执行<code>yarn install</code>、<code>yarn run dev</code>即可（官方文档<a href="https://docs.ohif.org/" target="_blank" rel="noopener">https://docs.ohif.org/</a>），不过它默认是连接OHIF提供的一个远程DICOM服务，我们需要修改配置，让它连接到Orthanc。<br>打开<code>platform/viewer/package.json</code>修改proxy的值为之前启动的Orthanc服务地址，例如<code>&quot;proxy&quot;: &quot;http://192.168.0.23:8042&quot;</code>，然后执行<code>yarn run dev:orthanc</code>即可对接Orthanc,初次查看影像需要输入orthanc的账号密码（默认）。</p>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Orthanc</tag>
      
      <tag>OHIF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DICOM Tag中文编码问题</title>
    <link href="/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/15/DICOM%20Tag%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>DICOM Tag信息一般都以英文存储，出现中文时，可能会出现显示为乱码的情况，而导致乱码的原因通常是，存储的信息含有中文，而DICOM tag中指定的编码格式<code>SpecificCharacterSet</code>并不支持中文.</p><a id="more"></a><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>常见的DICOM tag编码格式一般是<code>ISO_IR 100</code>，存储于<code>SpecificCharacterSet</code>（即0008,0005） tag中，该编码格式并不支持中文，因此DICOM信息中出现中文时，最好将这个tag的值改为<code>ISO_IR 192</code>即UTF-8编码。常见的DICOM tag编码对应关系可参考：</p><pre><code class="python">    &#39;ISO_IR 100&#39;: &#39;latin_1&#39;,    &#39;ISO_IR 101&#39;: &#39;iso8859_2&#39;,    &#39;ISO_IR 109&#39;: &#39;iso8859_3&#39;,    &#39;ISO_IR 110&#39;: &#39;iso8859_4&#39;,    &#39;ISO_IR 126&#39;: &#39;iso_ir_126&#39;,  # Greek    &#39;ISO_IR 127&#39;: &#39;iso_ir_127&#39;,  # Arabic    &#39;ISO_IR 138&#39;: &#39;iso_ir_138&#39;,  # Hebrew    &#39;ISO_IR 144&#39;: &#39;iso_ir_144&#39;,  # Russian    &#39;ISO_IR 148&#39;: &#39;iso_ir_148&#39;,  # Turkish    &#39;ISO_IR 166&#39;: &#39;iso_ir_166&#39;,  # Thai    &#39;ISO 2022 IR 6&#39;: &#39;iso8859&#39;,  # alias for latin_1 too    &#39;ISO 2022 IR 13&#39;: &#39;shift_jis&#39;,    &#39;ISO 2022 IR 87&#39;: &#39;iso2022_jp&#39;,    &#39;ISO 2022 IR 100&#39;: &#39;latin_1&#39;,    &#39;ISO 2022 IR 101&#39;: &#39;iso8859_2&#39;,    &#39;ISO 2022 IR 109&#39;: &#39;iso8859_3&#39;,    &#39;ISO 2022 IR 110&#39;: &#39;iso8859_4&#39;,    &#39;ISO 2022 IR 126&#39;: &#39;iso_ir_126&#39;,    &#39;ISO 2022 IR 127&#39;: &#39;iso_ir_127&#39;,    &#39;ISO 2022 IR 138&#39;: &#39;iso_ir_138&#39;,    &#39;ISO 2022 IR 144&#39;: &#39;iso_ir_144&#39;,    &#39;ISO 2022 IR 148&#39;: &#39;iso_ir_148&#39;,    &#39;ISO 2022 IR 149&#39;: &#39;euc_kr&#39;,    &#39;ISO 2022 IR 159&#39;: &#39;iso2022_jp_2&#39;,    &#39;ISO 2022 IR 166&#39;: &#39;iso_ir_166&#39;,    &#39;ISO 2022 IR 58&#39;: &#39;iso_ir_58&#39;,    &#39;ISO_IR 192&#39;: &#39;UTF8&#39;,  # from Chinese example, 2008 PS3.5 Annex J p1-4    &#39;GB18030&#39;: &#39;GB18030&#39;,    &#39;ISO 2022 GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234    &#39;ISO 2022 58&#39;: &#39;GB2312&#39;,  # from DICOM correction CP1234    &#39;GBK&#39;: &#39;GBK&#39;,  # from DICOM correction CP1234</code></pre><h2 id="使用SimpleITK读取DICOM-tag"><a href="#使用SimpleITK读取DICOM-tag" class="headerlink" title="使用SimpleITK读取DICOM tag"></a>使用SimpleITK读取DICOM tag</h2><p>DICOM tag中含有中文时，可以利用SimpleITK读取Tag信息并转换为GBK编码，随后可以使用pydicom改变<code>SpecificCharacterSet</code>的值为<code>ISO_IR 192</code>(暂时未找到SimpleITK改变DICOM tag的方法)。以下是读取DICOM tag中<code>PatientName</code>并改变编码的示例：</p><pre><code class="python">import SimpleITK as sitkdcm_path = &#39;/path_to_dcm&#39;dcm = sitk.ReadImage(dcm_path)patient_name = dcm.GetMetaData(&#39;0010|0010&#39;).strip().encode(&quot;utf-8&quot;, &quot;surrogateescape&quot;).decode(&#39;gbk&#39;, &#39;replace&#39;)ds = pydicom.dcmread(dcm_path)ds.SpecificCharacterSet = &#39;ISO_IR 192&#39;ds.PatientName = patient_nameds.save_as(dcm_path)</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Python</tag>
      
      <tag>pydicom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python将PDF转换为DICOM格式</title>
    <link href="/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/"/>
    <url>/2019/06/25/%E4%BD%BF%E7%94%A8python%E5%B0%86PDF%E8%BD%AC%E6%8D%A2%E4%B8%BADICOM%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>由于公司业务需要，尝试将AI辅助诊断报告（PDF格式）转换为DICOM格式，这样，当DICOM影像上传到云平台计算完成后，可以将生成的AI辅助诊断报告推送到医院PACS系统，医生就可以在DICOM viewer中同时看到病人原始影像和AI报告。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>DICOM影像通常分为三个层级：<code>Study</code>、<code>Series</code>、<code>Instance</code>，其中Study代表病人一次检查的全部影像，通常放在一个文件夹内，而Series则代表这次检查中的不同影像序列，每个序列的扫描参数、用途各有差异，而Instance则是代表每张影像的实体。为了区分影像，DICOM标准中对于Study、Series、Intance的序号（UID）命名有着明确的规范，另外对于影像的编码格式、传输语法以及影像信息都有要求，在创建DICOM影像时都要注意。</p><p>DICOM tag信息主要分为三大部分，第一部分File Meta文件头，指定了影像最重要的基本信息，包含编码格式、传输语法等信息，第二部分则是常规的病人信息、影像信息字段，而影像的像素数据则保存在第三部分<code>Pixel Data</code>字段中。</p><p>为了将PDF报告转换成DICOM格式，可以先利用<code>pdf2image</code>将PDF转换为常见的图片格式，再将图片转换为<code>bytes</code>类型数据，写入DICOM tag中的<code>Pixel Data</code>字段，同时还需要给这些创建的DICOM影像指定UID、编码格式、传输语法等Tag信息。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是PDF转DICOM的参考代码，注意这里的应用情况是将PDF转换后的DICOM影像写入到原始DICOM文件夹中，支持含有多页的PDF文件</p><pre><code class="python">import osimport tempfileimport datetimeimport pydicomfrom pydicom.dataset import Dataset, FileDatasetfrom pdf2image import convert_from_path# 从DICOM study文件夹中读取影像，返回最后一张（InstanceUID最大的一张）影像信息的字典def read_dcm(dicom_dir):    dicom_list = os.listdir(dicom_dir)    info_list = []    for dicom in dicom_list:        # 使用pydicom读取DICOM影像信息        ds = pydicom.dcmread(os.path.join(dicom_dir, dicom))        info_dict = {            &#39;MediaStorageSOPInstanceUID&#39;: ds.file_meta.MediaStorageSOPInstanceUID,            &#39;MediaStorageSOPClassUID&#39;: ds.file_meta.MediaStorageSOPClassUID,            &#39;ImplementationClassUID&#39;: ds.file_meta.ImplementationClassUID,            &#39;PatientName&#39;: ds.PatientName,            &#39;PatientID&#39;: ds.PatientID,            &#39;PatientSex&#39;: ds.PatientSex,            &#39;PatientBirthDate&#39;: ds.PatientBirthDate,            &#39;PatientAge&#39;: ds.PatientAge,            &#39;ContentDate&#39;: ds.ContentDate,            &#39;ContentTime&#39;: ds.ContentTime,            &#39;SOPClassUID&#39;: ds.SOPClassUID,            &#39;SOPInstanceUID&#39;: ds.SOPInstanceUID,            &#39;StudyInstanceUID&#39;: ds.StudyInstanceUID,            &#39;SeriesInstanceUID&#39;: ds.SeriesInstanceUID,            &#39;InstanceNumber&#39;: ds.InstanceNumber,            &#39;SeriesNumber&#39;: ds.SeriesNumber,        }        info_list.append(info_dict)    # 根据InstanceUID排序    sort_list = sorted(info_list, key=lambda x: x[&#39;MediaStorageSOPInstanceUID&#39;])    return sort_list[-1]# 将pdf报告转换后的图片数据写入DICOM影像，并放到原始DICOM文件夹中def write_dcm(index, img, dicom, dicom_dir):    # 用于将InstanceUID尾数加1    chguid = lambda x: x.replace(x[-1], str(int(x[-1]) + index + 1))    # 创建临时文件名    suffix = &#39;.dcm&#39;    filename_little_endian = tempfile.NamedTemporaryFile(suffix=suffix).name    # filename_big_endian = tempfile.NamedTemporaryFile(suffix=suffix).name    # 填充DICOM文件头必要信息    file_meta = Dataset()    file_meta.MediaStorageSOPClassUID = dicom[&#39;MediaStorageSOPClassUID&#39;]    file_meta.MediaStorageSOPInstanceUID = chguid(dicom[&#39;MediaStorageSOPInstanceUID&#39;])    file_meta.ImplementationClassUID = dicom[&#39;ImplementationClassUID&#39;]    # 创建一个FileDataset实例，初始时没有影像数据，只提供文件头(file meta)    ds = FileDataset(filename_little_endian, {}, file_meta=file_meta, preamble=b&quot;\0&quot; * 128)    # 加入DICOM tag信息（不包含所有）    ds.PatientName = dicom[&#39;PatientName&#39;]    ds.PatientID = dicom[&#39;PatientID&#39;]    ds.PatientSex = dicom[&#39;PatientSex&#39;]    ds.PatientBirthDate = dicom[&#39;PatientBirthDate&#39;]    ds.PatientAge = dicom[&#39;PatientAge&#39;]    # Set the transfer syntax    # ds.is_little_endian = True    # ds.is_implicit_VR = True    # 加入DICOM tag信息（不包含所有）    dt = datetime.datetime.now()    ds.ContentDate = dt    time_str = dt.strftime(&#39;%H%M%S.%f&#39;)    ds.ContentTime = time_str    # 生成StudyUID, SeriesUID, InstanceUID    ds.SOPClassUID = dicom[&#39;SOPClassUID&#39;]    ds.SOPInstanceUID = chguid(dicom[&#39;SOPInstanceUID&#39;])    ds.StudyInstanceUID = dicom[&#39;StudyInstanceUID&#39;]    ds.SeriesInstanceUID = dicom[&#39;SeriesInstanceUID&#39;] + &#39;.1&#39;    ds.InstanceNumber = index + 1    ds.SeriesNumber = str(int(dicom[&#39;SeriesNumber&#39;]) + 1)    # 指定影像参数    ds.Rows = img.size[1]    ds.Columns = img.size[0]    ds.SamplesPerPixel = 3    ds.PhotometricInterpretation = &quot;RGB&quot;    ds.HighBit = 7    ds.BitsStored = 8    ds.BitsAllocated = 8    ds.PixelRepresentation = 0    # 将img对象转换为bytes类型，写入PixelData字段    ds.PixelData = img.tobytes()    # 指定TransferSyntax等信息    ds.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRBigEndian    ds.is_little_endian = False    ds.is_implicit_VR = False    # 保存影像文件    file_name = &#39;report_{}.dcm&#39;.format(index)    file_path = os.path.join(dicom_dir, file_name)    ds.save_as(file_path)def main(pdf_path, dicom_dir):    # 将pdf转换为图片    images_list = convert_from_path(pdf_path)    # 从DICOM文件夹中读取最后一张影像的信息    dicom_info = read_dcm(dicom_dir)    # 创建DICOM影像并写入图片数据    for index, img in enumerate(images_list):        write_dcm(index, img, dicom_info, dicom_dir)if __name__ == &#39;__main__&#39;:    pdf_path = &#39;/home/ray/dcm_report/report.pdf&#39;    dicom_dir = &#39;/home/ray/dcm_report/dcm_data&#39;    main(pdf_path, dicom_dir)</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SimpleITK读取DICOM</title>
    <link href="/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/"/>
    <url>/2019/06/08/%E4%BD%BF%E7%94%A8SimpleITK%E8%AF%BB%E5%8F%96DICOM/</url>
    
    <content type="html"><![CDATA[<p>SimpleITK是ITK的简化接口，专门用于处理医学影像，在SimpleITK中，图像的概念与我们在计算机视觉中常用的RGB图像差异很大，后者只是一个多维矩阵，是一个数学上的概念，而在SimpleITK中，图像是一种物理实体，图像中的每一个像素都是物理空间中的一个点，不光有着像素值，还有着坐标，间距，方向等概念。本文将介绍python版SimpleITK读取DICOM并从DICOM study中提取需要的序列的方法。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install SimpleITK</code></p><h2 id="读取DICOM影像"><a href="#读取DICOM影像" class="headerlink" title="读取DICOM影像"></a>读取DICOM影像</h2><ul><li>读取单张DICOM影像</li></ul><pre><code class="python">import SimpleITK as sitkfile = sitk.ReadImage(filepath) # 图像大小file.GetSize()# 坐标原点file.GetOrigin()# 像素间距file.GetSpacing()# 方向file.GetDirection()# 获取影像元数据(返回DICOM tags元组)file.GetMetaDataKeys()# 像素矩阵pixel_array = sitk.GetArrayFromImage(file)</code></pre><ul><li>读取DICOM序列</li></ul><pre><code class="python">import osimport SimpleITK as sitkpath = &quot;/dicom_study_dir&quot;reader = sitk.ImageSeriesReader()seriesIDs = reader.GetGDCMSeriesIDs(path)dicom_names = reader.GetGDCMSeriesFileNames(path, seriesID[0])reader.SetFileNames(dicom_names)image = reader.Execute()</code></pre><h2 id="读取特定序列并保存为NIfTI格式"><a href="#读取特定序列并保存为NIfTI格式" class="headerlink" title="读取特定序列并保存为NIfTI格式"></a>读取特定序列并保存为NIfTI格式</h2><p>医学影像处理时，常常需要三维格式的数据，可以利用SimpleITK从DICOM study文件夹中提取需要的序列，并写入NIfTI文件。以下为示例：</p><pre><code class="python">import loggingimport osimport SimpleITK as sitk# 从DICOM影像中读取Tag信息def get_tag(dcm, key, default_value=&#39;&#39;):    try:        value = dcm.GetMetaData(key).strip()    except Exception as e:        logging.error(e)        value = default_value    return value# 从DICOM study文件夹中提取需要的序列并转换def extract_series(study_dir, series_desc):    # 获取所有series id,返回一个元组    series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(study_dir)    for series_id in series_ids:        # 获取该序列的所有DICOM影像，返回一个包含该序列所有影像路径的元组        files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(study_dir, series_id, recursive=False, useSeriesDetails=False)        reader = sitk.ImageSeriesReader()        reader.SetFileNames(files)        try:            img = reader.Execute()        except RuntimeError as e:            # 有的DICOM影像将一个序列所有影像都放在同一张DICOM文件中（MultiFrame），读取时会出现下面这个异常            if &#39;The file in the series have unsupported 3 dimensions&#39; in str(e):                img = sitk.ReadImage(files[0])            else:                logging.error(&#39;Error in reading image, dir %s, series id %s, detail message: %s&#39; % (study_dir, series_id, e))                continue        # 从当前序列取一张影像，便于读取其Tag信息                        dcm = sitk.ReadImage(files[0])        # 获取当前序列的序列描述        series_description = get_tag(dcm, &#39;0008|103e&#39;)        # 判断是否是需要的序列        if series_description == series_desc:            nii_name = str(series_id) + &quot;nii.gz&quot;            # 写入nii.gz文件            sitk.WriteImage(img, os.path.join(study_dir, nii_name))        else:            continue</code></pre>]]></content>
    
    
    <categories>
      
      <category>DICOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DICOM</tag>
      
      <tag>Python</tag>
      
      <tag>SimpleITK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django实现语言切换</title>
    <link href="/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/"/>
    <url>/2018/01/08/Django%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Django提供了实现多语言切换的中间件，可以实现模板（templates）、视图（views）以及JavaScript中语言的切换。基本的模式是在代码中对需要切换的内容加上标签，然后在翻译文件中填充翻译过后的字符串，最后编译即可。本文以中英文切换为例，介绍如果在Django中实现语言的切换。参考文档：<a href="https://djangobook-cn.readthedocs.io/en/latest/chapter19.html" target="_blank" rel="noopener">https://djangobook-cn.readthedocs.io/en/latest/chapter19.html</a></p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>首先在Django settings文件中加入中间件<code>django.middleware.locale.LocaleMiddleware</code></p><pre><code class="python">MIDDLEWARE = [  &#39;django.middleware.security.SecurityMiddleware&#39;,  &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,  # django语言国际化中间件  &#39;django.middleware.locale.LocaleMiddleware&#39;,  &#39;django.middleware.common.CommonMiddleware&#39;,  &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,  &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,  &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,  &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,]</code></pre></li><li><p>然后增加<code>LANGUAGES</code>和<code>LOCALE_PATHS</code>配置，<code>locale</code>文件夹需要手动创建：</p><pre><code class="python">LANGUAGES = (  (&#39;zh-hans&#39;, &#39;中文简体&#39;),  (&#39;en&#39;, &#39;English&#39;),)</code></pre></li></ul><p>LOCALE_PATHS = (<br>    os.path.join(os.path.dirname(BASE_DIR), ‘locale’),<br>)</p><pre><code>## 修改html模板文件- 首先需要在每个html第一行加入以下代码，可以将它放在公共页面```python{% load i18n %}</code></pre><ul><li><p>在需要翻译的字符串上加上trans标签,例如：</p><pre><code class="python">&lt;li&gt;&lt;a href=&quot;/management/language_set&quot;&gt;&lt;i class=&quot;ti-settings&quot;&gt;&lt;/i&gt; {% trans '语言设置' %}&lt;/a&gt;&lt;/li&gt;</code></pre></li><li><p>多次重复翻译的内容可以设置成常量：</p><pre><code class="python">{% trans "This is the title" as the_title %}&lt;title&gt;{{ the_title }}&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;{{ the_title }}&quot;&gt;</code></pre></li><li><p>如果翻译的内容有django模板输出的变量，就需要用blocktrans和endblocktrans，例如：</p><pre><code class="html">{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}</code></pre></li></ul><h2 id="后端视图"><a href="#后端视图" class="headerlink" title="后端视图"></a>后端视图</h2><ul><li>如果Django后端视图中有返回中文字符串也需要切换成英文，可以利用django的<code>gettext</code>模块，代码示例如下：<pre><code class="python">from django.utils.translation import gettext as _</code></pre></li></ul><p>def test_views(request):<br>    response_str = _(“中文字符串”)<br>    return HttpResponse(response_str)</p><pre><code>- 需要注意，Django渲染模板时需要使用`render`而不是`render_to_response`## JavaScript中的语言转换- 首先在根`urls.py`文件中的`urlpatterns`列表中添加如下代码：```pythonurl(r&#39;^jsi18n/$&#39;, JavaScriptCatalog.as_view(packages=[&#39;ProjectName&#39;]), name=&#39;javascript-catalog&#39;)</code></pre><ul><li><p>然后在模板中引入js(可放在公共页面)</p><pre><code class="python">&lt;script type=&quot;text/javascript&quot; src=&quot;{% url 'javascript-catalog' %}&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>使用<code>gettext</code>在js中标记字符串，例如：</p><pre><code class="javascript">function editpwd(){      layer.open({        type: 1,        title: gettext(&#39;修改密码&#39;),        maxmin: true,        shadeClose: true, //点击遮罩关闭层        area : [&#39;550px&#39; , &#39;&#39;],        content:$(&#39;#addsort_style&#39;),     })  }</code></pre></li><li><p>需要注意，必须将JavaScript代码单独放在.js文件中，不能写在html代码后面，否则后面生成翻译文件时检测不到</p></li></ul><h2 id="翻译文件生成与编译"><a href="#翻译文件生成与编译" class="headerlink" title="翻译文件生成与编译"></a>翻译文件生成与编译</h2><ul><li>添加完翻译的标记后，执行以下命令即可在<code>locale</code>文件夹下生成翻译文件：</li></ul><p><code>python manage.py makemessages -l en</code><br><code>python manage.py makemessages -d djangojs -l en</code></p><ul><li><p>执行成功后可以发现生成了<code>django.po</code>以及<code>djangojs.po</code>文件，然后就可以填充翻译后的字符串：</p><pre><code class="python">#: DrBrain3/templates/Management/series_list.html:46#: DrBrain3/templates/Users/new_psw.html:89msgid &quot;确认修改&quot;msgstr &quot;Confirm the changes&quot;</code></pre><p>需要注意，有时由于识别的错乱，执行<code>python manage.py makemessages -l en</code>后.po文件中会出现fuzzy的字眼，此时需要将.po文件中这些出现错乱的都删除，正确的翻译文件如上图所示</p></li><li><p>填充完所有翻译后的字符串，就可以执行编译命令生成.mo文件</p></li></ul><p><code>python manage.py compilemessages</code></p><h2 id="如何切换语言"><a href="#如何切换语言" class="headerlink" title="如何切换语言"></a>如何切换语言</h2><p>Django本身提供了语言切换的功能，可参考如下方法实现：</p><ul><li><p>在项目根路由文件<code>urls.py</code>中添加切换语言的url</p><pre><code class="python">url(r&#39;^i18n/&#39;,include(&#39;django.conf.urls.i18n&#39;))</code></pre></li><li><p>html页面中添加如下form表单</p><pre><code class="python">&lt;form action=&quot;{% url 'set_language' %}&quot; method=&quot;post&quot; id=&quot;change_language_form&quot; enctype=&quot;multipart/form-data&quot;&gt;  {% csrf_token %}  &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot;/&gt;  &lt;select class=&quot;change_language&quot; name=&quot;language&quot; id=&quot;language&quot; onclick=&quot;changeLan()&quot;&gt;      {% for lang in LANGUAGES %}        <option value="{{ lang.0 }}"{% ifequal lang.0 LANGUAGE_CODE %} selected {% endifequal %}>{{ lang.1 }}</option>{% endfor %}  &lt;/select&gt;&lt;/form&gt;</code></pre></li><li><p>JavaScript代码</p><pre><code class="javascript">$(&#39;.change_language&#39;).change(function (e) {  e.preventDefault();  $(&#39;#change_language_form&#39;).submit();  return false</code></pre></li></ul><p>});</p><pre><code>- 登录时记录用户选择的语言在用户登录的后端视图中加入：```pythonrequest.session[&#39;_language&#39;]=&#39;zh-hans&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django实现单设备登录限制</title>
    <link href="/2017/09/05/Django%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/"/>
    <url>/2017/09/05/Django%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本文旨在介绍Django项目实现单设备登录限制的一种方法，基于Django的session机制。</p><a id="more"></a><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>要保证同一账号只能在一台设备登录，基本思路就是维护一个用户登录状态记录，用户每次请求或登录时，先从登录状态记录中查询，如果该账号已经在其他设备登录，则删除或禁止之前的记录。</p><h2 id="使用Mysql数据表"><a href="#使用Mysql数据表" class="headerlink" title="使用Mysql数据表"></a>使用Mysql数据表</h2><p>为保证用户账号安全，限制同一账号只能在唯一一台设备登录，之前的实现思路是建立一个用户登录状态数据表，每次用户登录都根据用户id查询，判断是否有用户id相同的记录，有则删除，同时，在用户请求后端视图时，从session中取出用户id，再查询登录状态记录表，如果该session对应的记录已被删除，则失效该session。<br>实际测试时发现，维护用户登录状态记录表过于繁琐，并且由于用户每次请求都需要查询数据库，对性能也有一定影响，该方案不太可行。</p><h2 id="使用Redis缓存session"><a href="#使用Redis缓存session" class="headerlink" title="使用Redis缓存session"></a>使用Redis缓存session</h2><p>Django项目可以使用Redis作为缓存数据库，Redis是内存数据库，它读写速度快、灵活方便的特点很适合少量数据频繁读写。因此，可以将session保存在Redis中，用户登录时，首先生成session，然后查询是否有用户id相同的记录，如果用户id相同而session_key不同，则说明该账号已经在其他地方登录，此时直接删除之前的session，只保留当前session，因此之前登录的用户就会被挤出。关键代码如下：</p><pre><code class="python"># 获取当前session的session_keysession_key = request.session.session_key# 获取Redis中所有keykey_list = cache.keys(&quot;*&quot;)# 遍历获取到的所有key，通过正则筛选django的session记录for key in key_list:    s_key = re.match(r&#39;django\.contrib\.sessions\.cache(.*)&#39;, key)    # 如果session_key和当前session不同，则进行判断    if s_key and s_key.group(1) != session_key:        cache_session_dict = cache.get(key)        # 如果session信息中保存的user_id和当前用户id相同，则表明该账号已登录        if cache_session_dict.get(&#39;user_id&#39;) == user.id:            cache.delete(key)            logger.info(&#39;Account [{}] has logged in elsewhere, delete old session [{}]&#39;.format(username, key))            else:                continue</code></pre><h2 id="视图装饰器"><a href="#视图装饰器" class="headerlink" title="视图装饰器"></a>视图装饰器</h2><p>为了实现登录状态的判断，可以在Django视图上加上装饰器，从而判断每次request对应的session是否被删除，同时进行其他权限校验。</p><pre><code class="python">def auth_required(perm):    def decorator(view_func):        def _wrapped_view(request, *args, **kwargs):            try:                session_key = request.session.session_key                # session_flag = Session.objects.filter(session_key=session_key)                if not session_key:                    return JsonResponse({&quot;respCode&quot;: 4001})                else:                    role = request.session.get(&quot;role_id&quot;)                    if not role:                        return JsonResponse({&quot;respCode&quot;: 4002})                    else:                        if int(role) &gt; int(perm):                            return JsonResponse({&quot;respCode&quot;: 4003})            except Exception as e:                logger.error(e)                return JsonResponse({&quot;respCode&quot;: 4004})            return view_func(request, *args, **kwargs)        return _wrapped_view    return decorator</code></pre>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
